[
    {
        "file_name": "fht_1d_x8.v",
        "verilog_design": "`include \"fht_bfly_noFF.v\" `include \"fht_bfly.v\" module fht_1d_x8( rstn, sclk, x_valid, x_data, fht_valid, fht_data ); parameter N = 8; input rstn; input sclk; input x_valid; input [N-1:0] x_data; output fht_valid; output [N+2:0] fht_data; reg [N-1:0] x0,x1,x2,x3,x4,x5,x6,x7; always @(posedge sclk or negedge rstn) if (!rstn) begin x0 <= #1 0; x1 <= #1 0; x2 <= #1 0; x3 <= #1 0; x4 <= #1 0; x5 <= #1 0; x6 <= #1 0; x7 <= #1 0; end else if (x_valid) begin x0 <= #1 x_data; x1 <= #1 x0; x2 <= #1 x1; x3 <= #1 x2; x4 <= #1 x3; x5 <= #1 x4; x6 <= #1 x5; x7 <= #1 x6; end reg x_valid_1d; always @(posedge sclk or negedge rstn) if (!rstn) x_valid_1d <= #1 0; else x_valid_1d <= #1 x_valid; wire xi_ready; reg [2:0] cnt; always @(posedge sclk or negedge rstn) if (!rstn) cnt <= #1 0; else if (x_valid_1d) cnt <= #1 cnt + 1; assign xi_ready = (cnt == 7 && x_valid_1d) ? 1'b1 : 1'b0; reg [N-1:0] x0_FF,x1_FF,x2_FF,x3_FF,x4_FF,x5_FF,x6_FF,x7_FF; always @(posedge sclk or negedge rstn) if (!rstn) begin x0_FF <= #1 0; x1_FF <= #1 0; x2_FF <= #1 0; x3_FF <= #1 0; x4_FF <= #1 0; x5_FF <= #1 0; x6_FF <= #1 0; x7_FF <= #1 0; end else if (xi_ready) begin x0_FF <= #1 x7; x1_FF <= #1 x6; x2_FF <= #1 x5; x3_FF <= #1 x4; x4_FF <= #1 x3; x5_FF <= #1 x2; x6_FF <= #1 x1; x7_FF <= #1 x0; end reg [13:0] xi_ready_d; always @(posedge sclk or negedge rstn) if (!rstn) xi_ready_d[13:0] <= #1 0; else xi_ready_d[13:0] <= #1 {xi_ready_d[12:0],xi_ready}; wire [N:0] stg1_sum1; wire [N:0] stg1_sum2; wire [N:0] stg1_sum3; wire [N:0] stg1_sum4; wire [N:0] stg1_sub1; wire [N:0] stg1_sub2; wire [N:0] stg1_sub3; wire [N:0] stg1_sub4; fht_bfly_noFF #(N) u11_fht_bfly (.a({x0_FF}),.b({x4_FF}),.c(stg1_sum1),.d(stg1_sub1)); fht_bfly_noFF #(N) u12_fht_bfly (.a({x1_FF}),.b({x5_FF}),.c(stg1_sum2),.d(stg1_sub2)); fht_bfly_noFF #(N) u13_fht_bfly (.a({x2_FF}),.b({x6_FF}),.c(stg1_sum3),.d(stg1_sub3)); fht_bfly_noFF #(N) u14_fht_bfly (.a({x3_FF}),.b({x7_FF}),.c(stg1_sum4),.d(stg1_sub4)); wire [N+1:0] stg2_sum1; wire [N+1:0] stg2_sum2; wire [N+1:0] stg2_sum3; wire [N+1:0] stg2_sub1; wire [N+1:0] stg2_sub2; wire [N+1:0] stg2_sub3; fht_bfly #(N+1) u21_fht_bfly (.rstn(rstn),.clk(sclk),.valid(xi_ready_d[1]),.a(stg1_sum1),.b(stg1_sum3),.c(stg2_sum1),.d(stg2_sub1)); fht_bfly #(N+1) u22_fht_bfly (.rstn(rstn),.clk(sclk),.valid(xi_ready_d[1]),.a(stg1_sum2),.b(stg1_sum4),.c(stg2_sum2),.d(stg2_sub2)); fht_bfly #(N+1) u23_fht_bfly (.rstn(rstn),.clk(sclk),.valid(xi_ready_d[1]),.a(stg1_sub1),.b(stg1_sub3),.c(stg2_sum3),.d(stg2_sub3)); wire [N:0] mult_dat_1; wire [N:0] mult_dat_2; assign mult_dat_1 = stg1_sub2; assign mult_dat_2 = stg1_sub4; wire [N+1:0] mult_res1; wire [N+1:0] mult_res2; `ifdef USE_ASIC_MULT signed_mult_const_asic #(N+1) u_mult_1_fht (rstn,sclk,xi_ready_d[1],mult_dat_1,mult_res1); signed_mult_const_asic #(N+1) u_mult_2_fht (rstn,sclk,xi_ready_d[1],mult_dat_2,mult_res2); `elsif USE_FPGA_MULT signed_mult_const_fpga #(N+1) u_mult_1_fht (rstn,sclk,xi_ready_d[1],mult_dat_1,mult_res1); signed_mult_const_fpga #(N+1) u_mult_2_fht (rstn,sclk,xi_ready_d[1],mult_dat_2,mult_res2); `endif wire [N+2:0] stg3_sum1; wire [N+2:0] stg3_sum2; wire [N+2:0] stg3_sum3; wire [N+2:0] stg3_sum4; wire [N+2:0] stg3_sub1; wire [N+2:0] stg3_sub2; wire [N+2:0] stg3_sub3; wire [N+2:0] stg3_sub4; fht_bfly #(N+2) u31_fht_bfly (.rstn(rstn),.clk(sclk),.valid(xi_ready_d[3]),.a(stg2_sum1),.b(stg2_sum2),.c(stg3_sum1),.d(stg3_sub1)); fht_bfly #(N+2) u32_fht_bfly (.rstn(rstn),.clk(sclk),.valid(xi_ready_d[3]),.a(stg2_sub1),.b(stg2_sub2),.c(stg3_sum2),.d(stg3_sub2)); fht_bfly #(N+2) u33_fht_bfly (.rstn(rstn),.clk(sclk),.valid(xi_ready_d[3]),.a(stg2_sum3),.b(mult_res1),.c(stg3_sum3),.d(stg3_sub3)); fht_bfly #(N+2) u34_fht_bfly (.rstn(rstn),.clk(sclk),.valid(xi_ready_d[3]),.a(stg2_sub3),.b(mult_res2),.c(stg3_sum4),.d(stg3_sub4)); reg [N+2:0] h0_FF,h1_FF,h2_FF,h3_FF,h4_FF,h5_FF,h6_FF,h7_FF; always @(posedge sclk or negedge rstn) if (!rstn) begin h0_FF <= #1 0; h4_FF <= #1 0; h2_FF <= #1 0; h6_FF <= #1 0; h1_FF <= #1 0; h5_FF <= #1 0; h3_FF <= #1 0; h7_FF <= #1 0; end else if (xi_ready_d[5]) begin h0_FF <= #1 stg3_sum1; h4_FF <= #1 stg3_sub1; h2_FF <= #1 stg3_sum2; h6_FF <= #1 stg3_sub2; h1_FF <= #1 stg3_sum3; h5_FF <= #1 stg3_sub3; h3_FF <= #1 stg3_sum4; h7_FF <= #1 stg3_sub4; end wire h0_valid; wire h1_valid; wire h2_valid; wire h3_valid; wire h4_valid; wire h5_valid; wire h6_valid; wire h7_valid; assign h0_valid = xi_ready_d[6]; assign h1_valid = xi_ready_d[7]; assign h2_valid = xi_ready_d[8]; assign h3_valid = xi_ready_d[9]; assign h4_valid = xi_ready_d[10]; assign h5_valid = xi_ready_d[11]; assign h6_valid = xi_ready_d[12]; assign h7_valid = xi_ready_d[13]; wire fht_valid_or; assign fht_valid_or = h0_valid | h1_valid | h2_valid | h3_valid | h4_valid | h5_valid | h6_valid | h7_valid ; wire [N+2:0] h_or_data; assign h_or_data = (h0_FF & {N+3{h0_valid}}) | (h1_FF & {N+3{h1_valid}}) | (h2_FF & {N+3{h2_valid}}) | (h3_FF & {N+3{h3_valid}}) | (h4_FF & {N+3{h4_valid}}) | (h5_FF & {N+3{h5_valid}}) | (h6_FF & {N+3{h6_valid}}) | (h7_FF & {N+3{h7_valid}}) ; reg [N+2:0] fht_data; reg fht_valid; always @(posedge sclk or negedge rstn) if (!rstn) fht_valid <= #1 0; else fht_valid <= #1 fht_valid_or; always @(posedge sclk or negedge rstn) if (!rstn) fht_data <= #1 0; else fht_data <= #1 h_or_data; endmodule"
    },
    {
        "file_name": "fht_8x8_core.v",
        "verilog_design": "`include \"fht_1d_x8.v\" `include \"mtx_trps_8x8_dpsram.v\" module fht_8x8_core ( rstn, sclk, x_valid, x_data, fht_2d_valid, fht_2d_data ); parameter N = 8; input rstn; input sclk; input x_valid; input [N-1:0] x_data; output fht_2d_valid; output [N+5:0] fht_2d_data; wire fht_1d_valid; wire [N+2:0] fht_1d_data; fht_1d_x8 #(N) u1_fht_1d_x8_1st( .rstn (rstn), .sclk (sclk), .x_valid (x_valid), .x_data (x_data), .fht_valid (fht_1d_valid), .fht_data (fht_1d_data) ); wire mem_valid; wire [N+2:0] mem_data; mtx_trps_8x8_dpsram #(N+3) u2_mtx_ts ( .rstn (rstn), .sclk (sclk), .inp_valid (fht_1d_valid), .inp_data (fht_1d_data), .mem_data (mem_data), .mem_valid (mem_valid) ); fht_1d_x8 #(N+3) u3_fht_1d_x8_2nd( .rstn (rstn), .sclk (sclk), .x_valid (mem_valid), .x_data (mem_data), .fht_valid (fht_2d_valid), .fht_data (fht_2d_data) ); endmodule"
    },
    {
        "file_name": "fht_bfly.v",
        "verilog_design": "module fht_bfly( rstn, clk, valid, a, b, c, d ); parameter N = 8; input rstn; input clk; input valid; input [N-1:0] a; input [N-1:0] b; output [N :0] c; output [N :0] d; reg [N-1:0] a_FF; always @(posedge clk) if (!rstn) a_FF <= #1 0; else if (valid) a_FF <= #1 a; reg [N-1:0] b_FF; always @(posedge clk) if (!rstn) b_FF <= #1 0; else if (valid) b_FF <= #1 b; assign c = rca_N(a_FF,b_FF); assign d = rca_N(a_FF,twos_complement(b_FF)); function [1:0] full_adder; input a, b, ci; reg co, s; begin s = (a ^ b ^ ci); co = (a & b) | (ci & (a ^ b)); full_adder = {co,s}; end endfunction function [1:0] half_adder; input a, b; reg co, s; begin s = (a ^ b); co = (a & b); half_adder = {co,s}; end endfunction function [N:0] rca_N; input [N-1:0] a; input [N-1:0] b; reg [N-1:0] co,sum; begin : RCA integer i; for (i = 0; i < N; i = i + 1) if (i == 0) {co[i],sum[i]} = half_adder(a[i],b[i]); else {co[i],sum[i]} = full_adder(a[i],b[i],co[i-1]); rca_N[N-1:0] = sum; rca_N[N] = (a[N-1]==b[N-1]) ? co[N-1] : sum[N-1]; end endfunction function [N-1:0] twos_complement; input [N-1:0] a; reg [N-1:0] ainv; reg [N:0] plus1; begin ainv = ~a; plus1 = rca_N(ainv,{{N-1{1'b0}},1'b1}); if (a == {1'b1, {N-1{1'b0}}}) $display(\"--->>> 2's complement ERROR - absolute minimum negative value: %0b\\n\\t %m\",a); twos_complement = plus1[N-1:0]; end endfunction endmodule"
    },
    {
        "file_name": "fht_bfly_noFF.v",
        "verilog_design": "module fht_bfly_noFF( rstn, clk, valid, a, b, c, d ); parameter N = 8; input rstn; input clk; input valid; input [N-1:0] a; input [N-1:0] b; output [N :0] c; output [N :0] d; reg [N-1:0] a_FF; always @(posedge clk) if (!rstn) a_FF <= #1 0; else if (valid) a_FF <= #1 a; reg [N-1:0] b_FF; always @(posedge clk) if (!rstn) b_FF <= #1 0; else if (valid) b_FF <= #1 b; assign c = rca_N(a_FF,b_FF); assign d = rca_N(a_FF,twos_complement(b_FF)); function [1:0] full_adder; input a, b, ci; reg co, s; begin s = (a ^ b ^ ci); co = (a & b) | (ci & (a ^ b)); full_adder = {co,s}; end endfunction function [1:0] half_adder; input a, b; reg co, s; begin s = (a ^ b); co = (a & b); half_adder = {co,s}; end endfunction function [N:0] rca_N; input [N-1:0] a; input [N-1:0] b; reg [N-1:0] co,sum; begin : RCA integer i; for (i = 0; i < N; i = i + 1) if (i == 0) {co[i],sum[i]} = half_adder(a[i],b[i]); else {co[i],sum[i]} = full_adder(a[i],b[i],co[i-1]); rca_N[N-1:0] = sum; rca_N[N] = (a[N-1]==b[N-1]) ? co[N-1] : sum[N-1]; end endfunction function [N-1:0] twos_complement; input [N-1:0] a; reg [N-1:0] ainv; reg [N:0] plus1; begin ainv = ~a; plus1 = rca_N(ainv,{{N-1{1'b0}},1'b1}); if (a == {1'b1, {N-1{1'b0}}}) $display(\"--->>> 2's complement ERROR - absolute minimum negative value: %0b\\n\\t %m\",a); twos_complement = plus1[N-1:0]; end endfunction endmodule"
    },
    {
        "file_name": "mtx_trps_8x8_dpsram.v",
        "verilog_design": "module mtx_trps_8x8_dpsram ( rstn, sclk, inp_valid, inp_data, mem_data, mem_valid ); parameter N = 8; input rstn; input sclk; input inp_valid; input [N-1:0] inp_data; output [N-1:0] mem_data; output mem_valid; reg [6:0] cnt128d_wr; wire indicator; reg indicator_1d; wire indicator_pos_edge; wire indicator_neg_edge; reg [6:0] cnt128d_rd; wire cnt128d_rd_valid_start; wire cnt128d_rd_valid_stop; reg cnt128d_rd_valid; reg mem_valid; wire [15:0] wr_DATA; wire [ 6:0] wr_ADDR; wire wr_CSN; wire wr_WEN; wire [ 6:0] rd_ADDR; wire rd_CSN; wire [15:0] rd_DATA; `ifdef USE_FPGA_SPSRAM dpsram_128x16 u_dpsram( .addra (wr_ADDR), .addrb (rd_ADDR), .clka (sclk), .clkb (sclk), .dina (wr_DATA), .dinb ({16{1'b0}}), .douta (), .doutb (rd_DATA), .ena (wr_CSN), .enb (rd_CSN), .wea (wr_WEN), .web (1'b1) ); `endif `ifdef USE_ASIC_SPSRAM reg [15:0] rd_DATA = 16'd0; reg [15:0] sram[0:127]; always @(posedge sclk) if (~wr_WEN && ~wr_CSN) sram[wr_ADDR] <= wr_DATA; always @(posedge sclk) if ( 1'b1 && ~rd_CSN) rd_DATA <= sram[rd_ADDR]; `endif always @(posedge sclk or negedge rstn) if (!rstn) cnt128d_wr <= #1 0; else if (inp_valid) cnt128d_wr <= #1 cnt128d_wr + 1; assign wr_DATA = {{16-N{1'b0}},inp_data}; assign wr_ADDR = cnt128d_wr; assign wr_CSN = ~inp_valid; assign wr_WEN = ~inp_valid; assign indicator = cnt128d_wr[6]; always @(posedge sclk or negedge rstn) if (!rstn) indicator_1d <= #1 1'b0; else indicator_1d <= #1 indicator; assign indicator_pos_edge = indicator & ~indicator_1d; assign indicator_neg_edge = ~indicator & indicator_1d; assign cnt128d_rd_valid_start = indicator_pos_edge | indicator_neg_edge; assign cnt128d_rd_valid_stop = (cnt128d_rd[5:0] == 63) ? 1'b1 : 1'b0; always @(posedge sclk or negedge rstn) if (!rstn) cnt128d_rd_valid <= #1 1'b0; else if (cnt128d_rd_valid_start)cnt128d_rd_valid <= #1 1'b1; else if (cnt128d_rd_valid_stop) cnt128d_rd_valid <= #1 1'b0; always @(posedge sclk or negedge rstn) if (!rstn) cnt128d_rd <= #1 1'b0; else if (cnt128d_rd_valid) cnt128d_rd <= #1 cnt128d_rd + 1; assign rd_ADDR = {cnt128d_rd[6],cnt128d_rd[2:0],cnt128d_rd[5:3]}; assign rd_CSN = ~cnt128d_rd_valid; always @(posedge sclk or negedge rstn) if (!rstn) mem_valid <= #1 1'b0; else mem_valid <= #1 cnt128d_rd_valid; assign #1 mem_data = rd_DATA[7:0]; endmodule"
    },
    {
        "file_name": "signed_mult_const_asic.v",
        "verilog_design": "module signed_mult_const_asic ( rstn, clk, valid, a, p ); parameter N = 8; input rstn; input clk; input valid; input [N-1:0] a; output [N :0] p; parameter mult_constant = 9'd362; reg [N-1:0] a_FF; always @(posedge clk) if (!rstn) a_FF <= #1 0; else if (valid) a_FF <= #1 a; wire [N-1:0] b; assign b = a_FF[N-1] ? {~a_FF[N-1:0] + {{N-1{1'b0}},1'b1} } : a_FF[N-1:0]; wire [N+7:0] mult_wo_sign; assign mult_wo_sign = b[N-2:0]*mult_constant; wire [N-1:0] div256; assign div256 = mult_wo_sign >> 8; assign p = a_FF[N-1] ? {1'b1,{~div256[N-1:0] + {{N-1{1'b0}},1'b1}} } : {1'b0, div256[N-1:0]} ; endmodule"
    },
    {
        "file_name": "signed_mult_const_fpga.v",
        "verilog_design": "module signed_mult_const_fpga ( rstn, clk, valid, a, p ); parameter N = 8; input rstn; input clk; input valid; input signed [N-1:0] a; output signed [N :0] p; parameter mult_constant = {1'b0, 17'd92681}; reg signed [N-1:0] a_FF; always @(posedge clk) if (!rstn) a_FF <= #1 0; else if (valid) a_FF <= #1 a; wire signed [(16+1)+N-1:0] p_tmp = $signed(a_FF) * $signed(mult_constant); assign p = p_tmp >> 16; endmodule"
    },
    {
        "file_name": "accMUX.v",
        "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module accumulatorMUX (accMuxSel, immData, aluOut `ifdef timerAndCounter_peripheral , tcLoadIn, tcAccIn `endif `ifdef UART_peripheral , uartDataIn, uartStatIn `endif , accMuxOut ); input [`accMuxSelLen-1:0] accMuxSel; input [`immDataLen-1:0] immData; input [7:0] aluOut; `ifdef timerAndCounter_peripheral input [7:0] tcLoadIn, tcAccIn; `endif `ifdef UART_peripheral input [7:0] uartDataIn, uartStatIn; `endif output [7:0] accMuxOut; reg [7:0] accMuxOut; always @ * begin case (accMuxSel) `accMuxSelImmData : begin accMuxOut = immData; end `accMuxSelAluOut : begin accMuxOut = aluOut; end `ifdef timerAndCounter_peripheral `accMuxSelTcLoad : begin accMuxOut = tcLoadIn; end `accMuxSelTcAcc : begin accMuxOut = tcAccIn; end `endif `ifdef UART_peripheral `accMuxSelUartData : begin accMuxOut = uartDataIn; end `accMuxSelUartStat : begin accMuxOut = uartStatIn; end `endif default : begin accMuxOut = 8'bzzzzzzzz; end endcase end endmodule"
    },
    {
        "file_name": "bitNegator.v",
        "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module bitNegator (bitIn, bitN, bitOut); input bitIn, bitN; output bitOut; reg bitOut; always @ (bitIn or bitN) begin if (bitN) begin bitOut = ~ bitIn; end else begin bitOut = bitIn; end end endmodule"
    },
    {
        "file_name": "ramBit.v",
        "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module bitRam (clk, reset, bitRamEn, bitRamRw, bitRamIn, bitRamAddr, bitRamOut); input clk, reset, bitRamEn, bitRamRw, bitRamIn; input [`bitRamAddrLen-1:0] bitRamAddr; output bitRamOut; reg bitRam [`bitRamDepth-1:0]; reg bitRamOut; always @ (posedge clk or posedge reset) begin if (reset) begin bitRamOut = 1'b0; $write (\"\\nmodule bitRam is reset \"); end else begin if (bitRamEn) begin if (bitRamRw) begin bitRamOut = bitRam[bitRamAddr]; end else begin bitRam[bitRamAddr] = bitRamIn; end end else begin bitRamOut = 1'bZ; end end end endmodule"
    },
    {
        "file_name": "byteNegator.v",
        "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module byteNegator (byteIn, byteN, byteOut); input [7:0] byteIn; input byteN; output [7:0] byteOut; reg [7:0] byteOut; always @ (byteIn or byteN) begin if (byteN) begin byteOut = ~ byteIn; end else begin byteOut = byteIn; end end endmodule"
    },
    {
        "file_name": "ramByte.v",
        "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module byteRam (clk, reset, byteRamEn, byteRamRw, byteRamIn, byteRamAddr, byteRamOut); input clk, reset, byteRamEn, byteRamRw; input [`byteRamLen-1:0] byteRamIn; input [`byteRamAddrLen-1:0] byteRamAddr; output [`byteRamLen-1:0] byteRamOut; reg [`byteRamLen-1:0] byteRam [`byteRamDepth-1:0]; reg [`byteRamLen-1:0] byteRamOut; always @ (posedge clk or posedge reset) begin if (reset) begin byteRamOut = `byteRamLen'b0; $write (\"\\nmodule byteRam is reset \"); end else begin if (byteRamEn) begin if (byteRamRw) begin byteRamOut = byteRam[byteRamAddr]; end else begin byteRam[byteRamAddr] = byteRamIn; end end else begin byteRamOut = `byteRamLen'bz; end end end endmodule"
    },
    {
        "file_name": "inputReg.v",
        "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module inputRegister (inputs, inputReadAddr, inputReadOut); input [`inputNumber-1:0] inputs; input [`inputAddrLen-1:0] inputReadAddr; output inputReadOut; wire [`inputNumber-1:0] inputs; assign inputReadOut = inputs[inputReadAddr]; endmodule"
    },
    {
        "file_name": "outputReg.v",
        "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module outputReg (reset, outputRw, outputRwAddr, outputWriteIn, outputReadOut, outputs); input reset, outputRw; input [`outputAddrLen-1:0] outputRwAddr; input outputWriteIn; output outputReadOut; output wire [`outputNumber-1:0] outputs; reg outputReadOut; reg [`outputNumber-1 :0] outputReg = 0; always @ (reset or outputRw or outputRwAddr or outputWriteIn or outputReg) begin if (reset) begin outputReadOut = 1'bz; $write (\"\\nmodule outputRegister is reset \"); end else begin if (outputRw) begin outputReadOut = outputReg[outputRwAddr]; end else begin outputReg[outputRwAddr] = outputWriteIn; $write (\"\\nwriting to the output register : module outputRegister \"); end end end assign outputs = outputReg; endmodule"
    },
    {
        "file_name": "ppReg1.v",
        "verilog_design": "`include \"defines.v\" module ppReg1 (clk, opcodeIn, fieldIn, opcodeOut, fieldOut); input clk; input [`instOpCodeLen-1:0] opcodeIn; input [`instFieldLen-1:0] fieldIn; output [`instOpCodeLen-1:0] opcodeOut; output [`instFieldLen-1:0] fieldOut; reg [`instOpCodeLen-1:0] opcodeOut; reg [`instFieldLen-1:0] fieldOut; always @ (posedge clk) begin opcodeOut = opcodeIn; fieldOut = fieldIn; end endmodule"
    },
    {
        "file_name": "tcLoad.v",
        "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module tcLoad (tcAddr, dnIn, ttIn, cuIn, cdIn, tcLoadOut); input [`tcAddrLen-1:0] tcAddr; input [`tcNumbers-1:0] dnIn, ttIn, cuIn, cdIn; output [7:0] tcLoadOut; wire dnSel, ttSel, cuSel, cdSel; assign dnSel = dnIn[tcAddr]; assign ttSel = ttIn[tcAddr]; assign cuSel = cuIn[tcAddr]; assign cdSel = cdIn[tcAddr]; assign tcLoadOut = {4'b0, cdSel, cuSel, ttSel, dnSel}; endmodule"
    },
    {
        "file_name": "tcReset.v",
        "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module tcReset (tcResetEn, resetIn, tcAddr, resetOut); input tcResetEn, resetIn; input [`tcAddrLen-1:0] tcAddr; output [`tcNumbers-1:0] resetOut; reg [`tcNumbers-1:0] resets; always @ (posedge tcResetEn) begin if (tcResetEn) begin resets[tcAddr] = resetIn; end end assign resetOut = resets; endmodule"
    },
    {
        "file_name": "uartRec.v",
        "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module uartRec(clk, reset, sTick, rx, rxDoneTick, dOut); parameter dataBits = `dataBits; parameter sbTick = `sbTick; input clk, reset, sTick, rx; output rxDoneTick; output [dataBits-1:0] dOut; reg rxDoneTick; localparam idle = 2'b00, start = 2'b01, data = 2'b10, stop = 2'b11; reg [1:0] stateReg, stateNext; reg [3:0] sReg, sNext; reg [2:0] nReg, nNext; reg [7:0] bReg, bNext; always @ (posedge clk or posedge reset) begin if (reset) begin stateReg <= idle; sReg <= 1'b0; bReg <= 1'b0; nReg <= 1'b0; end else begin stateReg <= stateNext; sReg <= sNext; bReg <= bNext; nReg <= nNext; end end always @ * begin stateNext = stateReg; sNext = sReg; bNext = bReg; nNext = nReg; rxDoneTick = 1'b0; case (stateReg) idle : if (~rx) begin stateNext = start; sNext = 0; end start : if (sTick) if (sReg == 7) begin stateNext = data; sNext = 0; nNext = 0; end else sNext = sReg + 1; data : if (sTick) if (sReg == 15) begin sNext = 0; bNext = {rx, bReg[7:1]}; if (nReg == (dataBits-1)) stateNext = stop; else nNext = nReg + 1; end else sNext = sReg + 1; stop : if (sTick) if (sReg == (sbTick-1)) begin stateNext = idle; rxDoneTick = 1'b1; end else sNext = sReg + 1; endcase end assign dOut = bReg; endmodule"
    },
    {
        "file_name": "uartTrans.v",
        "verilog_design": "`include \"timescale.v\" `include \"defines.v\" module uartTrans (clk, reset, sTick, txDoneTick, din, tx, txStart); parameter dataBits = `dataBits; parameter sbTick = `sbTick; input [dataBits-1 :0] din; input clk, reset, sTick, txStart; output tx, txDoneTick; reg txDoneTick; localparam [1:0] idle = 2'b00, start = 2'b01, data = 2'b10, stop = 2'b11; reg [1:0] stateReg, stateNext; reg [3:0] sReg, sNext; reg [2:0] nReg, nNext; reg [7:0] bReg, bNext; reg txReg, txNext; always @ (posedge clk or posedge reset) begin if (reset) begin stateReg <= idle; sReg <= 1'b0; bReg <= 1'b0; nReg <= 1'b0; txReg <= 1'b1; end else begin stateReg <= stateNext; sReg <= sNext; bReg <= bNext; nReg <= nNext; txReg <= txNext; end end always @ * begin stateNext = stateReg; sNext = sReg; bNext = bReg; nNext = nReg; txNext = txReg; txDoneTick = 1'b0; case (stateReg) idle : begin txNext = 1'b1; if (txStart) begin txDoneTick = 1'b1; stateNext = start; sNext = 0; end end start : begin txNext = 0; txDoneTick = 1'b0; bNext = din; if (sTick) if (sReg == 15) begin stateNext = data; sNext = 1'b0; nNext = 1'b0; end else sNext = sReg + 1; end data : begin txNext = bReg[0]; if (sTick) if (sReg == 15) begin sNext = 0; bNext = bReg >> 1; if (nReg == (dataBits-1)) stateNext = stop; else nNext = nReg +1; end else sNext = sReg + 1; end stop : begin txNext = 1'b1; if (sTick) if (sReg == sbTick-1) begin stateNext = idle; end else sNext = sReg + 1; end endcase end assign tx = txReg; endmodule"
    },
    {
        "file_name": "host_interface.v",
        "verilog_design": "module host_interface_aes ( output [3:0] key_en, output [1:0] col_addr, output [1:0] chmod, output [1:0] mode, output [1:0] data_type, output col_wr_en, output col_rd_en, output [1:0] key_sel, output [3:0] iv_en, output [3:0] iv_sel, output int_ccf, output int_err, output disable_core, output reg first_block, output dma_req_wr, output dma_req_rd, output reg start_core, output [31:0] PRDATA, input [3:0] PADDR, input [12:0] PWDATA, input PWRITE, input PENABLE, input PSEL, input PCLK, input PRESETn, input [31:0] key_bus, input [31:0] col_bus, input [31:0] iv_bus, input ccf_set ); localparam AES_CR = 4'd00; localparam AES_SR = 4'd01; localparam AES_DINR = 4'd02; localparam AES_DOUTR = 4'd03; localparam AES_KEYR0 = 4'd04; localparam AES_KEYR1 = 4'd05; localparam AES_KEYR2 = 4'd06; localparam AES_KEYR3 = 4'd07; localparam AES_IVR0 = 4'd08; localparam AES_IVR1 = 4'd09; localparam AES_IVR2 = 4'd10; localparam AES_IVR3 = 4'd11; localparam ENCRYPTION = 2'b00; localparam KEY_DERIVATION = 2'b01; localparam DECRYPTION = 2'b10; localparam DECRYP_W_DERIV = 2'b11; localparam ECB = 2'b00; localparam CBC = 2'b01; localparam CTR = 2'b10; localparam AES_CR_RESET = 13'd0; localparam AES_SR_RESET = 3'd0; localparam ENABLE = 1'b1; localparam DISABLE = 1'b0; localparam IDLE = 3'd0; localparam INPUT = 3'd1; localparam START = 3'd2; localparam WAIT = 3'd3; localparam OUTPUT = 3'd4; wire [31:0] bus_out; reg [31:0] bus_out_mux; reg cnt_en; reg enable_clear; reg access_permission; reg first_block_set; reg first_block_clear; wire [1:0] mode_in; wire [1:0] chmod_in; wire write_en; wire read_en; wire dma_out_en; wire dma_in_en; wire err_ie; wire ccf_ie; wire errc; wire ccfc; wire aes_cr_wr_en; wire wr_err_en; wire rd_err_en; wire write_completed; wire read_completed; wire key_deriv; reg [10:0] aes_cr; reg wr_err; reg rd_err; reg ccf; reg [2:0] state, next_state; reg [1:0] cnt; reg dma_req; wire enable; assign write_en = PSEL & PENABLE & PWRITE; assign read_en = (PSEL & ~PWRITE)?1'b1:1'b0; assign dma_out_en = aes_cr[10]; assign dma_in_en = aes_cr[9]; assign err_ie = aes_cr[8]; assign ccf_ie = aes_cr[7]; assign errc = PWDATA[8]; assign ccfc = PWDATA[7]; assign chmod = aes_cr[6:5]; assign mode = aes_cr[4:3]; assign data_type = aes_cr[2:1]; assign enable = aes_cr[0]; assign aes_cr_wr_en = (PADDR == AES_CR) & write_en; assign mode_in = PWDATA[4:3]; assign chmod_in = PWDATA[6:5]; always @(posedge PCLK or negedge PRESETn) begin if(!PRESETn) aes_cr <= AES_CR_RESET[10:0]; else begin if(enable_clear) aes_cr[0] <= 1'b0; else if(aes_cr_wr_en) aes_cr[0] <= PWDATA[0]; if(aes_cr_wr_en && access_permission) begin aes_cr[2:1] <= PWDATA[2:1]; if(mode_in == DECRYP_W_DERIV && chmod_in == CTR) aes_cr[4:3] <= DECRYPTION; else aes_cr[4:3] <= mode_in; aes_cr[ 6:5] <= PWDATA[6:5]; aes_cr[10:7] <= PWDATA[12:9]; end end end always @(posedge PCLK or negedge PRESETn) begin if(!PRESETn) begin {wr_err, rd_err, ccf} <= AES_SR_RESET; end else begin if(wr_err_en) wr_err <= 1'b1; else if(errc && aes_cr_wr_en && access_permission) wr_err <= 1'b0; if(rd_err_en) rd_err <= 1'b1; else if(errc && aes_cr_wr_en && access_permission) rd_err <= 1'b0; if(ccf_set) ccf <= 1'b1; else if(ccfc && aes_cr_wr_en ) ccf <= 1'b0; end end assign int_ccf = ccf_ie & ccf_set; assign int_err = (wr_err_en | rd_err_en) & err_ie; assign key_en = (4'b1000 >> PADDR[1:0]) & {4{(~PADDR[3] & PADDR[2] & access_permission & write_en)}}; assign key_sel = ~PADDR[1:0] & {2{(PADDR[2] & access_permission)}}; assign iv_sel = (4'b1000 >> PADDR[1:0]) & {4{(PADDR[3] & ~PADDR[2] & access_permission)}}; assign iv_en = iv_sel & {4{write_en}}; always @(posedge PCLK or negedge PRESETn) begin if(!PRESETn) state <= IDLE; else if(!enable) state <= IDLE; else state <= next_state; end assign write_completed = (cnt == 2'b11); assign read_completed = (cnt == 2'b11); assign key_deriv = (mode == KEY_DERIVATION); always @(*) begin next_state = state; case(state) IDLE : begin if(enable) next_state = (key_deriv) ? START : INPUT; end INPUT : next_state = (write_completed && cnt_en) ? START : INPUT; START : next_state = WAIT; WAIT : begin if(ccf_set) next_state = (key_deriv) ? IDLE : OUTPUT; end OUTPUT: next_state = (read_completed && cnt_en) ? INPUT : OUTPUT; endcase end assign disable_core = ~enable; always @(*) begin access_permission = DISABLE; start_core = DISABLE; cnt_en = DISABLE; enable_clear = DISABLE; first_block_set = DISABLE; first_block_clear = DISABLE; case(state) IDLE: begin access_permission = ENABLE; first_block_set = ENABLE; if(enable && !key_deriv) cnt_en = ENABLE; end INPUT: begin if(PADDR == AES_DINR && write_en) cnt_en = ENABLE; end START: begin start_core = ENABLE; end WAIT: begin if(ccf_set) cnt_en = ENABLE; if(ccf_set && key_deriv) enable_clear = ENABLE; end OUTPUT: begin first_block_clear = ENABLE; if(PADDR == AES_DOUTR && read_en && PENABLE ) cnt_en = ENABLE; end endcase end always @(posedge PCLK or negedge PRESETn) begin if(!PRESETn) first_block <= 1'b1; else if(first_block_set) first_block <= 1'b1; else if(first_block_clear) first_block <= 1'b0; end always @(posedge PCLK or negedge PRESETn) begin if(!PRESETn) cnt <= 2'b11; else begin if(!enable || state == START) cnt <= 2'b11; else if(cnt_en) cnt <= cnt + 1'b1; end end assign col_addr = cnt; assign col_wr_en = (PADDR == AES_DINR && write_en && state == INPUT); assign col_rd_en = (PADDR == AES_DOUTR && read_en && state == OUTPUT); assign wr_err_en = (PADDR == AES_DINR && write_en && (state != INPUT && state != IDLE)); assign rd_err_en = (PADDR == AES_DOUTR && read_en && (state != OUTPUT && state != IDLE)); always @(posedge PCLK or negedge PRESETn) begin if(!PRESETn) dma_req <= 1'b0; else dma_req <= cnt[0]; end assign dma_req_wr = (dma_req ^ cnt[0]) & dma_in_en & enable & (state == INPUT || state == IDLE); assign dma_req_rd = (dma_req ^ cnt[0]) & dma_out_en & enable & (state == OUTPUT); assign PRDATA = bus_out; always @(*) begin bus_out_mux = 32'd0; case(PADDR) AES_CR: bus_out_mux = {{19{1'b0}}, aes_cr[10:7], 2'b00, aes_cr[6:0]}; AES_SR: bus_out_mux = {{29{1'b0}}, wr_err, rd_err, (ccf_set && ~PENABLE)? 1'b1:(ccfc && aes_cr_wr_en)?1'b0:ccf}; AES_DINR, AES_DOUTR: begin if(~PWRITE && PADDR == AES_DOUTR && (ccf_set || ccf )) bus_out_mux = col_bus; end AES_KEYR0, AES_KEYR1, AES_KEYR2, AES_KEYR3: if(!enable) bus_out_mux = key_bus; AES_IVR0, AES_IVR1, AES_IVR2, AES_IVR3: if(!enable) bus_out_mux = iv_bus; endcase end assign bus_out =(read_en)? bus_out_mux:32'd0; endmodule"
    },
    {
        "file_name": "key_expander.v",
        "verilog_design": "module key_expander ( output [127:0] key_out, output [ 31:0] g_in, input [ 31:0] g_out, input [127:0] key_in, input [ 3:0] round, input add_w_out, input enc_dec ); localparam integer KEY_WIDTH = 32; localparam integer KEY_NUM = 4; localparam integer WORD = 8; localparam integer ROUNDS = 10; wire [32 - 1 : 0] key [0 : 4 - 1]; wire [ 8 - 1 : 0] rot_in[0 : 4 - 1]; wire [32 - 1 : 0] g_func; reg [ 8 - 1 : 0] rc_dir, rc_inv; wire [ 8 - 1 : 0] rc; generate genvar i; for(i = 0; i < KEY_NUM; i = i + 1) begin:KG assign key[KEY_NUM - 1 - i] = key_in[KEY_WIDTH*(i + 1) - 1 : KEY_WIDTH*i]; end endgenerate generate genvar j; for(j = 0; j < KEY_NUM; j = j + 1) begin:KGO if(j == 0) assign key_out[KEY_WIDTH*(KEY_NUM - j) - 1 : KEY_WIDTH*(KEY_NUM - j - 1)] = key[j] ^ g_func; else if(j == 1) assign key_out[KEY_WIDTH*(KEY_NUM - j) - 1 : KEY_WIDTH*(KEY_NUM - j - 1)] = (add_w_out) ? key[j] ^ key[j - 1] ^ g_func : key[j] ^ key[j - 1]; else assign key_out[KEY_WIDTH*(KEY_NUM - j) - 1 : KEY_WIDTH*(KEY_NUM - j - 1)] = key[j] ^ key[j - 1]; end endgenerate generate genvar k; for(k = 0; k < KEY_NUM; k = k + 1) begin:GFIG assign rot_in[k] = (enc_dec) ? key[KEY_NUM - 1][WORD*(k + 1) - 1 : WORD*k] : key[KEY_NUM - 1][WORD*(k + 1) - 1 : WORD*k] ^ key[KEY_NUM - 2][WORD*(k + 1) - 1 : WORD*k]; end endgenerate generate genvar l; for(l = 0; l < KEY_NUM; l = l + 1) begin:GFIG1 assign g_in[WORD*(l + 1) - 1 : WORD*l] = rot_in[(KEY_NUM + l - 1)%KEY_NUM]; end endgenerate assign g_func = {g_out[KEY_WIDTH - 1 : KEY_WIDTH - WORD] ^ rc, g_out[KEY_WIDTH - WORD - 1 : 0]}; assign rc = (enc_dec) ? rc_dir : rc_inv; always @(*) begin: RC_DIR integer i; for(i = 0; i < ROUNDS; i = i + 1) if(round == 8) rc_dir = 8'h1b; else if(round == 9) rc_dir = 8'h36; else rc_dir = 8'h01 << round; end always @(*) begin: RC_INV integer i; for(i = 0; i < ROUNDS; i = i + 1) if(round == 1) rc_inv = 8'h1b; else if(round == 0) rc_inv = 8'h36; else rc_inv = 8'h80 >> (round - 2); end endmodule"
    },
    {
        "file_name": "cavlc_fsm.v",
        "verilog_design": "`include \"defines.v\" module cavlc_fsm ( clk, rst_n, ena, start, max_coeff_num, TotalCoeff, TotalCoeff_comb, TrailingOnes, TrailingOnes_comb, ZeroLeft, state, i, idle, valid ); input clk; input rst_n; input ena; input start; input [4:0] max_coeff_num; input [4:0] TotalCoeff; input [4:0] TotalCoeff_comb; input [1:0] TrailingOnes; input [1:0] TrailingOnes_comb; input [3:0] ZeroLeft; output [7:0] state; output [3:0] i; output idle; output valid; reg [7:0] state; reg [3:0] i; reg valid; always @(posedge clk or negedge rst_n) if (!rst_n) begin state <= `cavlc_idle_s; i <= 0; valid <= 0; end else if (ena) case(state) `cavlc_idle_s : begin if (start) begin state <= `cavlc_read_total_coeffs_s; valid <= 0; end else begin state <= `cavlc_idle_s; end end `cavlc_read_total_coeffs_s : begin i <= TotalCoeff_comb -1; if (TrailingOnes_comb > 0 && TotalCoeff_comb > 0) state <= `cavlc_read_t1s_flags_s; else if (TotalCoeff_comb > 0) state <= `cavlc_read_level_prefix_s; else begin state <= `cavlc_idle_s; valid <= 1; end end `cavlc_read_t1s_flags_s : begin if (TrailingOnes == TotalCoeff) state <= `cavlc_read_total_zeros_s; else begin state <= `cavlc_read_level_prefix_s; i <= i - TrailingOnes; end end `cavlc_read_level_prefix_s : begin state <= `cavlc_read_level_suffix_s; end `cavlc_read_level_suffix_s : begin state <= `cavlc_calc_level_s; end `cavlc_calc_level_s : begin if ( i == 0 && TotalCoeff < max_coeff_num) state <= `cavlc_read_total_zeros_s; else if (i == 0) begin state <= `cavlc_read_run_befores_s; i <= TotalCoeff - 1; end else begin state <= `cavlc_read_level_prefix_s; i <= i - 1; end end `cavlc_read_total_zeros_s : begin state <= `cavlc_read_run_befores_s; i <= TotalCoeff - 1; end `cavlc_read_run_befores_s : begin if (i == 0 || ZeroLeft == 0) begin state <= `cavlc_idle_s; valid <= 1; end else begin state <= `cavlc_read_run_befores_s; i <= i - 1; end end endcase assign idle = state[`cavlc_idle_bit]; endmodule"
    },
    {
        "file_name": "cavlc_len_gen.v",
        "verilog_design": "`include \"defines.v\" module cavlc_len_gen ( cavlc_state, len_read_total_coeffs_comb, len_read_levels_comb, len_read_total_zeros_comb, len_read_run_befores_comb, len_comb ); input [7:0] cavlc_state; input [4:0] len_read_total_coeffs_comb; input [4:0] len_read_levels_comb; input [3:0] len_read_total_zeros_comb; input [3:0] len_read_run_befores_comb; output [4:0] len_comb; reg [4:0] len_comb; always @ (*) case (1'b1) cavlc_state[`cavlc_read_total_coeffs_bit] : len_comb <= len_read_total_coeffs_comb; cavlc_state[`cavlc_read_t1s_flags_bit], cavlc_state[`cavlc_read_level_prefix_bit], cavlc_state[`cavlc_read_level_suffix_bit] : len_comb <= len_read_levels_comb; cavlc_state[`cavlc_read_total_zeros_bit] : len_comb <= len_read_total_zeros_comb; cavlc_state[`cavlc_read_run_befores_bit] : len_comb <= len_read_run_befores_comb; cavlc_state[`cavlc_calc_level_bit], cavlc_state[`cavlc_idle_bit] : len_comb <= 0; default : len_comb <= 'bx; endcase endmodule"
    },
    {
        "file_name": "cavlc_read_levels.v",
        "verilog_design": "`include \"defines.v\" module cavlc_read_levels ( clk, rst_n, ena, t1s_sel, prefix_sel, suffix_sel, calc_sel, TrailingOnes, TotalCoeff, rbsp, i, level_0, level_1, level_2, level_3, level_4, level_5, level_6, level_7, level_8, level_9, level_10, level_11, level_12, level_13, level_14, level_15, len_comb ); input clk; input rst_n; input ena; input t1s_sel; input prefix_sel; input suffix_sel; input calc_sel; input [1:0] TrailingOnes; input [4:0] TotalCoeff; input [0:15] rbsp; input [3:0] i; output [8:0] level_0; output [8:0] level_1; output [8:0] level_2; output [8:0] level_3; output [8:0] level_4; output [8:0] level_5; output [8:0] level_6; output [8:0] level_7; output [8:0] level_8; output [8:0] level_9; output [8:0] level_10; output [8:0] level_11; output [8:0] level_12; output [8:0] level_13; output [8:0] level_14; output [8:0] level_15; output [4:0] len_comb; reg [0:15] rbsp_internal; reg [3:0] level_prefix_comb; reg [8:0] level_suffix; reg [4:0] len_comb; reg [3:0] level_prefix; reg [2:0] suffixLength; reg [8:0] level; reg [8:0] level_abs; reg [8:0] level_code_tmp; reg [8:0] level_0, level_1, level_2, level_3, level_4, level_5, level_6, level_7; reg [8:0] level_8, level_9, level_10, level_11, level_12, level_13, level_14, level_15; always @(*) if ((t1s_sel || prefix_sel || suffix_sel)&& ena) rbsp_internal <= rbsp; else rbsp_internal <= 'hffff; always @(*) if (rbsp_internal[0]) level_prefix_comb <= 0; else if (rbsp_internal[1]) level_prefix_comb <= 1; else if (rbsp_internal[2]) level_prefix_comb <= 2; else if (rbsp_internal[3]) level_prefix_comb <= 3; else if (rbsp_internal[4]) level_prefix_comb <= 4; else if (rbsp_internal[5]) level_prefix_comb <= 5; else if (rbsp_internal[6]) level_prefix_comb <= 6; else if (rbsp_internal[7]) level_prefix_comb <= 7; else if (rbsp_internal[8]) level_prefix_comb <= 8; else if (rbsp_internal[9]) level_prefix_comb <= 9; else if (rbsp_internal[10]) level_prefix_comb <= 10; else if (rbsp_internal[11]) level_prefix_comb <= 11; else if (rbsp_internal[12]) level_prefix_comb <= 12; else if (rbsp_internal[13]) level_prefix_comb <= 13; else if (rbsp_internal[14]) level_prefix_comb <= 14; else if (rbsp_internal[15]) level_prefix_comb <= 15; else level_prefix_comb <= 'bx; always @(posedge clk or negedge rst_n) if (!rst_n) level_prefix <= 0; else if (prefix_sel && ena) level_prefix <= level_prefix_comb; wire first_level; assign first_level = (i == TotalCoeff - TrailingOnes - 1); always @(posedge clk or negedge rst_n) if (!rst_n) suffixLength <= 0; else if (prefix_sel && ena) begin if (TotalCoeff > 10 && TrailingOnes < 3 && first_level ) suffixLength <= 1; else if (first_level) suffixLength <= 0; else if (suffixLength == 0 && level_abs > 2'd3) suffixLength <= 2; else if (suffixLength == 0) suffixLength <= 1; else if ( level_abs > (2'd3 << (suffixLength - 1'b1) ) && suffixLength < 6) suffixLength <= suffixLength + 1'b1; end always @(*) if (suffixLength > 0 && level_prefix <= 14) level_suffix <= {3'b0, rbsp_internal[0:5] >> (3'd6 - suffixLength)}; else if (level_prefix == 14) level_suffix <= {3'b0, rbsp_internal[0:3] }; else if (level_prefix == 15) level_suffix <= rbsp_internal[3:11]; else level_suffix <= 0; always @(posedge clk or negedge rst_n) if (!rst_n) begin level_code_tmp <= 0; end else if (suffix_sel && ena) begin level_code_tmp <= (level_prefix << suffixLength) + level_suffix + ((suffixLength == 0 && level_prefix == 15) ? 4'd15 : 0); end wire [2:0] tmp1; assign tmp1 = (first_level && TrailingOnes < 3)? 2'd2 : 2'd0; always @(*) begin if (level_code_tmp % 2 == 0) begin level <= ( level_code_tmp + tmp1 + 2 ) >> 1; end else begin level <= (-level_code_tmp - tmp1 - 1 ) >> 1; end end wire level_abs_refresh; assign level_abs_refresh = calc_sel && ena; always @(posedge clk or negedge rst_n) if (!rst_n) begin level_abs <= 0; end else if (level_abs_refresh) begin level_abs <= level[8] ? -level : level; end always @ (posedge clk or negedge rst_n) if (!rst_n) begin level_0 <= 0; level_1 <= 0; level_2 <= 0; level_3 <= 0; level_4 <= 0; level_5 <= 0; level_6 <= 0; level_7 <= 0; level_8 <= 0; level_9 <= 0; level_10<= 0; level_11<= 0; level_12<= 0; level_13<= 0; level_14<= 0; level_15<= 0; end else if (t1s_sel && ena) case (i) 0 : level_0 <= rbsp_internal[0]? -1 : 1; 1 : begin level_1 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_0 <= rbsp_internal[1]? -1 : 1; end 2 : begin level_2 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_1 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_0 <= rbsp_internal[2]? -1 : 1; end 3 : begin level_3 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_2 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_1 <= rbsp_internal[2]? -1 : 1; end 4 : begin level_4 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_3 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_2 <= rbsp_internal[2]? -1 : 1; end 5 : begin level_5 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_4 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_3 <= rbsp_internal[2]? -1 : 1; end 6 : begin level_6 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_5 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_4 <= rbsp_internal[2]? -1 : 1; end 7 : begin level_7 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_6 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_5 <= rbsp_internal[2]? -1 : 1; end 8 : begin level_8 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_7 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_6 <= rbsp_internal[2]? -1 : 1; end 9 : begin level_9 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_8 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_7 <= rbsp_internal[2]? -1 : 1; end 10: begin level_10 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_9 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_8 <= rbsp_internal[2]? -1 : 1; end 11: begin level_11 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_10 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_9 <= rbsp_internal[2]? -1 : 1; end 12: begin level_12 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_11 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_10 <= rbsp_internal[2]? -1 : 1; end 13: begin level_13 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_12 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_11 <= rbsp_internal[2]? -1 : 1; end 14: begin level_14 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_13 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_12 <= rbsp_internal[2]? -1 : 1; end 15: begin level_15 <= rbsp_internal[0]? -1 : 1; if (TrailingOnes[1]) level_14 <= rbsp_internal[1]? -1 : 1; if (TrailingOnes == 3) level_13 <= rbsp_internal[2]? -1 : 1; end endcase else if (calc_sel && ena) case (i) 0 :level_0 <= level; 1 :level_1 <= level; 2 :level_2 <= level; 3 :level_3 <= level; 4 :level_4 <= level; 5 :level_5 <= level; 6 :level_6 <= level; 7 :level_7 <= level; 8 :level_8 <= level; 9 :level_9 <= level; 10:level_10<= level; 11:level_11<= level; 12:level_12<= level; 13:level_13<= level; 14:level_14<= level; 15:level_15<= level; endcase always @(*) if(t1s_sel) len_comb <= TrailingOnes; else if(prefix_sel) len_comb <= level_prefix_comb + 1; else if(suffix_sel && suffixLength > 0 && level_prefix <= 14) len_comb <= suffixLength; else if(suffix_sel && level_prefix == 14) len_comb <= 4; else if(suffix_sel && level_prefix == 15) len_comb <= 12; else len_comb <= 0; endmodule"
    },
    {
        "file_name": "cavlc_read_total_coeffs.v",
        "verilog_design": "`include \"defines.v\" module cavlc_read_total_coeffs ( clk, rst_n, ena, start, sel, rbsp, nC, TrailingOnes, TotalCoeff, TrailingOnes_comb, TotalCoeff_comb, len_comb ); input clk; input rst_n; input ena; input start; input sel; input [0:15] rbsp; input signed [5:0] nC; output [4:0] TotalCoeff; output [1:0] TrailingOnes; output [4:0] TotalCoeff_comb; output [1:0] TrailingOnes_comb; output [4:0] len_comb; reg [4:0] TotalCoeff_comb; reg [1:0] TrailingOnes_comb; reg [4:0] len_comb; reg [4:0] TotalCoeff_1; reg [1:0] TrailingOnes_1; reg [4:0] len_1; reg [4:0] TotalCoeff_2; reg [1:0] TrailingOnes_2; reg [4:0] len_2; reg [4:0] TotalCoeff_3; reg [1:0] TrailingOnes_3; reg [4:0] len_3; reg [4:0] TotalCoeff_4; reg [1:0] TrailingOnes_4; reg [4:0] len_4; reg [4:0] TotalCoeff_5; reg [1:0] TrailingOnes_5; reg [4:0] len_5; reg [0:15] rbsp_1; reg [0:13] rbsp_2; reg [0:9] rbsp_3; reg [0:5] rbsp_4; reg [0:7] rbsp_5; reg [4:0] TotalCoeff; reg [1:0] TrailingOnes; always @(posedge clk or negedge rst_n) if (!rst_n) begin rbsp_1 <= 0; rbsp_2 <= 0; rbsp_3 <= 0; rbsp_4 <= 0; rbsp_5 <= 0; end else if (ena && start) begin if (nC[5]) rbsp_5 <= rbsp[0:7]; else if ( nC[4] || nC[3]) rbsp_4 <= rbsp[0:5]; else if (nC[2]) rbsp_3 <= rbsp[0:9]; else if (nC[1]) rbsp_2 <= rbsp[0:13]; else rbsp_1 <= rbsp; end always @(rbsp_1) case (1'b1) rbsp_1[0] : begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 0; len_1 <= 1; end rbsp_1[1] : begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 1; len_1 <= 2; end rbsp_1[2] : begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 2; len_1 <= 3; end rbsp_1[3] : begin if (rbsp_1[4] == 'b1) begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 3; len_1 <= 5; end else if (rbsp_1[5] == 'b1) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 1; len_1 <= 6; end else begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 2; len_1 <= 6; end end rbsp_1[4] : begin if (rbsp_1[5] == 'b1) begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 4; len_1 <= 6; end else if (rbsp_1[6] == 'b1) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 3; len_1 <= 7; end else begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 5; len_1 <= 7; end end rbsp_1[5] : begin len_1 <= 8; if (rbsp_1[6:7] == 'b11) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 2; end else if (rbsp_1[6:7] == 'b10) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 3; end else if (rbsp_1[6:7] == 'b01) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 4; end else begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 6; end end rbsp_1[6] : begin len_1 <= 9; if (rbsp_1[7:8] == 2'b11) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 3; end else if (rbsp_1[7:8] == 2'b10) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 4; end else if (rbsp_1[7:8] == 2'b01) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 5; end else begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 7; end end rbsp_1[7] : begin len_1 <= 10; if (rbsp_1[8:9] == 2'b11) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 4; end else if (rbsp_1[8:9] == 2'b10) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 5; end else if (rbsp_1[8:9] == 2'b01) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 6; end else begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 8; end end rbsp_1[8] : begin len_1 <= 11; if (rbsp_1[9:10] == 2'b11) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 5; end else if (rbsp_1[9:10] == 2'b10) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 6; end else if (rbsp_1[9:10] == 2'b01) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 7; end else begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 9; end end rbsp_1[9] : begin len_1 <= 13; if (rbsp_1[10:12] == 3'b111) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 6; end else if (rbsp_1[10:12] == 3'b011) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 7; end else if (rbsp_1[10:12] == 3'b110) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 7; end else if (rbsp_1[10:12] == 3'b000) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 8; end else if (rbsp_1[10:12] == 3'b010) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 8; end else if (rbsp_1[10:12] == 3'b101) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 8; end else if (rbsp_1[10:12] == 3'b001) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 9; end else begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 10; end end rbsp_1[10] : begin len_1 <= 14; if (rbsp_1[11:13] == 3'b111) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 9; end else if (rbsp_1[11:13] == 3'b110) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 9; end else if (rbsp_1[11:13] == 3'b011) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 10; end else if (rbsp_1[11:13] == 3'b010) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 10; end else if (rbsp_1[11:13] == 3'b101) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 10; end else if (rbsp_1[11:13] == 3'b001) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 11; end else if (rbsp_1[11:13] == 3'b100) begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 11; end else begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 12; end end rbsp_1[11] : begin len_1 <= 15; if (rbsp_1[12:14] == 3'b111) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 11; end else if (rbsp_1[12:14] == 3'b110) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 11; end else if (rbsp_1[12:14] == 3'b011) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 12; end else if (rbsp_1[12:14] == 3'b010) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 12; end else if (rbsp_1[12:14] == 3'b101) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 12; end else if (rbsp_1[12:14] == 3'b001) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 13; end else if (rbsp_1[12:14] == 3'b100) begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 13; end else begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 14; end end rbsp_1[12] : begin len_1 <= 16; if (rbsp_1[13:15] == 3'b111) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 13; end else if (rbsp_1[13:15] == 3'b011) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 14; end else if (rbsp_1[13:15] == 3'b110) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 14; end else if (rbsp_1[13:15] == 3'b101) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 14; end else if (rbsp_1[13:15] == 3'b010) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 15; end else if (rbsp_1[13:15] == 3'b001) begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 15; end else if (rbsp_1[13:15] == 3'b100) begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 15; end else begin TrailingOnes_1 <= 3; TotalCoeff_1 <= 16; end end rbsp_1[13] : begin len_1 <= 16; if (rbsp_1[14:15] == 2'b11) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 15; end else if (rbsp_1[14:15] == 2'b00) begin TrailingOnes_1 <= 0; TotalCoeff_1 <= 16; end else if (rbsp_1[14:15] == 2'b10) begin TrailingOnes_1 <= 1; TotalCoeff_1 <= 16; end else begin TrailingOnes_1 <= 2; TotalCoeff_1 <= 16; end end default : begin len_1 <= 15; TrailingOnes_1 <= 1; TotalCoeff_1 <= 13; end endcase always @(rbsp_2) case (1'b1) rbsp_2[0] : begin len_2 <= 2; if (rbsp_2[1] == 'b1) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 0; end else begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 1; end end rbsp_2[1] : begin if (rbsp_2[2] == 'b1) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 2; len_2 <= 3; end else if (rbsp_2[3] == 'b1) begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 3; len_2 <= 4; end else begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 4; len_2 <= 4; end end rbsp_2[2] : begin if (rbsp_2[3:4] == 'b11) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 2; len_2 <= 5; end else if (rbsp_2[3:4] == 'b10) begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 5; len_2 <= 5; end else if (rbsp_2[4:5] == 'b11) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 1; len_2 <= 6; end else if (rbsp_2[4:5] == 'b10) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 3; len_2 <= 6; end else if (rbsp_2[4:5] == 'b01) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 3; len_2 <= 6; end else begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 6; len_2 <= 6; end end rbsp_2[3] : begin len_2 <= 6; if (rbsp_2[4:5] == 'b11) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 2; end else if (rbsp_2[4:5] == 'b10) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 4; end else if (rbsp_2[4:5] == 'b01) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 4; end else begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 7; end end rbsp_2[4] : begin len_2 <= 7; if (rbsp_2[5:6] == 'b11) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 3; end else if (rbsp_2[5:6] == 'b10) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 5; end else if (rbsp_2[5:6] == 'b01) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 5; end else begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 8; end end rbsp_2[5] : begin len_2 <= 8; if (rbsp_2[6:7] == 'b11) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 4; end else if (rbsp_2[6:7] == 'b00) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 5; end else if (rbsp_2[6:7] == 'b10) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 6; end else begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 6; end end rbsp_2[6] : begin len_2 <= 9; if (rbsp_2[7:8] == 'b11) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 6; end else if (rbsp_2[7:8] == 'b10) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 7; end else if (rbsp_2[7:8] == 'b01) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 7; end else begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 9; end end rbsp_2[7] : begin len_2 <= 11; if (rbsp_2[8:10] == 'b111) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 7; end else if (rbsp_2[8:10] == 'b011) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 8; end else if (rbsp_2[8:10] == 'b110) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 8; end else if (rbsp_2[8:10] == 'b101) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 8; end else if (rbsp_2[8:10] == 'b010) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 9; end else if (rbsp_2[8:10] == 'b001) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 9; end else if (rbsp_2[8:10] == 'b100) begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 10; end else begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 11; end end rbsp_2[8] : begin len_2 <= 12; if (rbsp_2[9:11] == 'b111) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 9; end else if (rbsp_2[9:11] == 'b011) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 10; end else if (rbsp_2[9:11] == 'b110) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 10; end else if (rbsp_2[9:11] == 'b101) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 10; end else if (rbsp_2[9:11] == 'b000) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 11; end else if (rbsp_2[9:11] == 'b010) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 11; end else if (rbsp_2[9:11] == 'b001) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 11; end else begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 12; end end rbsp_2[9] : begin len_2 <= 13; if (rbsp_2[10:12] == 'b111) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 12; end else if (rbsp_2[10:12] == 'b110) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 12; end else if (rbsp_2[10:12] == 'b101) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 12; end else if (rbsp_2[10:12] == 'b011) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 13; end else if (rbsp_2[10:12] == 'b010) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 13; end else if (rbsp_2[10:12] == 'b001) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 13; end else if (rbsp_2[10:12] == 'b100) begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 13; end else begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 14; end end rbsp_2[10] : begin if (rbsp_2[11:12] == 'b11) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 14; len_2 <= 13; end else if (rbsp_2[11:12] == 'b10) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 14; len_2 <= 13; end else if (rbsp_2[12:13] == 'b11) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 14; len_2 <= 14; end else if (rbsp_2[12:13] == 'b01) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 15; len_2 <= 14; end else if (rbsp_2[12:13] == 'b00) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 15; len_2 <= 14; end else begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 15; len_2 <= 14; end end rbsp_2[11] : begin len_2 <= 14; if (rbsp_2[12:13] == 'b11) begin TrailingOnes_2 <= 0; TotalCoeff_2 <= 16; end else if (rbsp_2[12:13] == 'b10) begin TrailingOnes_2 <= 1; TotalCoeff_2 <= 16; end else if (rbsp_2[12:13] == 'b01) begin TrailingOnes_2 <= 2; TotalCoeff_2 <= 16; end else begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 16; end end default : begin TrailingOnes_2 <= 3; TotalCoeff_2 <= 15; len_2 <= 13; end endcase always @(rbsp_3) case (1'b1) rbsp_3[0] : begin len_3 <= 4; case (rbsp_3[1:3]) 'b111 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 0; end 'b110 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 1; end 'b101 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 2; end 'b100 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 3; end 'b011 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 4; end 'b010 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 5; end 'b001 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 6; end 'b000 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 7; end endcase end rbsp_3[1] : begin len_3 <= 5; case (rbsp_3[2:4]) 'b111 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 2; end 'b100 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 3; end 'b110 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 3; end 'b010 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 4; end 'b011 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 4; end 'b000 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 5; end 'b001 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 5; end 'b101 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 8; end endcase end rbsp_3[2] : begin len_3 <= 6; case (rbsp_3[3:5]) 3'b111 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 1; end 3'b011 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 2; end 3'b000 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 3; end 3'b110 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 6; end 3'b101 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 6; end 3'b010 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 7; end 3'b001 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 7; end 3'b100 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 9; end endcase end rbsp_3[3] : begin len_3 <= 7; case (rbsp_3[4:6]) 'b111 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 4; end 'b011 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 5; end 'b001 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 6; end 'b000 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 7; end 'b110 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 8; end 'b101 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 8; end 'b010 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 9; end 'b100 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 10; end endcase end rbsp_3[4] : begin len_3 <= 8; case (rbsp_3[5:7]) 'b111 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 8; end 'b011 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 9; end 'b110 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 9; end 'b010 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 10; end 'b101 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 10; end 'b001 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 11; end 'b100 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 11; end 'b000 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 12; end endcase end rbsp_3[5] : begin len_3 <= 9; case (rbsp_3[6:8]) 'b111 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 10; end 'b011 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 11; end 'b110 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 11; end 'b000 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 12; end 'b010 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 12; end 'b101 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 12; end 'b001 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 13; end 'b100 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 13; end endcase end rbsp_3[6] : begin if (rbsp_3[7:8] == 'b11)begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 13; len_3 <= 9; end else if (rbsp_3[7:9] == 'b101)begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 13; len_3 <= 10; end else if (rbsp_3[7:9] == 'b001)begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 14; len_3 <= 10; end else if (rbsp_3[7:9] == 'b100)begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 14; len_3 <= 10; end else if (rbsp_3[7:9] == 'b011)begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 14; len_3 <= 10; end else if (rbsp_3[7:9] == 'b010)begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 14; len_3 <= 10; end else begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 15; len_3 <= 10; end end rbsp_3[7] : begin len_3 <= 10; case (rbsp_3[8:9]) 'b01 : begin TrailingOnes_3 <= 0; TotalCoeff_3 <= 15; end 'b11 : begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 15; end 'b10 : begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 15; end 'b00 : begin TrailingOnes_3 <= 1; TotalCoeff_3 <= 16; end endcase end rbsp_3[8] : begin len_3 <= 10; if (rbsp_3[9] == 'b1)begin TrailingOnes_3 <= 2; TotalCoeff_3 <= 16; end else begin TrailingOnes_3 <= 3; TotalCoeff_3 <= 16; end end default : begin len_3 <= 10; TrailingOnes_3 <= 0; TotalCoeff_3 <= 16; end endcase always @(rbsp_4) begin len_4 <= 6; if (rbsp_4[0:4] == 5'b00001) begin TrailingOnes_4 <= 0; TotalCoeff_4 <= 0; end else begin TrailingOnes_4 <= rbsp_4[4:5]; TotalCoeff_4 <= rbsp_4[0:3] + 1'b1; end end always @(rbsp_5) case (1'b1) rbsp_5[0] : begin TrailingOnes_5 <= 1; TotalCoeff_5 <= 1; len_5 <= 1; end rbsp_5[1] : begin TrailingOnes_5 <= 0; TotalCoeff_5 <= 0; len_5 <= 2; end rbsp_5[2] : begin TrailingOnes_5 <= 2; TotalCoeff_5 <= 2; len_5 <= 3; end rbsp_5[3] : begin len_5 <= 6; if (rbsp_5[4:5] == 'b11) begin TrailingOnes_5 <= 0; TotalCoeff_5 <= 1; end else if (rbsp_5[4:5] == 'b00) begin TrailingOnes_5 <= 0; TotalCoeff_5 <= 2; end else if (rbsp_5[4:5] == 'b10) begin TrailingOnes_5 <= 1; TotalCoeff_5 <= 2; end else begin TrailingOnes_5 <= 3; TotalCoeff_5 <= 3; end end rbsp_5[4] : begin len_5 <= 6; if (rbsp_5[5] == 'b1) begin TrailingOnes_5 <= 0; TotalCoeff_5 <= 3; end else begin TrailingOnes_5 <= 0; TotalCoeff_5 <= 4; end end rbsp_5[5] : begin len_5 <= 7; if (rbsp_5[6] == 'b1) begin TrailingOnes_5 <= 1; TotalCoeff_5 <= 3; end else begin TrailingOnes_5 <= 2; TotalCoeff_5 <= 3; end end rbsp_5[6] : begin len_5 <= 8; if (rbsp_5[7] == 'b1) begin TrailingOnes_5 <= 1; TotalCoeff_5 <= 4; end else begin TrailingOnes_5 <= 2; TotalCoeff_5 <= 4; end end default : begin len_5 <= 7; TrailingOnes_5 <= 3; TotalCoeff_5 <= 4; end endcase always @(*) begin if (nC == -1) begin TrailingOnes_comb <= TrailingOnes_5; TotalCoeff_comb <= TotalCoeff_5; len_comb <= len_5; end else if (nC[4] | nC[3]) begin TrailingOnes_comb <= TrailingOnes_4; TotalCoeff_comb <= TotalCoeff_4; len_comb <= len_4; end else if (nC[2]) begin TrailingOnes_comb <= TrailingOnes_3; TotalCoeff_comb <= TotalCoeff_3; len_comb <= len_3; end else if (nC[1]) begin TrailingOnes_comb <= TrailingOnes_2; TotalCoeff_comb <= TotalCoeff_2; len_comb <= len_2; end else begin TrailingOnes_comb <= TrailingOnes_1; TotalCoeff_comb <= TotalCoeff_1; len_comb <= len_1; end end always @(posedge clk or negedge rst_n) if (!rst_n) begin TrailingOnes <= 0; TotalCoeff <= 0; end else if (ena && sel) begin TrailingOnes <= TrailingOnes_comb; TotalCoeff <= TotalCoeff_comb; end endmodule"
    },
    {
        "file_name": "cavlc_read_total_zeros.v",
        "verilog_design": "`include \"defines.v\" module cavlc_read_total_zeros ( ena, sel, chroma_DC_sel, rbsp, TotalCoeff, TotalZeros_comb, len_comb ); input ena; input sel; input chroma_DC_sel; input [0:8] rbsp; input [3:0] TotalCoeff; output [3:0] TotalZeros_comb; output [3:0] len_comb; reg [3:0] TotalZeros_comb; reg [3:0] len_comb; reg [0:2] rbsp_chroma_DC; reg [1:0] TotalZeros_chroma_DC; reg [1:0] len_chroma_DC; reg [0:8] rbsp_LE3; reg [3:0] TotalZeros_LE3; reg [3:0] len_LE3; reg [0:5] rbsp_G3; reg [3:0] TotalZeros_G3; reg [2:0] len_G3; always @(*) if (ena && sel && chroma_DC_sel) begin rbsp_chroma_DC <= rbsp[0:2]; rbsp_LE3 <= 'hffff; rbsp_G3 <= 'hffff; end else if (ena && sel && TotalCoeff[3:2] == 2'b00) begin rbsp_chroma_DC <= 'hffff; rbsp_LE3 <= rbsp[0:8]; rbsp_G3 <= 'hffff; end else if (ena && sel)begin rbsp_chroma_DC <= 'hffff; rbsp_LE3 <= 'hffff; rbsp_G3 <= rbsp[0:5]; end else begin rbsp_chroma_DC <= 'hffff; rbsp_LE3 <= 'hffff; rbsp_G3 <= 'hffff; end always @(*) if ( TotalCoeff == 1 && rbsp_chroma_DC[0] ) begin TotalZeros_chroma_DC <= 0; len_chroma_DC <= 1; end else if ( TotalCoeff == 1 && rbsp_chroma_DC[1] ) begin TotalZeros_chroma_DC <= 1; len_chroma_DC <= 2; end else if ( TotalCoeff == 1 && rbsp_chroma_DC[2] ) begin TotalZeros_chroma_DC <= 2; len_chroma_DC <= 3; end else if ( TotalCoeff == 1 ) begin TotalZeros_chroma_DC <= 3; len_chroma_DC <= 3; end else if ( TotalCoeff == 2 && rbsp_chroma_DC[0] ) begin TotalZeros_chroma_DC <= 0; len_chroma_DC <= 1; end else if ( TotalCoeff == 2 && rbsp_chroma_DC[1] ) begin TotalZeros_chroma_DC <= 1; len_chroma_DC <= 2; end else if ( TotalCoeff == 2 ) begin TotalZeros_chroma_DC <= 2; len_chroma_DC <= 2; end else if ( rbsp_chroma_DC[0] ) begin TotalZeros_chroma_DC <= 0; len_chroma_DC <= 1; end else begin TotalZeros_chroma_DC <= 1; len_chroma_DC <= 1; end always @(rbsp_LE3 or TotalCoeff) case (TotalCoeff[1:0]) 1 :begin case(1'b1) rbsp_LE3[0] : begin TotalZeros_LE3 <= 0; len_LE3 <= 1; end rbsp_LE3[1] : begin len_LE3 <= 3; if (rbsp_LE3[2]) TotalZeros_LE3 <= 1; else TotalZeros_LE3 <= 2; end rbsp_LE3[2] : begin len_LE3 <= 4; if (rbsp_LE3[3]) TotalZeros_LE3 <= 3; else TotalZeros_LE3 <= 4; end rbsp_LE3[3] : begin len_LE3 <= 5; if (rbsp_LE3[4]) TotalZeros_LE3 <= 5; else TotalZeros_LE3 <= 6; end rbsp_LE3[4] : begin len_LE3 <= 6; if (rbsp_LE3[5]) TotalZeros_LE3 <= 7; else TotalZeros_LE3 <= 8; end rbsp_LE3[5] : begin len_LE3 <= 7; if (rbsp_LE3[6]) TotalZeros_LE3 <= 9; else TotalZeros_LE3 <= 10; end rbsp_LE3[6] : begin len_LE3 <= 8; if (rbsp_LE3[7]) TotalZeros_LE3 <= 11; else TotalZeros_LE3 <= 12; end rbsp_LE3[7] : begin len_LE3 <= 9; if (rbsp_LE3[8]) TotalZeros_LE3 <= 13; else TotalZeros_LE3 <= 14; end default : begin len_LE3 <= 9; TotalZeros_LE3 <= 15; end endcase end 2 : begin case(1'b1) rbsp_LE3[0] : begin len_LE3 <= 3; case(rbsp_LE3[1:2]) 'b11 : TotalZeros_LE3 <= 0; 'b10 : TotalZeros_LE3 <= 1; 'b01 : TotalZeros_LE3 <= 2; 'b00 : TotalZeros_LE3 <= 3; endcase end rbsp_LE3[1] : begin if (rbsp_LE3[2]) begin TotalZeros_LE3 <= 4; len_LE3 <= 3; end else begin len_LE3 <= 4; if (rbsp_LE3[3]) TotalZeros_LE3 <= 5; else TotalZeros_LE3 <= 6; end end rbsp_LE3[2] : begin len_LE3 <= 4; if (rbsp_LE3[3]) TotalZeros_LE3 <= 7; else TotalZeros_LE3 <= 8; end rbsp_LE3[3] : begin len_LE3 <= 5; if (rbsp_LE3[4]) TotalZeros_LE3 <= 9; else TotalZeros_LE3 <= 10; end default : begin len_LE3 <= 6; case(rbsp_LE3[4:5]) 'b11 : TotalZeros_LE3 <= 11; 'b10 : TotalZeros_LE3 <= 12; 'b01 : TotalZeros_LE3 <= 13; 'b00 : TotalZeros_LE3 <= 14; endcase end endcase end 3 : begin case(1'b1) rbsp_LE3[0] : begin len_LE3 <= 3; case(rbsp_LE3[1:2]) 'b11 : TotalZeros_LE3 <= 1; 'b10 : TotalZeros_LE3 <= 2; 'b01 : TotalZeros_LE3 <= 3; 'b00 : TotalZeros_LE3 <= 6; endcase end rbsp_LE3[1] : begin if (rbsp_LE3[2]) begin TotalZeros_LE3 <= 7; len_LE3 <= 3; end else begin len_LE3 <= 4; if (rbsp_LE3[3]) TotalZeros_LE3 <= 0; else TotalZeros_LE3 <= 4; end end rbsp_LE3[2] : begin len_LE3 <= 4; if (rbsp_LE3[3]) TotalZeros_LE3 <= 5; else TotalZeros_LE3 <= 8; end rbsp_LE3[3] : begin len_LE3 <= 5; if (rbsp_LE3[4]) TotalZeros_LE3 <= 9; else TotalZeros_LE3 <= 10; end rbsp_LE3[4] : begin len_LE3 <= 5; TotalZeros_LE3 <= 12; end default : begin len_LE3 <= 6; if(rbsp_LE3[5]) TotalZeros_LE3 <= 11; else TotalZeros_LE3 <= 13; end endcase end default : begin len_LE3 <= 'bx; TotalZeros_LE3 <= 'bx; end endcase always @(rbsp_G3 or TotalCoeff) case (TotalCoeff) 4 : begin case(1'b1) rbsp_G3[0] : begin len_G3 <= 3; case(rbsp_G3[1:2]) 'b11 : TotalZeros_G3 <= 1; 'b10 : TotalZeros_G3 <= 4; 'b01 : TotalZeros_G3 <= 5; 'b00 : TotalZeros_G3 <= 6; endcase end rbsp_G3[1] : begin if (rbsp_G3[2]) begin TotalZeros_G3 <= 8; len_G3 <= 3; end else begin len_G3 <= 4; if (rbsp_G3[3]) TotalZeros_G3 <= 2; else TotalZeros_G3 <= 3; end end rbsp_G3[2] : begin len_G3 <= 4; if (rbsp_G3[3]) TotalZeros_G3 <= 7; else TotalZeros_G3 <= 9; end default : begin len_G3 <= 5; case(rbsp_G3[3:4]) 'b11 : TotalZeros_G3 <= 0; 'b10 : TotalZeros_G3 <= 10; 'b01 : TotalZeros_G3 <= 11; 'b00 : TotalZeros_G3 <= 12; endcase end endcase end 5 :begin case(1'b1) rbsp_G3[0] : begin len_G3 <= 3; case(rbsp_G3[1:2]) 'b11 : TotalZeros_G3 <= 3; 'b10 : TotalZeros_G3 <= 4; 'b01 : TotalZeros_G3 <= 5; 'b00 : TotalZeros_G3 <= 6; endcase end rbsp_G3[1] : begin if (rbsp_G3[2]) begin TotalZeros_G3 <= 7; len_G3 <= 3; end else begin len_G3 <= 4; if (rbsp_G3[3]) TotalZeros_G3 <= 0; else TotalZeros_G3 <= 1; end end rbsp_G3[2] : begin len_G3 <= 4; if (rbsp_G3[3]) TotalZeros_G3 <= 2; else TotalZeros_G3 <= 8; end rbsp_G3[3] : begin len_G3 <= 4; TotalZeros_G3 <= 10; end default : begin len_G3 <= 5; if (rbsp_G3[4]) TotalZeros_G3 <= 9; else TotalZeros_G3 <= 11; end endcase end 6 : begin case(1'b1) rbsp_G3[0] : begin len_G3 <= 3; case(rbsp_G3[1:2]) 'b11 : TotalZeros_G3 <= 2; 'b10 : TotalZeros_G3 <= 3; 'b01 : TotalZeros_G3 <= 4; 'b00 : TotalZeros_G3 <= 5; endcase end rbsp_G3[1] : begin len_G3 <= 3; if (rbsp_G3[2]) TotalZeros_G3 <= 6; else TotalZeros_G3 <= 7; end rbsp_G3[2] : begin len_G3 <= 3; TotalZeros_G3 <= 9; end rbsp_G3[3] : begin len_G3 <= 4; TotalZeros_G3 <= 8; end rbsp_G3[4] : begin len_G3 <= 5; TotalZeros_G3 <= 1; end default : begin len_G3 <= 6; if (rbsp_G3[5]) TotalZeros_G3 <= 0; else TotalZeros_G3 <= 10; end endcase end 7 :begin case(1'b1) rbsp_G3[0] : begin if (rbsp_G3[1]) begin TotalZeros_G3 <= 5; len_G3 <= 2; end else begin len_G3 <= 3; if (rbsp_G3[2]) TotalZeros_G3 <= 2; else TotalZeros_G3 <= 3; end end rbsp_G3[1] : begin len_G3 <= 3; if (rbsp_G3[2]) TotalZeros_G3 <= 4; else TotalZeros_G3 <= 6; end rbsp_G3[2] : begin len_G3 <= 3; TotalZeros_G3 <= 8; end rbsp_G3[3] : begin len_G3 <= 4; TotalZeros_G3 <= 7; end rbsp_G3[4] : begin len_G3 <= 5; TotalZeros_G3 <= 1; end default : begin len_G3 <= 6; if (rbsp_G3[5]) TotalZeros_G3 <= 0; else TotalZeros_G3 <= 9; end endcase end 8 :begin case(1'b1) rbsp_G3[0] : begin len_G3 <= 2; if (rbsp_G3[1]) TotalZeros_G3 <= 4; else TotalZeros_G3 <= 5; end rbsp_G3[1] : begin len_G3 <= 3; if (rbsp_G3[2]) TotalZeros_G3 <= 3; else TotalZeros_G3 <= 6; end rbsp_G3[2] : begin len_G3 <= 3; TotalZeros_G3 <= 7; end rbsp_G3[3] : begin len_G3 <= 4; TotalZeros_G3 <= 1; end rbsp_G3[4] : begin len_G3 <= 5; TotalZeros_G3 <= 2; end default : begin len_G3 <= 6; if (rbsp_G3[5]) TotalZeros_G3 <= 0; else TotalZeros_G3 <= 8; end endcase end 9 : begin case(1'b1) rbsp_G3[0] : begin len_G3 <= 2; if (rbsp_G3[1]) TotalZeros_G3 <= 3; else TotalZeros_G3 <= 4; end rbsp_G3[1] : begin len_G3 <= 2; TotalZeros_G3 <= 6; end rbsp_G3[2] : begin len_G3 <= 3; TotalZeros_G3 <= 5; end rbsp_G3[3] : begin len_G3 <= 4; TotalZeros_G3 <= 2; end rbsp_G3[4] : begin len_G3 <= 5; TotalZeros_G3 <= 7; end default : begin len_G3 <= 6; if (rbsp_G3[5]) TotalZeros_G3 <= 0; else TotalZeros_G3 <= 1; end endcase end 10 : begin case(1'b1) rbsp_G3[0] : begin len_G3 <= 2; if (rbsp_G3[1]) TotalZeros_G3 <= 3; else TotalZeros_G3 <= 4; end rbsp_G3[1] : begin len_G3 <= 2; TotalZeros_G3 <= 5; end rbsp_G3[2] : begin len_G3 <= 3; TotalZeros_G3 <= 2; end rbsp_G3[3] : begin len_G3 <= 4; TotalZeros_G3 <= 6; end default : begin len_G3 <= 5; if (rbsp_G3[4]) TotalZeros_G3 <= 0; else TotalZeros_G3 <= 1; end endcase end 11 : begin case(1'b1) rbsp_G3[0] : begin len_G3 <= 1; TotalZeros_G3 <= 4; end rbsp_G3[1] : begin len_G3 <= 3; if (rbsp_G3[2]) TotalZeros_G3 <= 5; else TotalZeros_G3 <= 3; end rbsp_G3[2] : begin len_G3 <= 3; TotalZeros_G3 <= 2; end default : begin len_G3 <= 4; if (rbsp_G3[3]) TotalZeros_G3 <= 1; else TotalZeros_G3 <= 0; end endcase end 12 : begin case(1'b1) rbsp_G3[0] : begin len_G3 <= 1; TotalZeros_G3 <= 3; end rbsp_G3[1] : begin len_G3 <= 2; TotalZeros_G3 <= 2; end rbsp_G3[2] : begin len_G3 <= 3; TotalZeros_G3 <= 4; end default : begin len_G3 <= 4; if (rbsp_G3[3]) TotalZeros_G3 <= 1; else TotalZeros_G3 <= 0; end endcase end 13 :begin if (rbsp_G3[0]) begin TotalZeros_G3 <= 2; len_G3 <= 1; end else if (rbsp_G3[1]) begin TotalZeros_G3 <= 3; len_G3 <= 2; end else if (rbsp_G3[2]) begin TotalZeros_G3 <= 1; len_G3 <= 3; end else begin TotalZeros_G3 <= 0; len_G3 <= 3; end end 14 : begin if (rbsp_G3[0]) begin TotalZeros_G3 <= 2; len_G3 <= 1; end else if (rbsp_G3[1]) begin TotalZeros_G3 <= 1; len_G3 <= 2; end else begin TotalZeros_G3 <= 0; len_G3 <= 2; end end 15 : begin len_G3 <= 1; if (rbsp_G3[0]) TotalZeros_G3 <= 1; else TotalZeros_G3 <= 0; end default : begin len_G3 <= 'bx; TotalZeros_G3 <= 'bx; end endcase always @(*) if (ena && sel && chroma_DC_sel) begin TotalZeros_comb <= TotalZeros_chroma_DC; len_comb <= len_chroma_DC; end else if (ena && sel && TotalCoeff[3:2] == 2'b00) begin TotalZeros_comb <= TotalZeros_LE3; len_comb <= len_LE3; end else if (ena && sel)begin TotalZeros_comb <= TotalZeros_G3; len_comb <= len_G3; end else begin TotalZeros_comb <= 0; len_comb <= 0; end endmodule"
    },
    {
        "file_name": "ca_prng.v",
        "verilog_design": "module ca_prng( input wire clk, input wire reset_n, input wire [31 : 0] init_pattern_data, input wire load_init_pattern, input wire next_pattern, input wire [7 : 0] update_rule, input wire load_update_rule, output wire [31 : 0] prng_data ); parameter [7 : 0] DEFAULT_RULE = 8'b00011110; reg [31 : 0] ca_state_reg; reg [31 : 0] ca_state_new; reg ca_state_we; reg [7 : 0] update_rule_reg; reg [31 : 0] tmp_ca_state_new; assign prng_data = ca_state_reg; always @ (posedge clk) begin : reg_update if (!reset_n) begin update_rule_reg <= DEFAULT_RULE; ca_state_reg <= 32'b00000000000000000000000000000000; end else begin if (load_update_rule) begin update_rule_reg <= update_rule; end if (ca_state_we) begin ca_state_reg <= ca_state_new; end end end always @* begin : ca_state_update case({ca_state_reg[31], ca_state_reg[0], ca_state_reg[1]}) 0: begin tmp_ca_state_new[0] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[0] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[0] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[0] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[0] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[0] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[0] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[0] = update_rule_reg[7]; end endcase case({ca_state_reg[0], ca_state_reg[1], ca_state_reg[2]}) 0: begin tmp_ca_state_new[1] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[1] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[1] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[1] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[1] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[1] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[1] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[1] = update_rule_reg[7]; end endcase case({ca_state_reg[1], ca_state_reg[2], ca_state_reg[3]}) 0: begin tmp_ca_state_new[2] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[2] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[2] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[2] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[2] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[2] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[2] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[2] = update_rule_reg[7]; end endcase case({ca_state_reg[2], ca_state_reg[3], ca_state_reg[4]}) 0: begin tmp_ca_state_new[3] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[3] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[3] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[3] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[3] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[3] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[3] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[3] = update_rule_reg[7]; end endcase case({ca_state_reg[3], ca_state_reg[4], ca_state_reg[5]}) 0: begin tmp_ca_state_new[4] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[4] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[4] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[4] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[4] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[4] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[4] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[4] = update_rule_reg[7]; end endcase case({ca_state_reg[4], ca_state_reg[5], ca_state_reg[6]}) 0: begin tmp_ca_state_new[5] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[5] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[5] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[5] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[5] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[5] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[5] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[5] = update_rule_reg[7]; end endcase case({ca_state_reg[5], ca_state_reg[6], ca_state_reg[7]}) 0: begin tmp_ca_state_new[6] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[6] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[6] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[6] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[6] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[6] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[6] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[6] = update_rule_reg[7]; end endcase case({ca_state_reg[6], ca_state_reg[7], ca_state_reg[8]}) 0: begin tmp_ca_state_new[7] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[7] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[7] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[7] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[7] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[7] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[7] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[7] = update_rule_reg[7]; end endcase case({ca_state_reg[7], ca_state_reg[8], ca_state_reg[9]}) 0: begin tmp_ca_state_new[8] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[8] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[8] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[8] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[8] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[8] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[8] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[8] = update_rule_reg[7]; end endcase case({ca_state_reg[8], ca_state_reg[9], ca_state_reg[10]}) 0: begin tmp_ca_state_new[9] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[9] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[9] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[9] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[9] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[9] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[9] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[9] = update_rule_reg[7]; end endcase case({ca_state_reg[9], ca_state_reg[10], ca_state_reg[11]}) 0: begin tmp_ca_state_new[10] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[10] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[10] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[10] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[10] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[10] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[10] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[10] = update_rule_reg[7]; end endcase case({ca_state_reg[10], ca_state_reg[11], ca_state_reg[12]}) 0: begin tmp_ca_state_new[11] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[11] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[11] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[11] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[11] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[11] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[11] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[11] = update_rule_reg[7]; end endcase case({ca_state_reg[11], ca_state_reg[12], ca_state_reg[13]}) 0: begin tmp_ca_state_new[12] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[12] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[12] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[12] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[12] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[12] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[12] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[12] = update_rule_reg[7]; end endcase case({ca_state_reg[12], ca_state_reg[13], ca_state_reg[14]}) 0: begin tmp_ca_state_new[13] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[13] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[13] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[13] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[13] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[13] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[13] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[13] = update_rule_reg[7]; end endcase case({ca_state_reg[13], ca_state_reg[14], ca_state_reg[15]}) 0: begin tmp_ca_state_new[14] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[14] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[14] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[14] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[14] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[14] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[14] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[14] = update_rule_reg[7]; end endcase case({ca_state_reg[14], ca_state_reg[15], ca_state_reg[16]}) 0: begin tmp_ca_state_new[15] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[15] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[15] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[15] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[15] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[15] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[15] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[15] = update_rule_reg[7]; end endcase case({ca_state_reg[15], ca_state_reg[16], ca_state_reg[17]}) 0: begin tmp_ca_state_new[16] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[16] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[16] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[16] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[16] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[16] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[16] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[16] = update_rule_reg[7]; end endcase case({ca_state_reg[16], ca_state_reg[17], ca_state_reg[18]}) 0: begin tmp_ca_state_new[17] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[17] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[17] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[17] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[17] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[17] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[17] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[17] = update_rule_reg[7]; end endcase case({ca_state_reg[17], ca_state_reg[18], ca_state_reg[19]}) 0: begin tmp_ca_state_new[18] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[18] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[18] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[18] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[18] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[18] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[18] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[18] = update_rule_reg[7]; end endcase case({ca_state_reg[18], ca_state_reg[19], ca_state_reg[20]}) 0: begin tmp_ca_state_new[19] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[19] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[19] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[19] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[19] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[19] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[19] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[19] = update_rule_reg[7]; end endcase case({ca_state_reg[19], ca_state_reg[20], ca_state_reg[21]}) 0: begin tmp_ca_state_new[20] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[20] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[20] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[20] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[20] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[20] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[20] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[20] = update_rule_reg[7]; end endcase case({ca_state_reg[20], ca_state_reg[21], ca_state_reg[22]}) 0: begin tmp_ca_state_new[21] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[21] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[21] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[21] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[21] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[21] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[21] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[21] = update_rule_reg[7]; end endcase case({ca_state_reg[21], ca_state_reg[22], ca_state_reg[23]}) 0: begin tmp_ca_state_new[22] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[22] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[22] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[22] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[22] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[22] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[22] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[22] = update_rule_reg[7]; end endcase case({ca_state_reg[22], ca_state_reg[23], ca_state_reg[24]}) 0: begin tmp_ca_state_new[23] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[23] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[23] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[23] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[23] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[23] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[23] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[23] = update_rule_reg[7]; end endcase case({ca_state_reg[23], ca_state_reg[24], ca_state_reg[25]}) 0: begin tmp_ca_state_new[24] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[24] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[24] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[24] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[24] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[24] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[24] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[24] = update_rule_reg[7]; end endcase case({ca_state_reg[24], ca_state_reg[25], ca_state_reg[26]}) 0: begin tmp_ca_state_new[25] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[25] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[25] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[25] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[25] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[25] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[25] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[25] = update_rule_reg[7]; end endcase case({ca_state_reg[25], ca_state_reg[26], ca_state_reg[27]}) 0: begin tmp_ca_state_new[26] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[26] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[26] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[26] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[26] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[26] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[26] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[26] = update_rule_reg[7]; end endcase case({ca_state_reg[26], ca_state_reg[27], ca_state_reg[28]}) 0: begin tmp_ca_state_new[27] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[27] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[27] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[27] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[27] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[27] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[27] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[27] = update_rule_reg[7]; end endcase case({ca_state_reg[27], ca_state_reg[28], ca_state_reg[29]}) 0: begin tmp_ca_state_new[28] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[28] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[28] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[28] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[28] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[28] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[28] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[28] = update_rule_reg[7]; end endcase case({ca_state_reg[28], ca_state_reg[29], ca_state_reg[30]}) 0: begin tmp_ca_state_new[29] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[29] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[29] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[29] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[29] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[29] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[29] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[29] = update_rule_reg[7]; end endcase case({ca_state_reg[29], ca_state_reg[30], ca_state_reg[31]}) 0: begin tmp_ca_state_new[30] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[30] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[30] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[30] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[30] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[30] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[30] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[30] = update_rule_reg[7]; end endcase case({ca_state_reg[30], ca_state_reg[31], ca_state_reg[0]}) 0: begin tmp_ca_state_new[31] = update_rule_reg[0]; end 1: begin tmp_ca_state_new[31] = update_rule_reg[1]; end 2: begin tmp_ca_state_new[31] = update_rule_reg[2]; end 3: begin tmp_ca_state_new[31] = update_rule_reg[3]; end 4: begin tmp_ca_state_new[31] = update_rule_reg[4]; end 5: begin tmp_ca_state_new[31] = update_rule_reg[5]; end 6: begin tmp_ca_state_new[31] = update_rule_reg[6]; end 7: begin tmp_ca_state_new[31] = update_rule_reg[7]; end endcase if (load_init_pattern) begin ca_state_new = init_pattern_data; end else begin ca_state_new = tmp_ca_state_new; end if (load_init_pattern || next_pattern) begin ca_state_we = 1; end else begin ca_state_we = 0; end end endmodule"
    },
    {
        "file_name": "mux4to1.v",
        "verilog_design": "module mux4to1(e, s, i0, i1, i2, i3, z); parameter WID=4; input e; input [1:0] s; input [WID:1] i0; input [WID:1] i1; input [WID:1] i2; input [WID:1] i3; output [WID:1] z; reg [WID:1] z; always @(e or s or i0 or i1 or i2 or i3) if (!e) z <= {WID{1'b0}}; else begin case(s) 2'b00: z <= i0; 2'b01: z <= i1; 2'b10: z <= i2; 2'b11: z <= i3; endcase end endmodule"
    },
    {
        "file_name": "PSGBusArb.v",
        "verilog_design": "`timescale 1ns / 1ps module PSGBusArb(rst, clk, ce, ack, req0, req1, req2, req3, req4, req5, req6, req7, sel0, sel1, sel2, sel3, sel4, sel5, sel6, sel7, seln); input rst; input clk; input ce; input ack; input req0; input req1; input req2; input req3; input req4; input req5; input req6; input req7; output sel0; reg sel0; output sel1; reg sel1; output sel2; reg sel2; output sel3; reg sel3; output sel4; reg sel4; output sel5; reg sel5; output sel6; reg sel6; output sel7; reg sel7; output [2:0] seln; reg [2:0] seln; always @(posedge clk) begin if (rst) begin sel0 <= 1'b0; sel1 <= 1'b0; sel2 <= 1'b0; sel3 <= 1'b0; sel4 <= 1'b0; sel5 <= 1'b0; sel6 <= 1'b0; sel7 <= 1'b0; seln <= 3'd0; end else begin if (ce&ack) begin if (req0) begin sel0 <= 1'b1; sel1 <= 1'b0; sel2 <= 1'b0; sel3 <= 1'b0; sel4 <= 1'b0; sel5 <= 1'b0; sel6 <= 1'b0; sel7 <= 1'b0; seln <= 3'd0; end else if (req1) begin sel1 <= 1'b1; sel0 <= 1'b0; sel2 <= 1'b0; sel3 <= 1'b0; sel4 <= 1'b0; sel5 <= 1'b0; sel6 <= 1'b0; sel7 <= 1'b0; seln <= 3'd1; end else if (req2) begin sel2 <= 1'b1; sel0 <= 1'b0; sel1 <= 1'b0; sel3 <= 1'b0; sel4 <= 1'b0; sel5 <= 1'b0; sel6 <= 1'b0; sel7 <= 1'b0; seln <= 3'd2; end else if (req3) begin sel3 <= 1'b1; sel0 <= 1'b0; sel1 <= 1'b0; sel2 <= 1'b0; sel4 <= 1'b0; sel5 <= 1'b0; sel6 <= 1'b0; sel7 <= 1'b0; seln <= 3'd3; end else if (req4) begin sel4 <= 1'b1; sel0 <= 1'b0; sel1 <= 1'b0; sel2 <= 1'b0; sel3 <= 1'b0; sel5 <= 1'b0; sel6 <= 1'b0; sel7 <= 1'b0; seln <= 3'd4; end else if (req5) begin sel5 <= 1'b1; sel0 <= 1'b0; sel1 <= 1'b0; sel2 <= 1'b0; sel3 <= 1'b0; sel4 <= 1'b0; sel6 <= 1'b0; sel7 <= 1'b0; seln <= 3'd5; end else if (req6) begin sel6 <= 1'b1; sel0 <= 1'b0; sel1 <= 1'b0; sel2 <= 1'b0; sel3 <= 1'b0; sel4 <= 1'b0; sel5 <= 1'b0; sel7 <= 1'b0; seln <= 3'd6; end else if (req7) begin sel7 <= 1'b1; sel0 <= 1'b0; sel1 <= 1'b0; sel2 <= 1'b0; sel3 <= 1'b0; sel4 <= 1'b0; sel5 <= 1'b0; sel6 <= 1'b0; seln <= 3'd7; end else begin sel0 <= sel0; sel1 <= sel1; sel2 <= sel2; sel3 <= sel3; sel4 <= sel4; sel5 <= sel5; sel6 <= sel6; sel7 <= sel7; seln <= seln; end end end end endmodule"
    },
    {
        "file_name": "PSGChannelSummer.v",
        "verilog_design": "`timescale 1ns / 1ps module PSGChannelSummer(clk_i, cnt, outctrl, tmc_i, o); input clk_i; input [7:0] cnt; input [3:0] outctrl; input [19:0] tmc_i; output [21:0] o; reg [21:0] o; wire [1:0] sel = cnt[1:0]; always @(posedge clk_i) if (cnt==8'd0) o <= 22'd0 + (tmc_i & {20{outctrl[sel]}}); else if (cnt < 8'd4) o <= o + (tmc_i & {20{outctrl[sel]}}); endmodule"
    },
    {
        "file_name": "PSGFilter.v",
        "verilog_design": "`timescale 1ns / 1ps module PSGFilter(rst, clk, cnt, wr, adr, din, i, o); parameter pTaps = 16; input rst; input clk; input [7:0] cnt; input wr; input [3:0] adr; input [12:0] din; input [14:0] i; output [14:0] o; reg [14:0] o; reg [30:0] acc; reg [14:0] tap [0:pTaps-1]; integer n; reg [11:0] coeff [0:pTaps-1]; reg [pTaps-1:0] sgn; initial begin for (n = 0; n < pTaps; n = n + 1) begin coeff[n] <= 0; sgn[n] <= 0; end end always @(posedge clk) if (wr) begin coeff[adr] <= din[11:0]; sgn[adr] <= din[12]; end always @(posedge clk) if (cnt==8'd0) begin tap[0] <= i; for (n = 1; n < pTaps; n = n + 1) tap[n] <= tap[n-1]; end wire [26:0] mult = coeff[cnt[3:0]] * tap[cnt[3:0]]; always @(posedge clk) if (rst) acc <= 0; else if (cnt==8'd0) acc <= sgn[cnt[3:0]] ? 0 - mult : 0 + mult; else if (cnt < pTaps) acc <= sgn[cnt[3:0]] ? acc - mult : acc + mult; always @(posedge clk) if (rst) o <= 0; else if (cnt==8'd0) o <= acc[30:16]; endmodule"
    },
    {
        "file_name": "PSGMasterVolumeControl.v",
        "verilog_design": "`timescale 1ns / 1ps module PSGMasterVolumeControl(rst_i, clk_i, i, volume, o); input rst_i; input clk_i; input [15:0] i; input [3:0] volume; output [19:0] o; reg [19:0] o; wire [19:0] v1 = volume[0] ? i : 20'd0; wire [19:0] v2 = volume[1] ? {i,1'b0} + v1: v1; wire [19:0] v3 = volume[2] ? {i,2'b0} + v2: v2; wire [19:0] vo = volume[3] ? {i,3'b0} + v3: v3; always @(posedge clk_i) if (rst_i) o <= 20'b0; else o <= vo; endmodule"
    },
    {
        "file_name": "PSGOutputSummer.v",
        "verilog_design": "`timescale 1ns / 1ps module PSGOutputSummer(clk_i, cnt, ufi, fi, o); input clk_i; input [7:0] cnt; input [21:0] ufi; input [21:0] fi; output [21:0] o; reg [21:0] o; always @(posedge clk_i) if (cnt==8'd0) o <= ufi + fi; endmodule"
    },
    {
        "file_name": "PSGShaper.v",
        "verilog_design": "`timescale 1ns / 1ps module PSGShaper(clk_i, ce, tgi, env, o); input clk_i; input ce; input [11:0] tgi; input [7:0] env; output [19:0] o; reg [19:0] o; always @(posedge clk_i) if (ce) o <= tgi * env; endmodule"
    },
    {
        "file_name": "bit_reversal.v",
        "verilog_design": "`define size ((DATA_SIZE/4) * (2 ** (type - 1))) module bit_reversal #( parameter DATA_SIZE = 32 ) ( output [DATA_SIZE - 1 : 0] data_out, input [DATA_SIZE - 1 : 0] data_in, input [1 : 0] rev_type ); localparam NO_REVERSE = 2'b00; localparam BYTE = 2'b01; localparam HALF_WORD = 2'b10; localparam WORD = 2'b11; localparam TYPES = 4; wire [DATA_SIZE - 1 : 0] data_reversed[0 : 3]; assign data_reversed[NO_REVERSE] = data_in; generate genvar i, type; for(type = 1 ; type < TYPES; type = type + 1) for(i = 0; i < DATA_SIZE; i = i + 1) begin if(i < `size) assign data_reversed[type][i] = data_in[`size*((i/`size) + 1) - 1 - i]; else assign data_reversed[type][i] = data_in[`size*((i/`size) + 1) - 1 - (i%(`size*(i/`size)))]; end endgenerate assign data_out = data_reversed[rev_type]; endmodule"
    },
    {
        "file_name": "crc_comb.v",
        "verilog_design": "module crc_comb #( parameter CRC_SIZE = 8, parameter MASK = 8'hff )( output [CRC_SIZE - 1 : 0] crc_out, input data_in, input [CRC_SIZE - 1 : 0] crc_in, input [CRC_SIZE - 1 : 0] crc_poly, input [CRC_SIZE - 2 : 0] crc_poly_size ); wire [CRC_SIZE - 2 : 0] MASK_REVERSED; wire [CRC_SIZE - 1 : 0] feedback; wire [CRC_SIZE - 2 : 0] crc_in_masked; wire [CRC_SIZE - 2 : 0] crc_poly_size_reversed; assign crc_poly_size_reversed[0] = crc_poly_size[CRC_SIZE - 2 - 0]; assign MASK_REVERSED[0] = MASK[CRC_SIZE - 2 - 0]; assign crc_poly_size_reversed[1] = crc_poly_size[CRC_SIZE - 2 - 1]; assign MASK_REVERSED[1] = MASK[CRC_SIZE - 2 - 1]; assign crc_poly_size_reversed[2] = crc_poly_size[CRC_SIZE - 2 - 2]; assign MASK_REVERSED[2] = MASK[CRC_SIZE - 2 - 2]; assign crc_poly_size_reversed[3] = crc_poly_size[CRC_SIZE - 2 - 3]; assign MASK_REVERSED[3] = MASK[CRC_SIZE - 2 - 3]; assign crc_poly_size_reversed[4] = crc_poly_size[CRC_SIZE - 2 - 4]; assign MASK_REVERSED[4] = MASK[CRC_SIZE - 2 - 4]; assign crc_poly_size_reversed[5] = crc_poly_size[CRC_SIZE - 2 - 5]; assign MASK_REVERSED[5] = MASK[CRC_SIZE - 2 - 5]; assign crc_poly_size_reversed[6] = crc_poly_size[CRC_SIZE - 2 - 6]; assign MASK_REVERSED[6] = MASK[CRC_SIZE - 2 - 6]; assign feedback = crc_poly & {CRC_SIZE{crc_in[CRC_SIZE - 1] ^ data_in}}; assign crc_in_masked = crc_in[CRC_SIZE - 2 : 0] & (~(crc_poly_size_reversed[CRC_SIZE - 2 : 0] & MASK_REVERSED)); assign crc_out = {crc_in_masked ^ feedback[CRC_SIZE - 1 : 1], feedback[0]}; endmodule"
    },
    {
        "file_name": "crc_control_unit.v",
        "verilog_design": "module crc_control_unit ( output reg [1:0] byte_sel, output bypass_byte0, output buffer_full, output read_wait, output bypass_size, output set_crc_init_sel, output clear_crc_init_sel, output crc_out_en, output byte_en, output reset_pending, input [1:0] size_in, input write, input reset_chain, input clk, input rst_n ); localparam EMPTY = 2'b00; localparam WRITE_1 = 2'b01; localparam WRITE_2 = 2'b10; localparam BYPASS = 2'b11; localparam IDLE = 3'b100; localparam BYTE_0 = 3'b000; localparam BYTE_1 = 3'b001; localparam BYTE_2 = 3'b010; localparam BYTE_3 = 3'b011; localparam NO_RESET = 3'b000; localparam RESET = 3'b001; localparam WAIT = 3'b010; localparam WRITE = 3'b011; localparam RESET_2 = 3'b100; localparam BYTE = 2'b00; localparam HALF_WORD = 2'b01; localparam WORD = 2'b10; reg [1:0] state_full; reg [2:0] state_byte; reg [2:0] state_reset; reg [1:0] next_state_full; reg [2:0] next_state_byte; reg [2:0] next_state_reset; wire last_byte; wire has_data; always @(posedge clk) begin if(!rst_n) state_full <= EMPTY; else state_full <= next_state_full; end assign last_byte = (size_in == BYTE && state_byte == BYTE_0) || (size_in == HALF_WORD && state_byte == BYTE_1) || (size_in == WORD && state_byte == BYTE_3) ; always @(*) begin next_state_full = state_full; case(state_full) EMPTY : next_state_full = (write) ? WRITE_1 : EMPTY; WRITE_1: begin if(last_byte) begin if(!write) next_state_full = EMPTY; end else begin if(write) next_state_full = WRITE_2; end end WRITE_2: begin if(last_byte) next_state_full = (write) ? BYPASS : WRITE_1; end BYPASS : begin if(last_byte && !write) next_state_full = WRITE_1; end endcase end assign buffer_full = (state_full == WRITE_2 && !last_byte) || (state_full == BYPASS && !last_byte); assign read_wait = (state_byte != IDLE); assign bypass_byte0 = (state_full != BYPASS); assign has_data = (state_full == WRITE_2) || (state_full == BYPASS ) ; always @(posedge clk) begin if(!rst_n) state_byte <= IDLE; else state_byte <= next_state_byte; end always @(*) begin next_state_byte = state_byte; case(state_byte) IDLE: next_state_byte = (write) ? BYTE_0 : IDLE; BYTE_0: begin if(size_in == BYTE) begin if(!write && !has_data) next_state_byte = IDLE; end else begin next_state_byte = BYTE_1; end end BYTE_1: begin if(size_in == HALF_WORD) begin if(has_data || (write && !buffer_full)) next_state_byte = BYTE_0; else next_state_byte = IDLE; end else begin next_state_byte = BYTE_2; end end BYTE_2: begin next_state_byte = BYTE_3; end BYTE_3: begin if(has_data || (write && !buffer_full)) next_state_byte = BYTE_0; else next_state_byte = IDLE; end endcase end always @(*) begin byte_sel = 2'b00; case(state_byte) BYTE_0: byte_sel = BYTE_0; BYTE_1: byte_sel = BYTE_1; BYTE_2: byte_sel = BYTE_2; BYTE_3: byte_sel = BYTE_3; endcase end assign bypass_size = !( (state_full != BYPASS && state_byte != BYTE_0) || (state_full == BYPASS) ); assign crc_out_en = (state_byte != IDLE); assign byte_en = (state_byte == BYTE_0 && (size_in == HALF_WORD || size_in == WORD) && state_full != BYPASS) || (last_byte && has_data); always @(posedge clk) begin if(!rst_n) state_reset <= NO_RESET; else state_reset <= next_state_reset; end always @(*) begin next_state_reset = state_reset; case(state_reset) NO_RESET: begin if((reset_chain && !has_data && state_byte != IDLE && !last_byte) || (reset_chain && has_data && last_byte)) next_state_reset = RESET; if(reset_chain && has_data && !last_byte) next_state_reset = WAIT; end RESET: begin if(last_byte) next_state_reset = NO_RESET; else next_state_reset = (write) ? WRITE : RESET; end WAIT: begin if(last_byte) next_state_reset = (write) ? WRITE : RESET; else next_state_reset = WAIT; end WRITE: begin if(reset_chain) next_state_reset = (last_byte) ? RESET : RESET_2; else next_state_reset = (last_byte) ? NO_RESET : WRITE; end RESET_2: begin if(last_byte) next_state_reset = (write) ? WRITE : RESET; else next_state_reset = RESET_2; end endcase end assign set_crc_init_sel = (state_byte == BYTE_0); assign clear_crc_init_sel = (state_reset == NO_RESET && last_byte && reset_chain) || (state_byte == IDLE && reset_chain ) || (state_reset == RESET && last_byte ) || (state_reset == WRITE && last_byte ) || (state_reset == RESET_2 && last_byte ) ; assign reset_pending = (state_reset != NO_RESET); endmodule"
    },
    {
        "file_name": "host_interface.v",
        "verilog_design": "module host_interface ( output [31:0] HRDATA, output HREADYOUT, output HRESP, output [31:0] bus_wr, output [ 1:0] crc_poly_size, output [ 1:0] bus_size, output [ 1:0] rev_in_type, output rev_out_type, output crc_init_en, output crc_idr_en, output crc_poly_en, output buffer_write_en, output reset_chain, input [31:0] HWDATA, input [31:0] HADDR, input [ 2:0] HSIZE, input [ 1:0] HTRANS, input HWRITE, input HSElx, input HREADY, input HRESETn, input HCLK, input [31:0] crc_poly_out, input [31:0] crc_out, input [31:0] crc_init_out, input [ 7:0] crc_idr_out, input buffer_full, input reset_pending, input read_wait ); localparam RESET_CRC_CR = 6'h00; localparam CRC_DR = 3'h0; localparam CRC_IDR = 3'h1; localparam CRC_CR = 3'h2; localparam CRC_INIT = 3'h4; localparam CRC_POL = 3'h5; localparam IDLE = 2'b00; localparam BUSY = 2'b01; localparam NON_SEQ = 2'b10; localparam SEQ = 2'b11; localparam OK = 1'b0; localparam ERROR = 1'b1; reg [2:0] haddr_pp; reg [2:0] hsize_pp; reg [1:0] htrans_pp; reg hwrite_pp; reg hselx_pp; reg [4:0] crc_cr_ff; wire [31:0] crc_cr_rd; wire crc_dr_sel; wire crc_init_sel; wire crc_idr_sel; wire crc_poly_sel; wire crc_cr_sel; wire ahb_enable; wire write_en; wire read_en; wire crc_cr_en; wire sample_bus; wire buffer_read_en; always @(posedge HCLK) begin if(!HRESETn) begin hselx_pp <= 1'b0; end else if(sample_bus) begin haddr_pp <= HADDR[4:2]; hsize_pp <= HSIZE; htrans_pp <= HTRANS; hwrite_pp <= HWRITE; hselx_pp <= HSElx; end end assign ahb_enable = (htrans_pp == NON_SEQ); assign write_en = hselx_pp && hwrite_pp && ahb_enable; assign read_en = hselx_pp && !hwrite_pp && ahb_enable; assign crc_dr_sel = (haddr_pp == CRC_DR ); assign crc_init_sel = (haddr_pp == CRC_INIT); assign crc_idr_sel = (haddr_pp == CRC_IDR ); assign crc_poly_sel = (haddr_pp == CRC_POL ); assign crc_cr_sel = (haddr_pp == CRC_CR ); assign buffer_write_en = crc_dr_sel && write_en; assign crc_init_en = crc_init_sel && write_en; assign crc_idr_en = crc_idr_sel && write_en; assign crc_poly_en = crc_poly_sel && write_en; assign crc_cr_en = crc_cr_sel && write_en; assign buffer_read_en = crc_dr_sel && read_en; assign bus_size = hsize_pp; assign bus_wr = HWDATA; assign HREADYOUT = !((buffer_write_en && buffer_full ) || (buffer_read_en && read_wait ) || (crc_init_en && reset_pending ) ); assign sample_bus = HREADYOUT && HREADY; assign HRESP = OK; assign crc_cr_rd = {24'h0, crc_cr_ff[4:0], 3'h0}; assign HRDATA = ({32{crc_dr_sel }} & crc_out ) | ({32{crc_init_sel}} & crc_init_out ) | ({32{crc_idr_sel }} & {24'h0, crc_idr_out}) | ({32{crc_poly_sel}} & crc_poly_out ) | ({32{crc_cr_sel }} & crc_cr_rd ) ; always @(posedge HCLK) begin if(!HRESETn) crc_cr_ff <= RESET_CRC_CR; else if(crc_cr_en) crc_cr_ff <= {HWDATA[7], HWDATA[6:5], HWDATA[4:3]}; end assign reset_chain = (crc_cr_en && HWDATA[0]); assign crc_poly_size = crc_cr_ff[1:0]; assign rev_in_type = crc_cr_ff[3:2]; assign rev_out_type = crc_cr_ff[4]; endmodule"
    },
    {
        "file_name": "fpu_exceptions.v",
        "verilog_design": "`timescale 1ns / 100ps module fpu_exceptions( clk, rst, enable, rmode, opa, opb, in_except, exponent_in, mantissa_in, fpu_op, out, ex_enable, underflow, overflow, inexact, exception, invalid); input clk; input rst; input enable; input [1:0] rmode; input [63:0] opa; input [63:0] opb; input [63:0] in_except; input [11:0] exponent_in; input [1:0] mantissa_in; input [2:0] fpu_op; output [63:0] out; output ex_enable; output underflow; output overflow; output inexact; output exception; output invalid; reg [63:0] out; reg ex_enable; reg underflow; reg overflow; reg inexact; reg exception; reg invalid; reg in_et_zero; reg opa_et_zero; reg opb_et_zero; reg input_et_zero; reg add; reg subtract; reg multiply; reg divide; reg opa_QNaN; reg opb_QNaN; reg opa_SNaN; reg opb_SNaN; reg opa_pos_inf; reg opb_pos_inf; reg opa_neg_inf; reg opb_neg_inf; reg opa_inf; reg opb_inf; reg NaN_input; reg SNaN_input; reg a_NaN; reg div_by_0; reg div_0_by_0; reg div_inf_by_inf; reg div_by_inf; reg mul_0_by_inf; reg mul_inf; reg div_inf; reg add_inf; reg sub_inf; reg addsub_inf_invalid; reg addsub_inf; reg out_inf_trigger; reg out_pos_inf; reg out_neg_inf; reg round_nearest; reg round_to_zero; reg round_to_pos_inf; reg round_to_neg_inf; reg inf_round_down_trigger; reg mul_uf; reg div_uf; reg underflow_trigger; reg invalid_trigger; reg overflow_trigger; reg inexact_trigger; reg except_trigger; reg enable_trigger; reg NaN_out_trigger; reg SNaN_trigger; wire [10:0] exp_2047 = 11'b11111111111; wire [10:0] exp_2046 = 11'b11111111110; reg [62:0] NaN_output_0; reg [62:0] NaN_output; wire [51:0] mantissa_max = 52'b1111111111111111111111111111111111111111111111111111; reg [62:0] inf_round_down; reg [62:0] out_inf; reg [63:0] out_0; reg [63:0] out_1; reg [63:0] out_2; always @(posedge clk) begin if (rst) begin in_et_zero <= 0; opa_et_zero <= 0; opb_et_zero <= 0; input_et_zero <= 0; add <= 0; subtract <= 0; multiply <= 0; divide <= 0; opa_QNaN <= 0; opb_QNaN <= 0; opa_SNaN <= 0; opb_SNaN <= 0; opa_pos_inf <= 0; opb_pos_inf <= 0; opa_neg_inf <= 0; opb_neg_inf <= 0; opa_inf <= 0; opb_inf <= 0; NaN_input <= 0; SNaN_input <= 0; a_NaN <= 0; div_by_0 <= 0; div_0_by_0 <= 0; div_inf_by_inf <= 0; div_by_inf <= 0; mul_0_by_inf <= 0; mul_inf <= 0; div_inf <= 0; add_inf <= 0; sub_inf <= 0; addsub_inf_invalid <= 0; addsub_inf <= 0; out_inf_trigger <= 0; out_pos_inf <= 0; out_neg_inf <= 0; round_nearest <= 0; round_to_zero <= 0; round_to_pos_inf <= 0; round_to_neg_inf <= 0; inf_round_down_trigger <= 0; mul_uf <= 0; div_uf <= 0; underflow_trigger <= 0; invalid_trigger <= 0; overflow_trigger <= 0; inexact_trigger <= 0; except_trigger <= 0; enable_trigger <= 0; NaN_out_trigger <= 0; SNaN_trigger <= 0; NaN_output_0 <= 0; NaN_output <= 0; inf_round_down <= 0; out_inf <= 0; out_0 <= 0; out_1 <= 0; out_2 <= 0; end else if (enable) begin in_et_zero <= !(|in_except[62:0]); opa_et_zero <= !(|opa[62:0]); opb_et_zero <= !(|opb[62:0]); input_et_zero <= !(|in_except[62:0]); add <= fpu_op == 3'b000; subtract <= fpu_op == 3'b001; multiply <= fpu_op == 3'b010; divide <= fpu_op == 3'b011; opa_QNaN <= (opa[62:52] == 2047) & |opa[51:0] & opa[51]; opb_QNaN <= (opb[62:52] == 2047) & |opb[51:0] & opb[51]; opa_SNaN <= (opa[62:52] == 2047) & |opa[51:0] & !opa[51]; opb_SNaN <= (opb[62:52] == 2047) & |opb[51:0] & !opb[51]; opa_pos_inf <= !opa[63] & (opa[62:52] == 2047) & !(|opa[51:0]); opb_pos_inf <= !opb[63] & (opb[62:52] == 2047) & !(|opb[51:0]); opa_neg_inf <= opa[63] & (opa[62:52] == 2047) & !(|opa[51:0]); opb_neg_inf <= opb[63] & (opb[62:52] == 2047) & !(|opb[51:0]); opa_inf <= (opa[62:52] == 2047) & !(|opa[51:0]); opb_inf <= (opb[62:52] == 2047) & !(|opb[51:0]); NaN_input <= opa_QNaN | opb_QNaN | opa_SNaN | opb_SNaN; SNaN_input <= opa_SNaN | opb_SNaN; a_NaN <= opa_QNaN | opa_SNaN; div_by_0 <= divide & opb_et_zero & !opa_et_zero; div_0_by_0 <= divide & opb_et_zero & opa_et_zero; div_inf_by_inf <= divide & opa_inf & opb_inf; div_by_inf <= divide & !opa_inf & opb_inf; mul_0_by_inf <= multiply & ((opa_inf & opb_et_zero) | (opa_et_zero & opb_inf)); mul_inf <= multiply & (opa_inf | opb_inf) & !mul_0_by_inf; div_inf <= divide & opa_inf & !opb_inf; add_inf <= (add & (opa_inf | opb_inf)); sub_inf <= (subtract & (opa_inf | opb_inf)); addsub_inf_invalid <= (add & opa_pos_inf & opb_neg_inf) | (add & opa_neg_inf & opb_pos_inf) | (subtract & opa_pos_inf & opb_pos_inf) | (subtract & opa_neg_inf & opb_neg_inf); addsub_inf <= (add_inf | sub_inf) & !addsub_inf_invalid; out_inf_trigger <= addsub_inf | mul_inf | div_inf | div_by_0 | (exponent_in > 2046); out_pos_inf <= out_inf_trigger & !in_except[63]; out_neg_inf <= out_inf_trigger & in_except[63]; round_nearest <= (rmode == 2'b00); round_to_zero <= (rmode == 2'b01); round_to_pos_inf <= (rmode == 2'b10); round_to_neg_inf <= (rmode == 2'b11); inf_round_down_trigger <= (out_pos_inf & round_to_neg_inf) | (out_neg_inf & round_to_pos_inf) | (out_inf_trigger & round_to_zero); mul_uf <= multiply & !opa_et_zero & !opb_et_zero & in_et_zero; div_uf <= divide & !opa_et_zero & in_et_zero; underflow_trigger <= div_by_inf | mul_uf | div_uf; invalid_trigger <= SNaN_input | addsub_inf_invalid | mul_0_by_inf | div_0_by_0 | div_inf_by_inf; overflow_trigger <= out_inf_trigger & !NaN_input; inexact_trigger <= (|mantissa_in[1:0] | out_inf_trigger | underflow_trigger) & !NaN_input; except_trigger <= invalid_trigger | overflow_trigger | underflow_trigger | inexact_trigger; enable_trigger <= except_trigger | out_inf_trigger | NaN_input; NaN_out_trigger <= NaN_input | invalid_trigger; SNaN_trigger <= invalid_trigger & !SNaN_input; NaN_output_0 <= a_NaN ? { exp_2047, 1'b1, opa[50:0]} : { exp_2047, 1'b1, opb[50:0]}; NaN_output <= SNaN_trigger ? { exp_2047, 2'b01, opa[49:0]} : NaN_output_0; inf_round_down <= { exp_2046, mantissa_max }; out_inf <= inf_round_down_trigger ? inf_round_down : { exp_2047, 52'b0 }; out_0 <= underflow_trigger ? { in_except[63], 63'b0 } : in_except; out_1 <= out_inf_trigger ? { in_except[63], out_inf } : out_0; out_2 <= NaN_out_trigger ? { in_except[63], NaN_output} : out_1; end end always @(posedge clk) begin if (rst) begin ex_enable <= 0; underflow <= 0; overflow <= 0; inexact <= 0; exception <= 0; invalid <= 0; out <= 0; end else if (enable) begin ex_enable <= enable_trigger; underflow <= underflow_trigger; overflow <= overflow_trigger; inexact <= inexact_trigger; exception <= except_trigger; invalid <= invalid_trigger; out <= out_2; end end endmodule"
    },
    {
        "file_name": "fpu_sub.v",
        "verilog_design": "`timescale 1ns / 100ps module fpu_sub( clk, rst, enable, opa, opb, fpu_op, sign, diff_2, exponent_2); input clk; input rst; input enable; input [63:0] opa, opb; input [2:0] fpu_op; output sign; output [55:0] diff_2; output [10:0] exponent_2; reg [6:0] diff_shift; reg [6:0] diff_shift_2; reg [10:0] exponent_a; reg [10:0] exponent_b; reg [51:0] mantissa_a; reg [51:0] mantissa_b; reg expa_gt_expb; reg expa_et_expb; reg mana_gtet_manb; reg a_gtet_b; reg sign; reg [10:0] exponent_small; reg [10:0] exponent_large; reg [51:0] mantissa_small; reg [51:0] mantissa_large; reg small_is_denorm; reg large_is_denorm; reg large_norm_small_denorm; reg small_is_nonzero; reg [10:0] exponent_diff; reg [54:0] minuend; reg [54:0] subtrahend; reg [54:0] subtra_shift; wire subtra_shift_nonzero = |subtra_shift[54:0]; wire subtra_fraction_enable = small_is_nonzero & !subtra_shift_nonzero; wire [54:0] subtra_shift_2 = { 54'b0, 1'b1 }; reg [54:0] subtra_shift_3; reg [54:0] diff; reg diffshift_gt_exponent; reg diffshift_et_55; reg [54:0] diff_1; reg [10:0] exponent; reg [10:0] exponent_2; wire in_norm_out_denorm = (exponent_large > 0) & (exponent== 0); reg [55:0] diff_2; always @(posedge clk) begin if (rst) begin exponent_a <= 0; exponent_b <= 0; mantissa_a <= 0; mantissa_b <= 0; expa_gt_expb <= 0; expa_et_expb <= 0; mana_gtet_manb <= 0; a_gtet_b <= 0; sign <= 0; exponent_small <= 0; exponent_large <= 0; mantissa_small <= 0; mantissa_large <= 0; small_is_denorm <= 0; large_is_denorm <= 0; large_norm_small_denorm <= 0; small_is_nonzero <= 0; exponent_diff <= 0; minuend <= 0; subtrahend <= 0; subtra_shift <= 0; subtra_shift_3 <= 0; diff_shift_2 <= 0; diff <= 0; diffshift_gt_exponent <= 0; diffshift_et_55 <= 0; diff_1 <= 0; exponent <= 0; exponent_2 <= 0; diff_2 <= 0; end else if (enable) begin exponent_a <= opa[62:52]; exponent_b <= opb[62:52]; mantissa_a <= opa[51:0]; mantissa_b <= opb[51:0]; expa_gt_expb <= exponent_a > exponent_b; expa_et_expb <= exponent_a == exponent_b; mana_gtet_manb <= mantissa_a >= mantissa_b; a_gtet_b <= expa_gt_expb | (expa_et_expb & mana_gtet_manb); sign <= a_gtet_b ? opa[63] :!opb[63] ^ (fpu_op == 3'b000); exponent_small <= a_gtet_b ? exponent_b : exponent_a; exponent_large <= a_gtet_b ? exponent_a : exponent_b; mantissa_small <= a_gtet_b ? mantissa_b : mantissa_a; mantissa_large <= a_gtet_b ? mantissa_a : mantissa_b; small_is_denorm <= !(exponent_small > 0); large_is_denorm <= !(exponent_large > 0); large_norm_small_denorm <= (small_is_denorm == 1 && large_is_denorm == 0); small_is_nonzero <= (exponent_small > 0) | |mantissa_small[51:0]; exponent_diff <= exponent_large - exponent_small - large_norm_small_denorm; minuend <= { !large_is_denorm, mantissa_large, 2'b00 }; subtrahend <= { !small_is_denorm, mantissa_small, 2'b00 }; subtra_shift <= subtrahend >> exponent_diff; subtra_shift_3 <= subtra_fraction_enable ? subtra_shift_2 : subtra_shift; diff_shift_2 <= diff_shift; diff <= minuend - subtra_shift_3; diffshift_gt_exponent <= diff_shift_2 > exponent_large; diffshift_et_55 <= diff_shift_2 == 55; diff_1 <= diffshift_gt_exponent ? diff << exponent_large : diff << diff_shift_2; exponent <= diffshift_gt_exponent ? 0 : (exponent_large - diff_shift_2); exponent_2 <= diffshift_et_55 ? 0 : exponent; diff_2 <= in_norm_out_denorm ? { 1'b0, diff_1 >> 1} : {1'b0, diff_1}; end end always @(diff) casex(diff) 55'b1??????????????????????????????????????????????????????: diff_shift <= 0; 55'b01?????????????????????????????????????????????????????: diff_shift <= 1; 55'b001????????????????????????????????????????????????????: diff_shift <= 2; 55'b0001???????????????????????????????????????????????????: diff_shift <= 3; 55'b00001??????????????????????????????????????????????????: diff_shift <= 4; 55'b000001?????????????????????????????????????????????????: diff_shift <= 5; 55'b0000001????????????????????????????????????????????????: diff_shift <= 6; 55'b00000001???????????????????????????????????????????????: diff_shift <= 7; 55'b000000001??????????????????????????????????????????????: diff_shift <= 8; 55'b0000000001?????????????????????????????????????????????: diff_shift <= 9; 55'b00000000001????????????????????????????????????????????: diff_shift <= 10; 55'b000000000001???????????????????????????????????????????: diff_shift <= 11; 55'b0000000000001??????????????????????????????????????????: diff_shift <= 12; 55'b00000000000001?????????????????????????????????????????: diff_shift <= 13; 55'b000000000000001????????????????????????????????????????: diff_shift <= 14; 55'b0000000000000001???????????????????????????????????????: diff_shift <= 15; 55'b00000000000000001??????????????????????????????????????: diff_shift <= 16; 55'b000000000000000001?????????????????????????????????????: diff_shift <= 17; 55'b0000000000000000001????????????????????????????????????: diff_shift <= 18; 55'b00000000000000000001???????????????????????????????????: diff_shift <= 19; 55'b000000000000000000001??????????????????????????????????: diff_shift <= 20; 55'b0000000000000000000001?????????????????????????????????: diff_shift <= 21; 55'b00000000000000000000001????????????????????????????????: diff_shift <= 22; 55'b000000000000000000000001???????????????????????????????: diff_shift <= 23; 55'b0000000000000000000000001??????????????????????????????: diff_shift <= 24; 55'b00000000000000000000000001?????????????????????????????: diff_shift <= 25; 55'b000000000000000000000000001????????????????????????????: diff_shift <= 26; 55'b0000000000000000000000000001???????????????????????????: diff_shift <= 27; 55'b00000000000000000000000000001??????????????????????????: diff_shift <= 28; 55'b000000000000000000000000000001?????????????????????????: diff_shift <= 29; 55'b0000000000000000000000000000001????????????????????????: diff_shift <= 30; 55'b00000000000000000000000000000001???????????????????????: diff_shift <= 31; 55'b000000000000000000000000000000001??????????????????????: diff_shift <= 32; 55'b0000000000000000000000000000000001?????????????????????: diff_shift <= 33; 55'b00000000000000000000000000000000001????????????????????: diff_shift <= 34; 55'b000000000000000000000000000000000001???????????????????: diff_shift <= 35; 55'b0000000000000000000000000000000000001??????????????????: diff_shift <= 36; 55'b00000000000000000000000000000000000001?????????????????: diff_shift <= 37; 55'b000000000000000000000000000000000000001????????????????: diff_shift <= 38; 55'b0000000000000000000000000000000000000001???????????????: diff_shift <= 39; 55'b00000000000000000000000000000000000000001??????????????: diff_shift <= 40; 55'b000000000000000000000000000000000000000001?????????????: diff_shift <= 41; 55'b0000000000000000000000000000000000000000001????????????: diff_shift <= 42; 55'b00000000000000000000000000000000000000000001???????????: diff_shift <= 43; 55'b000000000000000000000000000000000000000000001??????????: diff_shift <= 44; 55'b0000000000000000000000000000000000000000000001?????????: diff_shift <= 45; 55'b00000000000000000000000000000000000000000000001????????: diff_shift <= 46; 55'b000000000000000000000000000000000000000000000001???????: diff_shift <= 47; 55'b0000000000000000000000000000000000000000000000001??????: diff_shift <= 48; 55'b00000000000000000000000000000000000000000000000001?????: diff_shift <= 49; 55'b000000000000000000000000000000000000000000000000001????: diff_shift <= 50; 55'b0000000000000000000000000000000000000000000000000001???: diff_shift <= 51; 55'b00000000000000000000000000000000000000000000000000001??: diff_shift <= 52; 55'b000000000000000000000000000000000000000000000000000001?: diff_shift <= 53; 55'b0000000000000000000000000000000000000000000000000000001: diff_shift <= 54; 55'b0000000000000000000000000000000000000000000000000000000: diff_shift <= 55; endcase endmodule"
    },
    {
        "file_name": "qadd.v",
        "verilog_design": "`timescale 1ns / 1ps module qadd( input [N-1:0] a, input [N-1:0] b, output [N-1:0] c ); parameter Q = 15; parameter N = 32; reg [N-1:0] res; assign c = res; always @(a,b) begin if(a[N-1] == 1 && b[N-1] == 1) begin res[N-1] = 1; res[N-2:0] = a[N-2:0] + b[N-2:0]; end else if(a[N-1] == 0 && b[N-1] == 0) begin res[N-1] = 0; res[N-2:0] = a[N-2:0] + b[N-2:0]; end else if(a[N-1] == 0 && b[N-1] == 1) begin if(a[N-2:0] > b[N-2:0]) res[N-1] = 1; else res[N-1] = 0; res[N-2:0] = a[N-2:0] - b[N-2:0]; end else begin if(a[N-2:0] < b[N-2:0]) res[N-1] = 1; else res[N-1] = 0; res[N-2:0] = b[N-2:0] - a[N-2:0]; end end endmodule"
    },
    {
        "file_name": "qmult.v",
        "verilog_design": "`timescale 1ns / 1ps `include \"qtwosComp.v\" module qmult( input [31:0] a, input [31:0] b, output [31:0] c ); wire [63:0] a_ext; wire [63:0] b_ext; wire [63:0] r_ext; reg [63:0] a_mult; reg [63:0] b_mult; reg [63:0] result; reg [31:0] retVal; parameter Q = 15; parameter N = 32; qtwosComp #(Q,N) comp_a (.a(a[30:0]), .b(a_ext)); qtwosComp #(Q,N) comp_b (.a(b[30:0]), .b(b_ext)); qtwosComp #(Q,N) comp_r (.a(result[32-2+15:15]), .b(r_ext)); assign c = retVal; always @(a_ext,b_ext) begin if(a[32-1] == 1) a_mult <= a_ext; else a_mult <= a; if(b[32-1] == 1) b_mult <= b_ext; else b_mult <= b; end always @(a_mult,b_mult) begin result <= a_mult * b_mult; end always @(result,r_ext) begin if((a[32-1] == 1 && b[32-1] == 0) || (a[32-1] == 0 && b[32-1] == 1)) begin retVal[32-1] <= 1; retVal[32-2:0] <= r_ext[32-2:0]; end else begin retVal[32-1] <= 0; retVal[32-2:0] <= result[32-2+15:15]; end end endmodule"
    },
    {
        "file_name": "qtwosComp.v",
        "verilog_design": "`timescale 1ns / 1ps module qtwosComp( input [30:0] a, output [63:0] b ); reg [63:0] data; reg [63:0] flip; reg [63:0] out; parameter Q = 15; parameter N = 32; assign b = out; always @(a) begin data <= a; end always @(data) begin flip <= ~a; end always @(flip) begin out <= flip + 1; end endmodule"
    },
    {
        "file_name": "dff_3_pipe.v",
        "verilog_design": "module dff_3_pipe #( parameter DATA_WIDTH = 8 )( input clk, input rst_n, input [DATA_WIDTH-1:0] d0, input [DATA_WIDTH-1:0] d1, input [DATA_WIDTH-1:0] d2, output reg [DATA_WIDTH-1:0] q0, output reg [DATA_WIDTH-1:0] q1, output reg [DATA_WIDTH-1:0] q2 ); always @(posedge clk or negedge rst_n) begin : register_bank_3u if(~rst_n) begin q0 <= {DATA_WIDTH{1'b0}}; q1 <= {DATA_WIDTH{1'b0}}; q2 <= {DATA_WIDTH{1'b0}}; end else begin q0 <= d0; q1 <= d1; q2 <= d2; end end endmodule"
    },
    {
        "file_name": "dual_port_ram.v",
        "verilog_design": "`timescale 1ns/10ps module dual_port_ram #( parameter DATA_WIDTH = 32, parameter ADDR_WIDTH = 14 ) ( input clk, input r_ena, input w_ena, input [DATA_WIDTH-1:0] w_data, input [ADDR_WIDTH-1:0] w_addr, input [ADDR_WIDTH-1:0] r_addr, output reg [DATA_WIDTH-1:0] r_data ); reg [DATA_WIDTH-1:0] mem[0:2**ADDR_WIDTH-1]; always @ (posedge clk) begin if (w_ena) mem[w_addr] <= w_data; if (r_ena) r_data <= mem[r_addr]; end endmodule"
    },
    {
        "file_name": "node.v",
        "verilog_design": "module node #( parameter DATA_WIDTH = 8, parameter LOW_MUX = 1, parameter HI_MUX = 1 )( input [DATA_WIDTH-1:0] data_a, input [DATA_WIDTH-1:0] data_b, output reg [DATA_WIDTH-1:0] data_hi, output reg [DATA_WIDTH-1:0] data_lo ); reg sel0; always @(*) begin : comparator if(data_a < data_b) begin sel0 = 1'b0; end else begin sel0 = 1'b1; end end always @(*) begin : mux_lo_hi case (sel0) 1'b0 : begin if(LOW_MUX == 1) data_lo = data_a; if(HI_MUX == 1) data_hi = data_b; end 1'b1 : begin if(LOW_MUX == 1) data_lo = data_b; if(HI_MUX == 1) data_hi = data_a; end default : begin data_lo = {DATA_WIDTH{1'b0}}; data_hi = {DATA_WIDTH{1'b0}}; end endcase end endmodule"
    },
    {
        "file_name": "dpll.v",
        "verilog_design": "module dpll(SignalIn, SignalOut, MainClock, Positive, Negative, Lead, Lag ); input SignalIn; input MainClock; output SignalOut; output Positive, Negative; output Lead, Lag; phasecomparator inst_ph_cmp(.MainClock(MainClock), .InputSignal(SignalIn), .OutputSignal(SignalOut), .Lead(Lead), .Lag(Lag) ); variableresetrandomwalkfilter inst_zrwf(.MainClock(MainClock), .Lead(Lead), .Lag(Lag), .Positive(Positive), .Negative(Negative) ); freqdivider inst_freqdiv(.MainClock(MainClock), .FrequencyOut(SignalOut), .Positive(Positive), .Negative(Negative) ); endmodule"
    },
    {
        "file_name": "freqdivider.v",
        "verilog_design": "module freqdivider(MainClock, Positive, Negative, FrequencyOut); input MainClock; input Positive, Negative; output FrequencyOut; parameter DividerLength = 7; parameter DividerMaxValue = 48; reg [DividerLength-1 : 0] DividerCounter; reg FrequencyOut; always @(posedge MainClock) begin if(DividerCounter >= (DividerMaxValue - 1)) DividerCounter <= 0; else if(Negative) DividerCounter <= DividerCounter + 2; else if(Positive) DividerCounter <= DividerCounter; else DividerCounter <= DividerCounter + 1; if(DividerCounter == 0) FrequencyOut <= ~FrequencyOut; end endmodule"
    },
    {
        "file_name": "variableresetrandomwalkfilter.v",
        "verilog_design": "`include \"randomwalkfilter.v\" module variableresetrandomwalkfilter(MainClock, Lead, Lag, Positive, Negative); input MainClock, Lead, Lag; output Positive, Negative; parameter N_FilterLength = 8; parameter N_FilterResetValue = 8; parameter N_FilterMaxValue = N_FilterResetValue; parameter N_FilterMinValue = 256 - N_FilterResetValue; parameter ResetterCounterLength = 4; parameter ResetterCounterMaxValue = 3; parameter ResetterCounterMinValue = 16 - 3; reg [N_FilterLength-1 : 0] N_FilterCounter; wire Up, Down; randomwalkfilter inst_M_Filter(.MainClock(MainClock), .Lead(Lead), .Lag(Lag), .Positive(Up), .Negative(Down)); reg [ResetterCounterLength-1 : 0] ResetterCounter; always @(posedge MainClock) begin if(Up) begin if((ResetterCounter < ResetterCounterMaxValue) || (ResetterCounter >= ResetterCounterMinValue)) ResetterCounter <= ResetterCounter + 1; end else if(Down) begin if((ResetterCounter <= ResetterCounterMaxValue) || (ResetterCounter > ResetterCounterMinValue)) ResetterCounter <= ResetterCounter - 1; end if((ResetterCounter > ResetterCounterMaxValue) && (ResetterCounter < ResetterCounterMinValue)) ResetterCounter <= 0; end reg [N_FilterLength-1 : 0] ResetterValue; always @(*) begin case(ResetterCounter) 16 - 3: ResetterValue = 256 - 7; 16 - 2: ResetterValue = 256 - 6; 16 - 1: ResetterValue = 256 - 4; 0: ResetterValue = 0; 1: ResetterValue = 4; 2: ResetterValue = 6; 3: ResetterValue = 7; default: ResetterValue = 0; endcase end always @(posedge MainClock) begin if((N_FilterCounter == N_FilterMaxValue) || (N_FilterCounter == N_FilterMinValue)) N_FilterCounter <= ResetterValue; else begin if(Lead) N_FilterCounter <= N_FilterCounter + 1; if(Lag) N_FilterCounter <= N_FilterCounter - 1; end end reg Positive, Negative; always @(posedge MainClock) begin Positive <= (N_FilterCounter == N_FilterMaxValue); Negative <= (N_FilterCounter == N_FilterMinValue); end endmodule"
    },
    {
        "file_name": "clean_rst.v",
        "verilog_design": "`include \"timescale.v\" module clean_rst( input clk, input rsti, output reg rsto ); reg rstt; always @(posedge clk or posedge rsti) begin rstt <= (rsti) ? 1 : 0; rsto <= (rsti) ? 1 : rstt; end endmodule"
    },
    {
        "file_name": "decoder_8b10b.v",
        "verilog_design": "`include \"timescale.v\" module decoder_8b10b ( input reset, input RBYTECLK, input [9:0] tbi, output reg K_out, output reg [7:0] ebi, output reg coding_err, output reg disparity, output disparity_err ); `ifdef MODEL_TECH wire [4:0] decoder_8b_X; wire [2:0] decoder_8b_Y; assign decoder_8b_X = ebi[4:0]; assign decoder_8b_Y = ebi[7:5]; `endif wire a,b,c,d,e,i,f,g,h,j; assign {a,b,c,d,e,i,f,g,h,j} = tbi[9:0]; wire AEQB, CEQD, P22, P13, P31; wire eeqi, c_d_e_i, cn_dn_en_in; wire P22_a_c_eeqi, P22_an_cn_eeqi; wire P22_b_c_eeqi, P22_bn_cn_eeqi, an_bn_en_in; wire a_b_e_i, P13_d_e_i, P13_in, P13_en, P31_i; wire OR12_1, OR12_2, OR12_3, OR12_4, OR12_5, OR12_6, OR12_7; wire A, B, C, D, E; wire K, F, G, H, K28p, KA, KB, KC; assign AEQB = (a & b) | (!a & !b) ; assign CEQD = (c & d) | (!c & !d) ; assign P22 = (a & b & !c & !d) | (c & d & !a & !b) | ( !AEQB & !CEQD) ; assign P13 = ( !AEQB & !c & !d) | ( !CEQD & !a & !b) ; assign P31 = ( !AEQB & c & d) | ( !CEQD & a & b) ; assign eeqi = (e == i); assign P22_a_c_eeqi = P22 & a & c & eeqi; assign P22_an_cn_eeqi = P22 & !a & !c & eeqi; assign cn_dn_en_in = (!c & !d & !e & !i); assign c_d_e_i = (c & d & e & i); assign KA = c_d_e_i | cn_dn_en_in; assign KB = P13 & (!e & i & g & h & j); assign KC = P31 & (e & !i & !g & !h & !j); assign K = KA | KB | KC; assign P22_b_c_eeqi = P22 & b & c & eeqi; assign P22_bn_cn_eeqi = P22 & !b & !c & eeqi; assign an_bn_en_in = !a & !b & !e & !i; assign a_b_e_i = a & b & e & i; assign P13_d_e_i = P13 & d & e & i; assign P13_in = P13 & !i; assign P13_en = P13 & !e; assign P31_i = P31 & i; assign OR12_1 = P22_an_cn_eeqi | P13_en; assign OR12_2 = a_b_e_i | cn_dn_en_in | P31_i; assign OR12_3 = P31_i | P22_b_c_eeqi | P13_d_e_i; assign OR12_4 = P22_a_c_eeqi | P13_en; assign OR12_5 = P13_en | cn_dn_en_in | an_bn_en_in; assign OR12_6 = P22_an_cn_eeqi | P13_in; assign OR12_7 = P13_d_e_i | P22_bn_cn_eeqi; assign A = a ^ (OR12_7 | OR12_1 | OR12_2); assign B = b ^ (OR12_2 | OR12_3 | OR12_4); assign C = c ^ (OR12_1 | OR12_3 | OR12_5); assign D = d ^ (OR12_2 | OR12_4 | OR12_7); assign E = e ^ (OR12_5 | OR12_6 | OR12_7); assign K28p = ! (c | d | e | i) ; assign F = (j & !f & (h | !g | K28p)) | (f & !j & (!h | g | !K28p)) | (K28p & g & h) | (!K28p & !g & !h) ; assign G = (j & !f & (h | !g | !K28p)) | (f & !j & (!h | g |K28p)) | (!K28p & g & h) | (K28p & !g & !h) ; assign H = ((j ^ h) & ! ((!f & g & !h & j & !K28p) | (!f & g & h & !j & K28p) | (f & !g & !h & j & !K28p) | (f & !g & h & !j & K28p))) | (!f & g & h & j) | (f & !g & !h & !j) ; always @(posedge RBYTECLK or posedge reset) if (reset) begin K_out <= 0; ebi[7:0] <= 8'b0; end else begin K_out <= K; ebi[7:0] <= { H, G, F, E, D, C, B, A } ; end wire heqj, fghjP13, fghjP31, fghj22; wire DISPARITY6p, DISPARITY6n, DISPARITY4p, DISPARITY4n; wire DISPARITY6b, DISPARITY6a2, DISPARITY6a0; assign feqg = (f & g) | (!f & !g); assign heqj = (h & j) | (!h & !j); assign fghjP13 = ( !feqg & !h & !j) | ( !heqj & !f & !g) ; assign fghjP31 = ( (!feqg) & h & j) | ( !heqj & f & g) ; assign fghj22 = (f & g & !h & !j) | (!f & !g & h & j) | ( !feqg & !heqj) ; assign DISPARITY6p = (P31 & (e | i)) | (P22 & e & i) ; assign DISPARITY6n = (P13 & ! (e & i)) | (P22 & !e & !i); assign DISPARITY4p = fghjP31 ; assign DISPARITY4n = fghjP13 ; assign DISPARITY6a = P31 | (P22 & disparity); assign DISPARITY6a2 = P31 & disparity; assign DISPARITY6a0 = P13 & ! disparity; assign DISPARITY6b = (e & i & ! DISPARITY6a0) | (DISPARITY6a & (e | i)) | DISPARITY6a2; wire derr1,derr2,derr3,derr4,derr5,derr6,derr7,derr8; assign derr1 = (disparity & DISPARITY6p) | (DISPARITY6n & !disparity); assign derr2 = (disparity & !DISPARITY6n & f & g); assign derr3 = (disparity & a & b & c); assign derr4 = (disparity & !DISPARITY6n & DISPARITY4p); assign derr5 = (!disparity & !DISPARITY6p & !f & !g); assign derr6 = (!disparity & !a & !b & !c); assign derr7 = (!disparity & !DISPARITY6p & DISPARITY4n); assign derr8 = (DISPARITY6p & DISPARITY4p) | (DISPARITY6n & DISPARITY4n); reg derr12, derr34, derr56, derr78; always @(posedge RBYTECLK or posedge reset) if (reset) begin disparity <= 1'b0; derr12 <= 1; derr34 <= 1; derr56 <= 1; derr78 <= 1; end else begin disparity <= fghjP31 | (DISPARITY6b & fghj22) ; derr12 <= derr1 | derr2; derr34 <= derr3 | derr4; derr56 <= derr5 | derr6; derr78 <= derr7 | derr8; end assign disparity_err = derr12|derr34|derr56|derr78; wire cerr1, cerr2, cerr3, cerr4, cerr5, cerr6, cerr7, cerr8, cerr9; assign cerr1 = (a & b & c & d) | (!a & !b & !c & !d); assign cerr2 = (P13 & !e & !i); assign cerr3 = (P31 & e & i); assign cerr4 = (f & g & h & j) | (!f & !g & !h & !j); assign cerr5 = (e & i & f & g & h) | (!e & !i & !f & !g & !h); assign cerr6 = (e & !i & g & h & j) | (!e & i & !g & !h & !j); assign cerr7 = (((e & i & !g & !h & !j) | (!e & !i & g & h & j)) & !((c & d & e) | (!c & !d & !e))); assign cerr8 = (!P31 & e & !i & !g & !h & !j); assign cerr9 = (!P13 & !e & i & g & h & j); reg cerr; always @(posedge RBYTECLK or posedge reset) if (reset) cerr <= 0; else cerr <= cerr1|cerr2|cerr3|cerr4|cerr5|cerr6|cerr7|cerr8|cerr9; wire zerr1, zerr2, zerr3; assign zerr1 = (DISPARITY6p & DISPARITY4p) | (DISPARITY6n & DISPARITY4n); assign zerr2 = (f & g & !h & !j & DISPARITY6p); assign zerr3 = (!f & !g & h & j & DISPARITY6n); reg zerr; always @(posedge RBYTECLK or posedge reset) if (reset) zerr <= 0; else zerr <= zerr1|zerr2|zerr3; wire xerr1, xerr2, xerr3, xerr4; reg xerr; assign xerr1 = (a & b & c & !e & !i & ((!f & !g) | fghjP13)); assign xerr2 =(!a & !b & !c & e & i & ((f & g) | fghjP31)); assign xerr3 = (c & d & e & i & !f & !g & !h); assign xerr4 = (!c & !d & !e & !i & f & g & h); always @(posedge RBYTECLK or posedge reset) if (reset) xerr <= 0; else xerr <= xerr1|xerr2|xerr3|xerr4; always @(posedge RBYTECLK or posedge reset) if (reset) coding_err <= 1'b1; else coding_err <= cerr | zerr | xerr; endmodule"
    },
    {
        "file_name": "encoder_8b10b.v",
        "verilog_design": "`include \"timescale.v\" module encoder_8b10b ( input reset, input SBYTECLK, input K, input [7:0] ebi, output [9:0] tbi, output reg disparity ); wire L40, L04, L13, L31, L22, AeqB, CeqD; wire PD_1S6, NDOS6, PDOS6, ND_1S6; wire ND_1S4, PD_1S4, NDOS4, PDOS4; wire illegalk, DISPARITY6; reg COMPLS6, COMPLS4; wire NAO, NBO, NCO, NDO, NEO, NIO; wire NFO, NGO, NHO, NJO; wire A,B,C,D,E,F,G,H; assign {H,G,F,E,D,C,B,A} = ebi[7:0]; reg a,b,c,d,e,i,f,g,h,j; assign tbi[9:0] = {a,b,c,d,e,i,f,g,h,j}; wire [9:0] tst; assign tst[9:0] = {NAO,NBO,NCO,NDO,NEO,NIO,NFO,NGO,NHO,NJO}; always @(posedge SBYTECLK or posedge reset) if (reset) begin disparity <= 1'b0; {a,b,c,d,e,i,f,g,h,j} <= 10'b0; end else begin disparity <= (PDOS4 | NDOS4) ^ DISPARITY6; {a,b,c,d,e,i,f,g,h,j} <= { NAO^COMPLS6, NBO^COMPLS6, NCO^COMPLS6, NDO^COMPLS6, NEO^COMPLS6, NIO^COMPLS6, NFO^COMPLS4, NGO^COMPLS4, NHO^COMPLS4, NJO^COMPLS4 }; end assign AeqB = (A & B) | (!A & !B); assign CeqD = (C & D) | (!C & !D); assign L40 = A & B & C & D ; assign L04 = !A & !B & !C & !D; assign L13 = (!AeqB & !C & !D) | (!CeqD & !A & !B); assign L31 = (!AeqB & C & D) | (!CeqD & A & B); assign L22 = (A & B & !C & !D) | (C & D & !A & !B) | ( !AeqB & !CeqD) ; assign PD_1S6 = (E & D & !C & !B & !A) | (!E & !L22 & !L31) ; assign NDOS6 = PD_1S6 ; assign PDOS6 = K | (E & !L22 & !L13) ; assign ND_1S6 = K | (E & !L22 & !L13) | (!E & !D & C & B & A) ; assign ND_1S4 = F & G ; assign NDOS4 = (!F & !G) ; assign PD_1S4 = (!F & !G) | (K & ((F & !G) | (!F & G))); assign PDOS4 = F & G & H ; assign illegalk = K & (A | B | !C | !D | !E) & (!F | !G | !H | !E | !L31); assign DISPARITY6 = disparity ^ (NDOS6 | PDOS6) ; always @(posedge SBYTECLK or posedge reset) if(reset) begin COMPLS4 <= 0; COMPLS6 <= 0; end else begin COMPLS4 <= (PD_1S4 & !DISPARITY6) | (ND_1S4 & DISPARITY6); COMPLS6 <= (PD_1S6 & !disparity) | (ND_1S6 & disparity); end reg tNAO, tNBOx, tNBOy, tNCOx, tNCOy, tNDO , tNEOx, tNEOy, tNIOw, tNIOx, tNIOy, tNIOz; always @(posedge SBYTECLK or posedge reset) if(reset) begin tNAO <= 0; tNBOx <= 0; tNBOy <= 0; tNCOx <= 0; tNCOy <= 0; tNDO <= 0; tNEOx <= 0; tNEOy <= 0; tNIOw <= 0; tNIOx <= 0; tNIOy <= 0; tNIOz <= 0; end else begin tNAO <= A ; tNBOx <= B & !L40; tNBOy <= L04 ; tNCOx <= L04 | C ; tNCOy <= E & D & !C & !B & !A ; tNDO <= D & ! (A & B & C) ; tNEOx <= E | L13; tNEOy <= !(E & D & !C & !B & !A) ; tNIOw <= (L22 & !E) | (E & L40) ; tNIOx <= E & !D & !C & !(A & B) ; tNIOy <= K & E & D & C & !B & !A ; tNIOz <= E & !D & C & !B & !A ; end assign NAO = tNAO ; assign NBO = tNBOx | tNBOy ; assign NCO = tNCOx | tNCOy ; assign NDO = tNDO ; assign NEO = tNEOx & tNEOy ; assign NIO = tNIOw | tNIOx | tNIOy | tNIOz; reg alt7, tNFO, tNGO, tNHO, tNJO; always @(posedge SBYTECLK or posedge reset) if(reset) begin alt7 <= 0; tNFO <= 0; tNGO <= 0; tNHO <= 0; tNJO <= 0; end else begin alt7 <= F & G & H & (K | (disparity ? (!E & D & L31) : (E & !D & L13))) ; tNFO <= F; tNGO <= G | (!F & !G & !H) ; tNHO <= H ; tNJO <= !H & (G ^ F) ; end assign NFO = tNFO & !alt7 ; assign NGO = tNGO ; assign NHO = tNHO ; assign NJO = tNJO | alt7 ; endmodule"
    },
    {
        "file_name": "ge_1000baseX_mdio.v",
        "verilog_design": "`include \"ge_1000baseX_constants.v\" `include \"timescale.v\" module ge_1000baseX_mdio #( parameter PHY_ADDR = 5'b00000 ) ( input reset, input mdc, input mdio, output mdio_out, output mdio_oe, output [4:0] data_addr, input [15:0] data_rd, output [15:0] data_wr, output reg strobe_wr ); `ifdef MODEL_TECH enum logic [3:0] { `else localparam `endif S_PREAMBLE = 0, S_ST = 1, S_OP_CODE = 2, S_PHY_ADDR = 3, S_REG_ADDR = 4, S_TA = 5, S_WR_DATA = 6, S_RD_DATA = 7, S_WR_COMMIT = 8 `ifdef MODEL_TECH } present, next; `else ; reg [3:0] present, next; `endif reg [5:0] preamble_cnt; assign preamble_match = (preamble_cnt == 31); always @(posedge mdc or posedge reset) if (reset) preamble_cnt = 0; else preamble_cnt <= (mdio & ~preamble_match) ? preamble_cnt + 1 : (mdio & preamble_match) ? preamble_cnt : 0; reg pos_cnt_inc; reg [4:0] pos_cnt; always @(posedge mdc or posedge reset) if (reset) pos_cnt <= 0; else pos_cnt <= (pos_cnt_inc) ? pos_cnt + 1 : 0; assign op_code_done = (pos_cnt == 1); assign phy_addr_done = (pos_cnt == 6); assign reg_addr_done = (pos_cnt == 11); assign ta0_done = (pos_cnt == 12); assign ta1_done = (pos_cnt == 13); assign data_done = (pos_cnt == 29); reg st; reg st_latch; always @(posedge mdc or posedge reset) if (reset) st <= 0; else if (st_latch) st <= mdio; assign st_match = ~st & mdio; reg [1:0] op_code; reg op_code_shift; always @(posedge mdc or posedge reset) if (reset) op_code <= 0; else if (op_code_shift) op_code <= { op_code[0], mdio}; assign op_is_rd = (op_code == 2'b10); assign op_is_wr = (op_code == 2'b01); assign op_is_invalid = ~op_is_rd & ~op_is_wr; reg [4:0] phy_addr; reg phy_addr_shift; always @(posedge mdc or posedge reset) if (reset) phy_addr <= 0; else if (phy_addr_shift) phy_addr <= { phy_addr[3:0], mdio}; assign phy_addr_match = (phy_addr == PHY_ADDR); reg [4:0] reg_addr; reg reg_addr_shift; always @(posedge mdc or posedge reset) if (reset) reg_addr <= 0; else if (reg_addr_shift) reg_addr <= { reg_addr[3:0], mdio}; assign data_addr = reg_addr; reg [15:0] data_in; reg data_in_shift; always @(posedge mdc or posedge reset) if (reset) data_in <= 0; else if (data_in_shift) data_in <= { data_in[14:0], mdio}; assign data_wr = data_in; reg [15:0] data_out; reg data_out_load, data_out_shift; always @(posedge mdc or posedge reset) if (reset) data_out <= 0; else if (data_out_load) data_out <= data_rd; else if (data_out_shift) data_out <= { data_out[14:0], 1'b0 }; assign mdio_oe = (ta1_done & op_is_rd) | data_out_shift; assign mdio_out = (ta1_done & op_is_rd) ? 1'b1 : data_out[15]; always @(posedge mdc or posedge reset) present <= (reset) ? S_PREAMBLE : next; always @* begin next = present; pos_cnt_inc = 0; st_latch = 0; op_code_shift = 0; phy_addr_shift = 0; reg_addr_shift = 0; data_in_shift = 0; data_out_load = 0; data_out_shift = 0; strobe_wr = 0; case (present) S_PREAMBLE: begin next = (preamble_match & ~mdio) ? S_ST : S_PREAMBLE; end S_ST: begin next = (mdio) ? S_OP_CODE: S_PREAMBLE; end S_OP_CODE: begin pos_cnt_inc = 1; op_code_shift = 1; next = (op_code_done) ? S_PHY_ADDR : S_OP_CODE; end S_PHY_ADDR: begin pos_cnt_inc = 1; phy_addr_shift = 1; next = (phy_addr_done) ? S_REG_ADDR : S_PHY_ADDR; end S_REG_ADDR: begin if (phy_addr_match) begin pos_cnt_inc = 1; reg_addr_shift = 1; next = (reg_addr_done) ? S_TA : S_REG_ADDR; end else next = S_PREAMBLE; end S_TA: begin pos_cnt_inc = 1; if (ta1_done) begin data_out_load = op_is_rd; next = (op_is_rd) ? S_RD_DATA : (op_is_wr) ? S_WR_DATA : S_PREAMBLE; end end S_WR_DATA: begin pos_cnt_inc = 1; data_in_shift = 1; next = (data_done) ? S_WR_COMMIT : S_WR_DATA; end S_RD_DATA: begin pos_cnt_inc = 1; data_out_shift = 1; next = (data_done) ? S_PREAMBLE : S_RD_DATA; end S_WR_COMMIT: begin strobe_wr = 1; next = S_PREAMBLE; end endcase end endmodule"
    },
    {
        "file_name": "ge_1000baseX_rx.v",
        "verilog_design": "`include \"timescale.v\" `include \"ge_1000baseX_regs.v\" `include \"ge_1000baseX_constants.v\" module ge_1000baseX_rx( input ck, input reset, input [7:0] ebi_rxd, input ebi_K, input rx_even, input carrier_detect, input sync_status, input signal_detect, output rx_frame_pulse, output reg [7:0] gmii_rxd, output reg gmii_rx_dv, output reg gmii_rx_er, output reg receiving, input [2:0] xmit, output reg [15:0] rx_config, output reg rx_config_set, input mr_main_reset, output reg [2:0] rudi, output reg ability_match, output reg acknowledge_match, output consistency_match, output idle_match ); `define RX_FRAME_CNT 16'h0000 `define RX_DATA_CNT 16'h0001 `define EARLY_END_CNT 16'h0002 `define CHECK_END_T_R_K28_5_CNT 16'h0003 `define CHECK_END_R_R_K28_5_CNT 16'h0004 `define CHECK_END_T_R_R_CNT 16'h0005 `define CHECK_END_R_R_R_CNT 16'h0006 `define CHECK_END_R_R_S_CNT 16'h0007 `define RESET 16'hffff reg [7:0] ge_x_pcs_rx_stats_inc; reg [15:0] rx_frame_cnt; reg [15:0] rx_data_cnt; reg [15:0] early_end_cnt; reg [15:0] check_end_T_R_K28_5_cnt; reg [15:0] check_end_R_R_K28_5_cnt; reg [15:0] check_end_T_R_R_cnt; reg [15:0] check_end_R_R_R_cnt; reg [15:0] check_end_R_R_S_cnt; always @(posedge ck or posedge reset) if (reset) begin rx_frame_cnt <= 0; rx_data_cnt <= 0; early_end_cnt <= 0; check_end_T_R_K28_5_cnt <= 0; check_end_R_R_K28_5_cnt <= 0; check_end_T_R_R_cnt <= 0; check_end_R_R_R_cnt <= 0; check_end_R_R_S_cnt <= 0; end else begin if (ge_x_pcs_rx_stats_inc[0]) rx_frame_cnt <= rx_frame_cnt + 1; else if (ge_x_pcs_rx_stats_inc[1]) rx_data_cnt <= rx_data_cnt + 1; else if (ge_x_pcs_rx_stats_inc[2]) early_end_cnt <= early_end_cnt + 1; else if (ge_x_pcs_rx_stats_inc[3]) check_end_T_R_K28_5_cnt <= check_end_T_R_K28_5_cnt + 1; else if (ge_x_pcs_rx_stats_inc[4]) check_end_R_R_K28_5_cnt <= check_end_R_R_K28_5_cnt + 1; else if (ge_x_pcs_rx_stats_inc[5]) check_end_T_R_R_cnt <= check_end_T_R_R_cnt + 1; else if (ge_x_pcs_rx_stats_inc[6]) check_end_R_R_R_cnt <= check_end_R_R_R_cnt + 1; else if (ge_x_pcs_rx_stats_inc[7]) check_end_R_R_S_cnt <= check_end_R_R_S_cnt + 1; end assign rx_frame_pulse = ge_x_pcs_rx_stats_inc[0]; reg soft_reset; always @(posedge ck or posedge reset) if (reset) soft_reset <= 0; else soft_reset <= mr_main_reset; reg [7:0] ebi_rxd_d1; reg [7:0] ebi_rxd_d2; reg [7:0] ebi_rxd_d3; reg ebi_K_d1, ebi_K_d2, ebi_K_d3; reg rx_even_d1, rx_even_d2, rx_even_d3; reg sync_status_d1, sync_status_d2, sync_status_d3; reg carrier_detect_d1, carrier_detect_d2, carrier_detect_d3; always @(posedge ck or posedge reset) if (reset) begin ebi_K_d1 <= 0; ebi_K_d2 <= 0; ebi_K_d3 <= 0; rx_even_d1 <= 0; rx_even_d2 <= 0; rx_even_d3 <= 0; ebi_rxd_d1 <= 0; ebi_rxd_d2 <= 0; ebi_rxd_d3 <= 0; sync_status_d1 <= 0; sync_status_d2 <= 0; sync_status_d3 <= 0; carrier_detect_d1 <= 0; carrier_detect_d2 <= 0; carrier_detect_d3 <= 0; end else begin ebi_K_d3 <= ebi_K_d2; ebi_K_d2 <= ebi_K_d1; ebi_K_d1 <= ebi_K; rx_even_d3 <= rx_even_d2; rx_even_d2 <= rx_even_d1; rx_even_d1 <= rx_even; ebi_rxd_d3 <= ebi_rxd_d2; ebi_rxd_d2 <= ebi_rxd_d1; ebi_rxd_d1 <= ebi_rxd; sync_status_d3 <= sync_status_d2; sync_status_d2 <= sync_status_d1; sync_status_d1 <= sync_status; carrier_detect_d3 <= carrier_detect_d2; carrier_detect_d2 <= carrier_detect_d1; carrier_detect_d1 <= carrier_detect; end `ifdef MODEL_TECH wire [4:0] ebi_rxd_d1_X; wire [2:0] ebi_rxd_d1_Y; wire [4:0] ebi_rxd_d2_X; wire [2:0] ebi_rxd_d2_Y; wire [4:0] ebi_rxd_d3_X; wire [2:0] ebi_rxd_d3_Y; assign {ebi_rxd_d1_Y, ebi_rxd_d1_X} = ebi_rxd_d1; assign {ebi_rxd_d2_Y, ebi_rxd_d2_X} = ebi_rxd_d2; assign {ebi_rxd_d3_Y, ebi_rxd_d3_X} = ebi_rxd_d3; `endif wire early_end_idle; assign early_end_idle = (ebi_K_d2 & ebi_rxd_d2 == `K28_5_symbol) & ~(ebi_K_d1) & (ebi_K & ebi_rxd == `K28_5_symbol); wire early_end_config; assign early_end_config = (( ebi_K_d2 & ebi_rxd_d2 == `K28_5_symbol) & (~ebi_K_d1 & (ebi_rxd_d1 == `D21_5_symbol | ebi_rxd_d1 == `D2_2_symbol)) & (~ebi_K & ebi_rxd == `D0_0_symbol)); reg early_end; always @(posedge ck or posedge reset) if (reset) early_end <= 0; else early_end <= (early_end_idle | early_end_config) & rx_even; reg check_end_T_R_K28_5; always @(posedge ck or posedge reset) if (reset) check_end_T_R_K28_5 <= 0; else check_end_T_R_K28_5 <= ((ebi_K_d2 & ebi_rxd_d2 == `K29_7_symbol) & (ebi_K_d1 & ebi_rxd_d1 == `K23_7_symbol) & (ebi_K & ebi_rxd == `K28_5_symbol) & rx_even); reg check_end_T_R_R; always @(posedge ck or posedge reset) if (reset) check_end_T_R_R <= 0; else check_end_T_R_R <= ((ebi_K_d2 & ebi_rxd_d2 == `K29_7_symbol) & (ebi_K_d1 & ebi_rxd_d1 == `K23_7_symbol) & (ebi_K & ebi_rxd == `K23_7_symbol)); reg check_end_R_R_R; always @(posedge ck or posedge reset) if (reset) check_end_R_R_R <= 0; else check_end_R_R_R <= ((ebi_K_d2 & ebi_rxd_d2 == `K23_7_symbol) & (ebi_K_d1 & ebi_rxd_d1 == `K23_7_symbol) & (ebi_K & ebi_rxd == `K23_7_symbol)); reg check_end_R_R_K28_5; always @(posedge ck or posedge reset) if (reset) check_end_R_R_K28_5 <= 0; else check_end_R_R_K28_5 <= ((ebi_K_d2 & ebi_rxd_d2 == `K23_7_symbol) & (ebi_K_d1 & ebi_rxd_d1 == `K23_7_symbol) & (ebi_K & ebi_rxd == `K28_5_symbol) & rx_even); reg check_end_R_R_S; always @(posedge ck or posedge reset) if (reset) check_end_R_R_S <= 0; else check_end_R_R_S <= ((ebi_K_d2 & ebi_rxd_d2 == `K23_7_symbol) & (ebi_K_d1 & ebi_rxd_d1 == `K23_7_symbol) & (ebi_K & ebi_rxd == `K27_7_symbol)); reg K28_5_match, D2_2_match, D21_5_match, D5_6_match, D16_2_match; always @(posedge ck or posedge reset) if (reset) begin K28_5_match <= 0; D2_2_match <= 0; D21_5_match <= 0; D5_6_match <= 0; D16_2_match <= 0; end else begin K28_5_match <= (ebi_K_d2 & ebi_rxd_d2 == `K28_5_symbol); D2_2_match <= ~ebi_K_d2 & (ebi_rxd_d2 == `D2_2_symbol); D21_5_match <= ~ebi_K_d2 & (ebi_rxd_d2 == `D21_5_symbol); D5_6_match <= ~ebi_K_d2 & (ebi_rxd_d2 == `D5_6_symbol); D16_2_match <= ~ebi_K_d2 & (ebi_rxd_d2 == `D16_2_symbol); end reg CE_match, SPD_match, EPD_match; always @(posedge ck or posedge reset) if (reset) begin CE_match <= 0; SPD_match <= 0; EPD_match <= 0; end else begin CE_match <= ebi_K_d2 & (ebi_rxd_d2 == `K23_7_symbol); SPD_match <= ebi_K_d2 & (ebi_rxd_d2 == `K27_7_symbol); EPD_match <= ebi_K_d2 & (ebi_rxd_d2 == `K29_7_symbol); end `ifdef MODEL_TECH wire [4:0] ebi_rxd_X; wire [2:0] ebi_rxd_Y; assign ebi_rxd_X = ebi_rxd[4:0]; assign ebi_rxd_Y = ebi_rxd[7:5]; `endif reg [15:0] rx_config_d1; reg [15:0] rx_config_d2; reg [7:0] rx_config_lo; reg rx_config_lo_read, rx_config_hi_read; wire [15:0] rx_config_tmp = { ebi_rxd_d3, rx_config_lo }; always @(posedge ck or posedge reset) if (reset) begin rx_config <= 0; rx_config_set <= 0; rx_config_lo <= 0; rx_config_d1 <= 0; rx_config_d2 <= 0; end else begin if (rx_config_lo_read) begin rx_config_d2 <= rx_config_d1; rx_config_d1 <= rx_config; rx_config_lo <= ebi_rxd_d3; end else if (rx_config_hi_read) begin rx_config <= rx_config_tmp; rx_config_set <= |rx_config_tmp; end end reg [2:0] rx_config_cnt; reg rx_config_cnt_m_inc, rx_config_cnt_m_rst; always @(posedge ck or posedge reset) if (reset) rx_config_cnt <= 0; else begin if (rx_config_cnt_m_inc) rx_config_cnt <= rx_config_cnt + 1; else if (rx_config_cnt_m_rst) rx_config_cnt <= 0; end wire rx_config_cnt_done; assign rx_config_cnt_done = (rx_config_cnt == 3); wire [6:0] ability; wire [6:0] ability_d1; wire [6:0] ability_d2; assign ability = { rx_config[15], rx_config[13:12], rx_config[8:5] }; assign ability_d1 = { rx_config_d1[15], rx_config_d1[13:12], rx_config_d1[8:5]}; assign ability_d2 = { rx_config_d2[15], rx_config_d2[13:12], rx_config_d2[8:5]}; assign ability_matched1 = ~| (ability ^ ability_d1); assign ability_matched2 = ~| (ability ^ ability_d2); assign ability_matched = rx_config_cnt_done & ability_matched1 & ability_matched2; reg [6:0] ability_matched_reg; always @(posedge ck or posedge reset) if (reset) ability_matched_reg <= 0; else begin ability_match <= ability_matched; if (ability_matched) ability_matched_reg <= ability; end assign rx_config_match1 = ability_matched1 & ~(rx_config[14] ^ rx_config_d1[14]); assign rx_config_match2 = ability_matched2 & ~(rx_config[14] ^ rx_config_d2[14]); assign rx_config_match = rx_config_match1 & rx_config_match2; always @(posedge ck or posedge reset) acknowledge_match <= (reset) ? 0 : ( rx_config_match & rx_config_d2[14] ); assign consistency_match = ability_match & ~|(ability_matched_reg ^ ability); reg [1:0] idle_cnt; reg idle_cnt_m_inc, idle_cnt_m_clr; always @(posedge ck or posedge reset) if (reset) idle_cnt <= 0; else begin if (idle_cnt_m_clr) idle_cnt <= 0; else if (idle_cnt_m_inc) idle_cnt <= idle_cnt + 1; end assign idle_match = (idle_cnt == 3); reg rudi_INVALID_m_set; reg rudi_IDLE_m_set; reg rudi_CONF_m_set; always @(posedge ck or posedge reset) if (reset) rudi <= `RUDI_INVALID; else begin if (rudi_INVALID_m_set) rudi <= `RUDI_INVALID; else if (rudi_IDLE_m_set) rudi <= `RUDI_IDLE; else if (rudi_CONF_m_set) rudi <= `RUDI_CONF; end reg gmii_rxd_false_carrier_m_set, gmii_rxd_preamble_m_set, gmii_rxd_ext_err_m_set; reg gmii_rxd_packet_burst_m_set, gmii_rxd_trr_extend_m_set, gmii_rxd_m_set; always @(posedge ck or posedge reset) if (reset) gmii_rxd <= 0; else begin gmii_rxd <= (gmii_rxd_m_set) ? ebi_rxd_d3 : (gmii_rxd_false_carrier_m_set) ? 8'b00001110 : (gmii_rxd_preamble_m_set) ? 8'b01010101 : (gmii_rxd_ext_err_m_set) ? 8'b00011111 : (gmii_rxd_trr_extend_m_set) ? 8'b00001111 : (gmii_rxd_packet_burst_m_set) ? 8'b00001111 : 0; end reg receiving_m_set, receiving_m_clr; always @(posedge ck or posedge reset) if (reset) receiving <= 0; else begin if (receiving_m_set) receiving <= 1; else if (receiving_m_clr) receiving <= 0; end `ifdef MODEL_TECH enum logic [4:0] { `else localparam `endif S_PCS_RX_START = 0, S_PCS_RX_LINK_FAILED = 1, S_PCS_RX_WAIT_K = 2, S_PCS_RX_K = 3, S_PCS_RX_CONFIG_CB = 4, S_PCS_RX_CONFIG_CC = 5, S_PCS_RX_CONFIG_CD = 6, S_PCS_RX_INVALID = 7, S_PCS_RX_IDLE_D = 8, S_PCS_RX_FALSE_CARRIER = 9, S_PCS_RX_START_OF_PACKET = 10, S_PCS_RX_RECEIVE = 11, S_PCS_RX_EARLY_END = 12, S_PCS_RX_TRI_RRI = 13, S_PCS_RX_TRR_EXTEND = 14, S_PCS_RX_EPD2_CHECK_END = 15, S_PCS_RX_PACKET_BURST_RRS = 16, S_PCS_RX_EXTEND_ERR = 17, S_PCS_RX_EARLY_END_EXT = 18, S_PCS_RX_DATA_ERROR = 19, S_PCS_RX_DATA = 20 `ifdef MODEL_TECH } pcs_rx_present, pcs_rx_next; `else ; reg [4:0] pcs_rx_present, pcs_rx_next; `endif reg gmii_rx_er_m_set, gmii_rx_er_m_clr; always @(posedge ck or posedge reset) if (reset) gmii_rx_er <= 0; else begin if (gmii_rx_er_m_set) gmii_rx_er <= 1; else if (gmii_rx_er_m_clr) gmii_rx_er <= 0; end reg gmii_rx_dv_m_set, gmii_rx_dv_m_clr; always @(posedge ck or posedge reset) if (reset) gmii_rx_dv <= 0; else begin if (gmii_rx_dv_m_set) gmii_rx_dv <= 1; else if (gmii_rx_dv_m_clr) gmii_rx_dv <= 0; end wire xmit_DATA, xmit_nDATA, xmit_DATA_CD, xmit_DATA_nCD; assign xmit_DATA = (xmit == `XMIT_DATA); assign xmit_nDATA = (xmit != `XMIT_DATA); assign xmit_DATA_CD = (xmit_DATA & carrier_detect_d3); assign xmit_DATA_nCD = (xmit_DATA & ~carrier_detect_d3); wire xmit_DATA_CD_SPD, xmit_DATA_CD_nSPD, xmit_DATA_CD_nSPD_nK28_5; assign xmit_DATA_CD_SPD = xmit_DATA_CD & SPD_match; assign xmit_DATA_CD_nSPD = xmit_DATA_CD & ~SPD_match; assign xmit_DATA_CD_nSPD_nK28_5 = xmit_DATA_CD_nSPD & ~K28_5_match; always @(posedge ck or posedge reset) pcs_rx_present <= (reset) ? S_PCS_RX_START : pcs_rx_next; always @* begin pcs_rx_next = pcs_rx_present; rx_config_lo_read = 0; rx_config_hi_read = 0; receiving_m_set = 0; receiving_m_clr = 0; gmii_rxd_false_carrier_m_set = 0; gmii_rxd_preamble_m_set = 0; gmii_rxd_ext_err_m_set = 0; gmii_rxd_packet_burst_m_set = 0; gmii_rxd_trr_extend_m_set = 0; gmii_rxd_m_set = 0; idle_cnt_m_clr = 0; idle_cnt_m_inc = 0; gmii_rx_er_m_set = 0; gmii_rx_er_m_clr = 0; gmii_rx_dv_m_set = 0; gmii_rx_dv_m_clr = 0; rudi_INVALID_m_set = 0; rudi_IDLE_m_set = 0; rudi_CONF_m_set = 0; rx_config_cnt_m_inc = 0; rx_config_cnt_m_rst = 0; ge_x_pcs_rx_stats_inc = 16'h0000; case (pcs_rx_present) S_PCS_RX_START: begin pcs_rx_next = S_PCS_RX_LINK_FAILED; end S_PCS_RX_LINK_FAILED: begin rudi_INVALID_m_set = (xmit_nDATA); if (receiving) begin receiving_m_clr = 1; gmii_rx_er_m_set = 1; end else begin gmii_rx_dv_m_clr = 1; gmii_rx_er_m_clr = 1; end pcs_rx_next = S_PCS_RX_WAIT_K; end S_PCS_RX_WAIT_K: begin rx_config_cnt_m_rst = 1; receiving_m_clr = 1; gmii_rx_dv_m_clr = 1; gmii_rx_er_m_clr = 1; pcs_rx_next = (K28_5_match & rx_even_d3) ? S_PCS_RX_K : S_PCS_RX_WAIT_K; end S_PCS_RX_K: begin receiving_m_clr = 1; gmii_rx_dv_m_clr = 1; gmii_rx_er_m_clr = 1; rudi_IDLE_m_set = (xmit_nDATA & ~ebi_K_d3 & ~D21_5_match & ~D2_2_match) | (xmit_DATA & ~D21_5_match & ~D2_2_match); pcs_rx_next = (D21_5_match | D2_2_match) ? S_PCS_RX_CONFIG_CB : ((xmit_nDATA) & ~ebi_K_d3 & ~D21_5_match & ~D2_2_match) ? S_PCS_RX_IDLE_D : ((xmit_DATA) & ~D21_5_match & ~D2_2_match) ? S_PCS_RX_IDLE_D : ((xmit_nDATA) & ebi_K_d3) ? S_PCS_RX_INVALID : S_PCS_RX_INVALID; end S_PCS_RX_CONFIG_CB: begin rx_config_cnt_m_inc = ~rx_config_cnt_done; rx_config_lo_read = ~ebi_K_d3; receiving_m_clr = 1; gmii_rx_dv_m_clr = 1; gmii_rx_er_m_clr = 1; pcs_rx_next = (ebi_K_d3) ? S_PCS_RX_INVALID : S_PCS_RX_CONFIG_CC; end S_PCS_RX_CONFIG_CC: begin rx_config_hi_read = ~ebi_K_d3; idle_cnt_m_clr = 1; rudi_CONF_m_set = ~ebi_K_d3; pcs_rx_next = (ebi_K_d3) ? S_PCS_RX_INVALID : S_PCS_RX_CONFIG_CD; end S_PCS_RX_CONFIG_CD: begin pcs_rx_next = (K28_5_match & rx_even_d3) ? S_PCS_RX_K : S_PCS_RX_INVALID; end S_PCS_RX_INVALID: begin rudi_INVALID_m_set = (xmit == `XMIT_CONFIGURATION); receiving_m_set = (xmit_DATA); pcs_rx_next = (K28_5_match & rx_even_d3) ? S_PCS_RX_K : (~K28_5_match & rx_even_d3) ? S_PCS_RX_WAIT_K : S_PCS_RX_INVALID; end S_PCS_RX_IDLE_D: begin rx_config_cnt_m_rst = 1; idle_cnt_m_inc = ~idle_match; rudi_IDLE_m_set = 1; if (xmit_DATA_CD_SPD) gmii_rx_dv_m_set = 1; else gmii_rx_dv_m_clr = 1; if (xmit_DATA_CD_nSPD_nK28_5) gmii_rx_er_m_set = 1; else gmii_rx_er_m_clr = 1; if (xmit_DATA_CD) begin if (~K28_5_match) begin receiving_m_set = 1; if (SPD_match) gmii_rxd_preamble_m_set = 1; else gmii_rxd_false_carrier_m_set = 1; end end else receiving_m_clr = 1; pcs_rx_next = (~K28_5_match & ~xmit_DATA ) ? S_PCS_RX_INVALID : ( xmit_DATA_CD_SPD ) ? S_PCS_RX_RECEIVE : ( xmit_DATA_nCD | K28_5_match ) ? S_PCS_RX_K : ( xmit_DATA_CD_nSPD ) ? S_PCS_RX_FALSE_CARRIER : S_PCS_RX_IDLE_D; ge_x_pcs_rx_stats_inc[0] = xmit_DATA_CD_SPD; end S_PCS_RX_FALSE_CARRIER: begin gmii_rx_er_m_set = 1; gmii_rxd_false_carrier_m_set = 1; pcs_rx_next = (K28_5_match & rx_even_d3) ? S_PCS_RX_K : S_PCS_RX_FALSE_CARRIER; end S_PCS_RX_START_OF_PACKET: begin gmii_rx_dv_m_set = 1; gmii_rx_er_m_clr = 1; gmii_rxd_preamble_m_set = 1; pcs_rx_next = S_PCS_RX_RECEIVE; end S_PCS_RX_RECEIVE: begin if (early_end) begin ge_x_pcs_rx_stats_inc[2] = 1; gmii_rx_er_m_set = 1; pcs_rx_next = S_PCS_RX_EARLY_END; end else if (check_end_T_R_K28_5) begin ge_x_pcs_rx_stats_inc[3] = 1; receiving_m_clr = 1; gmii_rx_dv_m_clr = 1; gmii_rx_er_m_clr = 1; pcs_rx_next = S_PCS_RX_TRI_RRI; end else if (check_end_T_R_R) begin ge_x_pcs_rx_stats_inc[5] = 1; gmii_rx_dv_m_clr = 1; gmii_rx_er_m_set = 1; gmii_rxd_trr_extend_m_set = 1; pcs_rx_next = S_PCS_RX_EPD2_CHECK_END; end else if (check_end_R_R_R) begin ge_x_pcs_rx_stats_inc[6] = 1; gmii_rx_er_m_set = 1; pcs_rx_next = S_PCS_RX_EPD2_CHECK_END; end else if (~ebi_K_d3) begin ge_x_pcs_rx_stats_inc[1] = 1; gmii_rx_er_m_clr = 1; gmii_rxd_m_set = 1; end else gmii_rx_er_m_set = 1; end S_PCS_RX_EARLY_END: begin pcs_rx_next = (D21_5_match | D2_2_match) ? S_PCS_RX_CONFIG_CB : S_PCS_RX_IDLE_D; end S_PCS_RX_TRI_RRI: begin pcs_rx_next = (K28_5_match) ? S_PCS_RX_K : S_PCS_RX_TRI_RRI; end S_PCS_RX_TRR_EXTEND: begin gmii_rx_dv_m_clr = 1; gmii_rx_er_m_set = 1; gmii_rxd_trr_extend_m_set = 1; pcs_rx_next = S_PCS_RX_EPD2_CHECK_END; end S_PCS_RX_EPD2_CHECK_END: begin if (check_end_R_R_R) begin gmii_rx_dv_m_clr = 1; gmii_rx_er_m_set = 1; gmii_rxd_trr_extend_m_set = 1; end else if (check_end_R_R_K28_5) begin ge_x_pcs_rx_stats_inc[4] = 1; receiving_m_clr = 1; gmii_rx_dv_m_clr = 1; gmii_rx_er_m_clr = 1; end else if (check_end_R_R_S) begin ge_x_pcs_rx_stats_inc[7] = 1; end pcs_rx_next = (check_end_R_R_R) ? S_PCS_RX_TRR_EXTEND : (check_end_R_R_K28_5) ? S_PCS_RX_TRI_RRI : (check_end_R_R_S) ? S_PCS_RX_PACKET_BURST_RRS : S_PCS_RX_EXTEND_ERR; end S_PCS_RX_PACKET_BURST_RRS: begin gmii_rx_dv_m_clr = 1; gmii_rxd_packet_burst_m_set = 1; pcs_rx_next = (SPD_match) ? S_PCS_RX_START_OF_PACKET : S_PCS_RX_PACKET_BURST_RRS; end S_PCS_RX_EXTEND_ERR: begin gmii_rx_dv_m_clr = 1; gmii_rxd_ext_err_m_set = 1; pcs_rx_next = (SPD_match) ? S_PCS_RX_START_OF_PACKET : (K28_5_match & rx_even_d3) ? S_PCS_RX_K : (~SPD_match & ~K28_5_match & rx_even_d3) ? S_PCS_RX_EPD2_CHECK_END : S_PCS_RX_EXTEND_ERR; end S_PCS_RX_EARLY_END_EXT: begin gmii_rx_er_m_set = 1; pcs_rx_next = S_PCS_RX_EPD2_CHECK_END; end S_PCS_RX_DATA_ERROR: begin gmii_rx_er_m_set = 1; pcs_rx_next = S_PCS_RX_RECEIVE; end S_PCS_RX_DATA: begin gmii_rx_er_m_clr = 1; gmii_rxd_m_set = 1; pcs_rx_next = S_PCS_RX_RECEIVE; end endcase if (~signal_detect) pcs_rx_next = S_PCS_RX_LINK_FAILED; else if (~sync_status_d3) pcs_rx_next = S_PCS_RX_LINK_FAILED; else if (soft_reset) pcs_rx_next = S_PCS_RX_WAIT_K; end endmodule"
    },
    {
        "file_name": "ge_1000baseX_sync.v",
        "verilog_design": "`include \"ge_1000baseX_constants.v\" `include \"timescale.v\" module ge_1000baseX_sync( input ck, input reset, input startup_enable, input signal_detect, input [7:0] ebi_rxd, input ebi_K, output reg [7:0] ebi_rxd_out, output reg ebi_K_out, input decoder_disparity_err, input decoder_coding_err, output reg sync_status, output reg rx_even, input loopback ); reg running_disparity; reg running_disparity_positive_m_set; reg running_disparity_negative_m_set; always @(posedge ck or posedge reset) if (reset) running_disparity <= 0; else begin if (running_disparity_positive_m_set) running_disparity <= 1; else if (running_disparity_negative_m_set) running_disparity <= 0; end reg sync_m_acquired, sync_m_lost; always @(posedge ck or posedge reset) if (reset) sync_status <= 0; else begin if (sync_m_acquired) begin sync_status <= 1; end else if (sync_m_lost) begin sync_status <= 0; end end reg rx_even_m_init, rx_even_m_set, rx_even_m_clr, rx_even_m_toggle; always @(posedge ck or posedge reset) if (reset) rx_even <= 1; else begin if (rx_even_m_init) rx_even <= 1; else if (rx_even_m_set) rx_even <= 1; else if (rx_even_m_clr) rx_even <= 0; else if (rx_even_m_toggle) rx_even <= ~rx_even; end reg [7:0] ebi_rxd_d1; reg ebi_K_d1; always @(posedge ck or posedge reset) if (reset) begin ebi_rxd_d1 <= 0; ebi_K_d1 <= 0; end else begin ebi_rxd_d1 <= ebi_rxd; ebi_K_d1 <= ebi_K; end always @(posedge ck or posedge reset) if (reset) begin ebi_rxd_out <= 0; ebi_K_out <=0; end else begin ebi_rxd_out <= ebi_rxd_d1; ebi_K_out <= ebi_K_d1; end assign K28_1_RX = (ebi_rxd_d1 == `K28_1_symbol); assign K28_5_RX = (ebi_rxd_d1 == `K28_5_symbol); assign K28_7_RX = (ebi_rxd_d1 == `K28_7_symbol); assign COMMA_RX = K28_1_RX | K28_5_RX | K28_7_RX; assign COMMA_match = COMMA_RX & ebi_K_d1; `ifdef MODEL_TECH wire [4:0] ebi_rxd_X; wire [2:0] ebi_rxd_Y; assign ebi_rxd_X = ebi_rxd[4:0]; assign ebi_rxd_Y = ebi_rxd[7:5]; `endif reg INVALID; always @(posedge ck or posedge reset) INVALID <= (reset) ? 0 : decoder_disparity_err | decoder_coding_err; assign VALID = ~INVALID; reg [2:0] good_cgs; reg good_cgs_m_init, good_cgs_m_inc, good_cgs_m_cnt; always @(posedge ck or posedge reset) if (reset) good_cgs <= 0; else begin if (good_cgs_m_init) good_cgs <= 0; else if (good_cgs_m_cnt) good_cgs <= 1; else if (good_cgs_m_inc) good_cgs <= good_cgs + 1 ; end assign good_cgs_done = (good_cgs == 3); assign cgbad = INVALID | (COMMA_match & rx_even); assign cggood = ~cgbad; `ifdef MODEL_TECH enum logic [3:0] { `else localparam `endif S_PCS_SYNC_RUN = 0, S_PCS_SYNC_LOSS_OF_SYNC = 1, S_PCS_SYNC_COMMA_DETECT_1 = 2, S_PCS_SYNC_ACQUIRE_SYNC_1 = 3, S_PCS_SYNC_COMMA_DETECT_2 = 4, S_PCS_SYNC_ACQUIRE_SYNC_2 = 5, S_PCS_SYNC_COMMA_DETECT_3 = 6, S_PCS_SYNC_ACQUIRED_1 = 7, S_PCS_SYNC_ACQUIRED_2 = 8, S_PCS_SYNC_ACQUIRED_3 = 9, S_PCS_SYNC_ACQUIRED_4 = 10, S_PCS_SYNC_ACQUIRED_2A = 11, S_PCS_SYNC_ACQUIRED_3A = 12, S_PCS_SYNC_ACQUIRED_4A = 13 `ifdef MODEL_TECH } pcs_sync_present, pcs_sync_next; `else ; reg [3:0] pcs_sync_present, pcs_sync_next; `endif always @(posedge ck or posedge reset) pcs_sync_present <= (reset) ? S_PCS_SYNC_RUN : pcs_sync_next; always @* begin pcs_sync_next = pcs_sync_present; good_cgs_m_init = 0; good_cgs_m_inc = 0; good_cgs_m_cnt = 0; sync_m_acquired = 0; sync_m_lost = 0; rx_even_m_init = 0; rx_even_m_set = 0; rx_even_m_clr = 0; rx_even_m_toggle = 0; running_disparity_negative_m_set = 0; running_disparity_positive_m_set = 0; case (pcs_sync_present) S_PCS_SYNC_RUN: begin if (startup_enable) pcs_sync_next = S_PCS_SYNC_LOSS_OF_SYNC; end S_PCS_SYNC_LOSS_OF_SYNC : begin sync_m_lost = sync_status; if ((signal_detect | loopback) & COMMA_match) begin rx_even_m_set = 1; pcs_sync_next = S_PCS_SYNC_COMMA_DETECT_1; end else rx_even_m_toggle = 1; end S_PCS_SYNC_COMMA_DETECT_1 : begin rx_even_m_toggle = 1; pcs_sync_next = (~ebi_K_d1 & ~cgbad) ? S_PCS_SYNC_ACQUIRE_SYNC_1 : S_PCS_SYNC_LOSS_OF_SYNC; end S_PCS_SYNC_ACQUIRE_SYNC_1: begin if (~rx_even & COMMA_match) begin rx_even_m_set = 1; pcs_sync_next = S_PCS_SYNC_COMMA_DETECT_2; end else begin rx_even_m_toggle = 1; pcs_sync_next = (~COMMA_match & ~INVALID) ? S_PCS_SYNC_ACQUIRE_SYNC_1 : S_PCS_SYNC_LOSS_OF_SYNC; end end S_PCS_SYNC_COMMA_DETECT_2: begin rx_even_m_toggle = 1; pcs_sync_next = (~ebi_K_d1 & ~cgbad) ? S_PCS_SYNC_ACQUIRE_SYNC_2 : S_PCS_SYNC_LOSS_OF_SYNC; end S_PCS_SYNC_ACQUIRE_SYNC_2: begin if (~rx_even & COMMA_match) begin rx_even_m_set = 1; pcs_sync_next = S_PCS_SYNC_COMMA_DETECT_3; end else begin rx_even_m_toggle = 1; pcs_sync_next = (~COMMA_match & ~INVALID) ? S_PCS_SYNC_ACQUIRE_SYNC_2 : S_PCS_SYNC_LOSS_OF_SYNC; end end S_PCS_SYNC_COMMA_DETECT_3: begin rx_even_m_toggle = 1; pcs_sync_next = (~ebi_K_d1 & ~cgbad) ? S_PCS_SYNC_ACQUIRED_1 : S_PCS_SYNC_LOSS_OF_SYNC; sync_m_acquired = ~ebi_K_d1; end S_PCS_SYNC_ACQUIRED_1: begin rx_even_m_toggle = 1; pcs_sync_next = cggood ? S_PCS_SYNC_ACQUIRED_1 : S_PCS_SYNC_ACQUIRED_2; end S_PCS_SYNC_ACQUIRED_2: begin rx_even_m_toggle = 1; if (cggood) good_cgs_m_cnt = 1; else good_cgs_m_init = 1; pcs_sync_next = cggood ? S_PCS_SYNC_ACQUIRED_2A : S_PCS_SYNC_ACQUIRED_3; end S_PCS_SYNC_ACQUIRED_3: begin rx_even_m_toggle = 1; if (cggood) good_cgs_m_cnt = 1; else good_cgs_m_init = 1; pcs_sync_next = cggood ? S_PCS_SYNC_ACQUIRED_3A: S_PCS_SYNC_ACQUIRED_4; end S_PCS_SYNC_ACQUIRED_4: begin rx_even_m_toggle = 1; if (cggood) good_cgs_m_cnt = 1; else good_cgs_m_init = 1; pcs_sync_next = cggood ? S_PCS_SYNC_ACQUIRED_4A: S_PCS_SYNC_LOSS_OF_SYNC; end S_PCS_SYNC_ACQUIRED_2A: begin rx_even_m_toggle = 1; good_cgs_m_inc = 1; pcs_sync_next = (cgbad) ? S_PCS_SYNC_ACQUIRED_3 : (good_cgs_done) ? S_PCS_SYNC_ACQUIRED_1 : S_PCS_SYNC_ACQUIRED_2A; end S_PCS_SYNC_ACQUIRED_3A: begin rx_even_m_toggle = 1; good_cgs_m_inc = 1; pcs_sync_next = (cgbad) ? S_PCS_SYNC_ACQUIRED_4 : (good_cgs_done) ? S_PCS_SYNC_ACQUIRED_2 : S_PCS_SYNC_ACQUIRED_3A; end S_PCS_SYNC_ACQUIRED_4A: begin rx_even_m_toggle = 1; good_cgs_m_inc = 1; pcs_sync_next = (cgbad) ? S_PCS_SYNC_LOSS_OF_SYNC : (good_cgs_done) ? S_PCS_SYNC_ACQUIRED_3 : S_PCS_SYNC_ACQUIRED_4A; end endcase if (~signal_detect) pcs_sync_next = S_PCS_SYNC_LOSS_OF_SYNC; end endmodule"
    },
    {
        "file_name": "eth_cop.v",
        "verilog_design": "module eth_cop ( wb_clk_i, wb_rst_i, m1_wb_adr_i, m1_wb_sel_i, m1_wb_we_i, m1_wb_dat_o, m1_wb_dat_i, m1_wb_cyc_i, m1_wb_stb_i, m1_wb_ack_o, m1_wb_err_o, m2_wb_adr_i, m2_wb_sel_i, m2_wb_we_i, m2_wb_dat_o, m2_wb_dat_i, m2_wb_cyc_i, m2_wb_stb_i, m2_wb_ack_o, m2_wb_err_o, s1_wb_adr_o, s1_wb_sel_o, s1_wb_we_o, s1_wb_cyc_o, s1_wb_stb_o, s1_wb_ack_i, s1_wb_err_i, s1_wb_dat_i, s1_wb_dat_o, s2_wb_adr_o, s2_wb_sel_o, s2_wb_we_o, s2_wb_cyc_o, s2_wb_stb_o, s2_wb_ack_i, s2_wb_err_i, s2_wb_dat_i, s2_wb_dat_o ); parameter ETH_BASE = 32'hd0000000; parameter ETH_WIDTH = 32'h800; parameter MEMORY_BASE = 32'h2000; parameter MEMORY_WIDTH = 32'h10000; input wb_clk_i, wb_rst_i; input [31:0] m1_wb_adr_i, m1_wb_dat_i; input [3:0] m1_wb_sel_i; input m1_wb_cyc_i, m1_wb_stb_i, m1_wb_we_i; output [31:0] m1_wb_dat_o; output m1_wb_ack_o, m1_wb_err_o; input [31:0] m2_wb_adr_i, m2_wb_dat_i; input [3:0] m2_wb_sel_i; input m2_wb_cyc_i, m2_wb_stb_i, m2_wb_we_i; output [31:0] m2_wb_dat_o; output m2_wb_ack_o, m2_wb_err_o; input [31:0] s1_wb_dat_i; input s1_wb_ack_i, s1_wb_err_i; output [31:0] s1_wb_adr_o, s1_wb_dat_o; output [3:0] s1_wb_sel_o; output s1_wb_we_o, s1_wb_cyc_o, s1_wb_stb_o; input [31:0] s2_wb_dat_i; input s2_wb_ack_i, s2_wb_err_i; output [31:0] s2_wb_adr_o, s2_wb_dat_o; output [3:0] s2_wb_sel_o; output s2_wb_we_o, s2_wb_cyc_o, s2_wb_stb_o; reg m1_in_progress; reg m2_in_progress; reg [31:0] s1_wb_adr_o; reg [3:0] s1_wb_sel_o; reg s1_wb_we_o; reg [31:0] s1_wb_dat_o; reg s1_wb_cyc_o; reg s1_wb_stb_o; reg [31:0] s2_wb_adr_o; reg [3:0] s2_wb_sel_o; reg s2_wb_we_o; reg [31:0] s2_wb_dat_o; reg s2_wb_cyc_o; reg s2_wb_stb_o; reg m1_wb_ack_o; reg [31:0] m1_wb_dat_o; reg m2_wb_ack_o; reg [31:0] m2_wb_dat_o; reg m1_wb_err_o; reg m2_wb_err_o; wire m_wb_access_finished; wire m1_addressed_s1 = (m1_wb_adr_i >= ETH_BASE) & (m1_wb_adr_i < (ETH_BASE + ETH_WIDTH)); wire m1_addressed_s2 = (m1_wb_adr_i >= MEMORY_BASE) & (m1_wb_adr_i < (MEMORY_BASE + MEMORY_WIDTH)); wire m2_addressed_s1 = (m2_wb_adr_i >= ETH_BASE) & (m2_wb_adr_i < (ETH_BASE + ETH_WIDTH)); wire m2_addressed_s2 = (m2_wb_adr_i >= MEMORY_BASE) & (m2_wb_adr_i < (MEMORY_BASE + MEMORY_WIDTH)); wire m1_req = m1_wb_cyc_i & m1_wb_stb_i & (m1_addressed_s1 | m1_addressed_s2); wire m2_req = m2_wb_cyc_i & m2_wb_stb_i & (m2_addressed_s1 | m2_addressed_s2); always @ (posedge wb_clk_i or posedge wb_rst_i) begin if(wb_rst_i) begin m1_in_progress <= 0; m2_in_progress <= 0; s1_wb_adr_o <= 0; s1_wb_sel_o <= 0; s1_wb_we_o <= 0; s1_wb_dat_o <= 0; s1_wb_cyc_o <= 0; s1_wb_stb_o <= 0; s2_wb_adr_o <= 0; s2_wb_sel_o <= 0; s2_wb_we_o <= 0; s2_wb_dat_o <= 0; s2_wb_cyc_o <= 0; s2_wb_stb_o <= 0; end else begin case({m1_in_progress, m2_in_progress, m1_req, m2_req, m_wb_access_finished}) 5'b00_10_0, 5'b00_11_0 : begin m1_in_progress <= 1'b1; if(m1_addressed_s1) begin s1_wb_adr_o <= m1_wb_adr_i; s1_wb_sel_o <= m1_wb_sel_i; s1_wb_we_o <= m1_wb_we_i; s1_wb_dat_o <= m1_wb_dat_i; s1_wb_cyc_o <= 1'b1; s1_wb_stb_o <= 1'b1; end else if(m1_addressed_s2) begin s2_wb_adr_o <= m1_wb_adr_i; s2_wb_sel_o <= m1_wb_sel_i; s2_wb_we_o <= m1_wb_we_i; s2_wb_dat_o <= m1_wb_dat_i; s2_wb_cyc_o <= 1'b1; s2_wb_stb_o <= 1'b1; end else $display(\"(%t)(%m)WISHBONE ERROR: Unspecified address space accessed\", $time); end 5'b00_01_0 : begin m2_in_progress <= 1'b1; if(m2_addressed_s1) begin s1_wb_adr_o <= m2_wb_adr_i; s1_wb_sel_o <= m2_wb_sel_i; s1_wb_we_o <= m2_wb_we_i; s1_wb_dat_o <= m2_wb_dat_i; s1_wb_cyc_o <= 1'b1; s1_wb_stb_o <= 1'b1; end else if(m2_addressed_s2) begin s2_wb_adr_o <= m2_wb_adr_i; s2_wb_sel_o <= m2_wb_sel_i; s2_wb_we_o <= m2_wb_we_i; s2_wb_dat_o <= m2_wb_dat_i; s2_wb_cyc_o <= 1'b1; s2_wb_stb_o <= 1'b1; end else $display(\"(%t)(%m)WISHBONE ERROR: Unspecified address space accessed\", $time); end 5'b10_10_1, 5'b10_11_1 : begin m1_in_progress <= 1'b0; if(m1_addressed_s1) begin s1_wb_cyc_o <= 1'b0; s1_wb_stb_o <= 1'b0; end else if(m1_addressed_s2) begin s2_wb_cyc_o <= 1'b0; s2_wb_stb_o <= 1'b0; end end 5'b01_01_1, 5'b01_11_1 : begin m2_in_progress <= 1'b0; if(m2_addressed_s1) begin s1_wb_cyc_o <= 1'b0; s1_wb_stb_o <= 1'b0; end else if(m2_addressed_s2) begin s2_wb_cyc_o <= 1'b0; s2_wb_stb_o <= 1'b0; end end endcase end end always @ (m1_in_progress or m1_wb_adr_i or s1_wb_ack_i or s2_wb_ack_i or s1_wb_dat_i or s2_wb_dat_i or m1_addressed_s1 or m1_addressed_s2) begin if(m1_in_progress) begin if(m1_addressed_s1) begin m1_wb_ack_o <= s1_wb_ack_i; m1_wb_dat_o <= s1_wb_dat_i; end else if(m1_addressed_s2) begin m1_wb_ack_o <= s2_wb_ack_i; m1_wb_dat_o <= s2_wb_dat_i; end end else m1_wb_ack_o <= 0; end always @ (m2_in_progress or m2_wb_adr_i or s1_wb_ack_i or s2_wb_ack_i or s1_wb_dat_i or s2_wb_dat_i or m2_addressed_s1 or m2_addressed_s2) begin if(m2_in_progress) begin if(m2_addressed_s1) begin m2_wb_ack_o <= s1_wb_ack_i; m2_wb_dat_o <= s1_wb_dat_i; end else if(m2_addressed_s2) begin m2_wb_ack_o <= s2_wb_ack_i; m2_wb_dat_o <= s2_wb_dat_i; end end else m2_wb_ack_o <= 0; end always @ (m1_in_progress or m1_wb_adr_i or s1_wb_err_i or s2_wb_err_i or m2_addressed_s1 or m2_addressed_s2 or m1_wb_cyc_i or m1_wb_stb_i) begin if(m1_in_progress) begin if(m1_addressed_s1) m1_wb_err_o <= s1_wb_err_i; else if(m1_addressed_s2) m1_wb_err_o <= s2_wb_err_i; end else if(m1_wb_cyc_i & m1_wb_stb_i & ~m1_addressed_s1 & ~m1_addressed_s2) m1_wb_err_o <= 1'b1; else m1_wb_err_o <= 1'b0; end always @ (m2_in_progress or m2_wb_adr_i or s1_wb_err_i or s2_wb_err_i or m2_addressed_s1 or m2_addressed_s2 or m2_wb_cyc_i or m2_wb_stb_i) begin if(m2_in_progress) begin if(m2_addressed_s1) m2_wb_err_o <= s1_wb_err_i; else if(m2_addressed_s2) m2_wb_err_o <= s2_wb_err_i; end else if(m2_wb_cyc_i & m2_wb_stb_i & ~m2_addressed_s1 & ~m2_addressed_s2) m2_wb_err_o <= 1'b1; else m2_wb_err_o <= 1'b0; end assign m_wb_access_finished = m1_wb_ack_o | m1_wb_err_o | m2_wb_ack_o | m2_wb_err_o; integer cnt; always @ (posedge wb_clk_i or posedge wb_rst_i) begin if(wb_rst_i) cnt <= 0; else if(s1_wb_ack_i | s1_wb_err_i | s2_wb_ack_i | s2_wb_err_i) cnt <= 0; else if(s1_wb_cyc_o | s2_wb_cyc_o) cnt <= cnt+1; end always @ (posedge wb_clk_i) begin if(cnt==1000) begin $display(\"(%0t)(%m) ERROR: WB activity ??? \", $time); if(s1_wb_cyc_o) begin $display(\"s1_wb_dat_o = 0x%0x\", s1_wb_dat_o); $display(\"s1_wb_adr_o = 0x%0x\", s1_wb_adr_o); $display(\"s1_wb_sel_o = 0x%0x\", s1_wb_sel_o); $display(\"s1_wb_we_o = 0x%0x\", s1_wb_we_o); end else if(s2_wb_cyc_o) begin $display(\"s2_wb_dat_o = 0x%0x\", s2_wb_dat_o); $display(\"s2_wb_adr_o = 0x%0x\", s2_wb_adr_o); $display(\"s2_wb_sel_o = 0x%0x\", s2_wb_sel_o); $display(\"s2_wb_we_o = 0x%0x\", s2_wb_we_o); end $stop; end end always @ (posedge wb_clk_i) begin if(s1_wb_err_i & s1_wb_cyc_o) begin $display(\"(%0t) ERROR: WB cycle finished with error acknowledge \", $time); $display(\"s1_wb_dat_o = 0x%0x\", s1_wb_dat_o); $display(\"s1_wb_adr_o = 0x%0x\", s1_wb_adr_o); $display(\"s1_wb_sel_o = 0x%0x\", s1_wb_sel_o); $display(\"s1_wb_we_o = 0x%0x\", s1_wb_we_o); $stop; end if(s2_wb_err_i & s2_wb_cyc_o) begin $display(\"(%0t) ERROR: WB cycle finished with error acknowledge \", $time); $display(\"s2_wb_dat_o = 0x%0x\", s2_wb_dat_o); $display(\"s2_wb_adr_o = 0x%0x\", s2_wb_adr_o); $display(\"s2_wb_sel_o = 0x%0x\", s2_wb_sel_o); $display(\"s2_wb_we_o = 0x%0x\", s2_wb_we_o); $stop; end end endmodule"
    },
    {
        "file_name": "eth_crc.v",
        "verilog_design": "module eth_crc (Clk, Reset, Data, Enable, Initialize, Crc, CrcError); input Clk; input Reset; input [3:0] Data; input Enable; input Initialize; output [31:0] Crc; output CrcError; reg [31:0] Crc; wire [31:0] CrcNext; assign CrcNext[0] = Enable & (Data[0] ^ Crc[28]); assign CrcNext[1] = Enable & (Data[1] ^ Data[0] ^ Crc[28] ^ Crc[29]); assign CrcNext[2] = Enable & (Data[2] ^ Data[1] ^ Data[0] ^ Crc[28] ^ Crc[29] ^ Crc[30]); assign CrcNext[3] = Enable & (Data[3] ^ Data[2] ^ Data[1] ^ Crc[29] ^ Crc[30] ^ Crc[31]); assign CrcNext[4] = (Enable & (Data[3] ^ Data[2] ^ Data[0] ^ Crc[28] ^ Crc[30] ^ Crc[31])) ^ Crc[0]; assign CrcNext[5] = (Enable & (Data[3] ^ Data[1] ^ Data[0] ^ Crc[28] ^ Crc[29] ^ Crc[31])) ^ Crc[1]; assign CrcNext[6] = (Enable & (Data[2] ^ Data[1] ^ Crc[29] ^ Crc[30])) ^ Crc[ 2]; assign CrcNext[7] = (Enable & (Data[3] ^ Data[2] ^ Data[0] ^ Crc[28] ^ Crc[30] ^ Crc[31])) ^ Crc[3]; assign CrcNext[8] = (Enable & (Data[3] ^ Data[1] ^ Data[0] ^ Crc[28] ^ Crc[29] ^ Crc[31])) ^ Crc[4]; assign CrcNext[9] = (Enable & (Data[2] ^ Data[1] ^ Crc[29] ^ Crc[30])) ^ Crc[5]; assign CrcNext[10] = (Enable & (Data[3] ^ Data[2] ^ Data[0] ^ Crc[28] ^ Crc[30] ^ Crc[31])) ^ Crc[6]; assign CrcNext[11] = (Enable & (Data[3] ^ Data[1] ^ Data[0] ^ Crc[28] ^ Crc[29] ^ Crc[31])) ^ Crc[7]; assign CrcNext[12] = (Enable & (Data[2] ^ Data[1] ^ Data[0] ^ Crc[28] ^ Crc[29] ^ Crc[30])) ^ Crc[8]; assign CrcNext[13] = (Enable & (Data[3] ^ Data[2] ^ Data[1] ^ Crc[29] ^ Crc[30] ^ Crc[31])) ^ Crc[9]; assign CrcNext[14] = (Enable & (Data[3] ^ Data[2] ^ Crc[30] ^ Crc[31])) ^ Crc[10]; assign CrcNext[15] = (Enable & (Data[3] ^ Crc[31])) ^ Crc[11]; assign CrcNext[16] = (Enable & (Data[0] ^ Crc[28])) ^ Crc[12]; assign CrcNext[17] = (Enable & (Data[1] ^ Crc[29])) ^ Crc[13]; assign CrcNext[18] = (Enable & (Data[2] ^ Crc[30])) ^ Crc[14]; assign CrcNext[19] = (Enable & (Data[3] ^ Crc[31])) ^ Crc[15]; assign CrcNext[20] = Crc[16]; assign CrcNext[21] = Crc[17]; assign CrcNext[22] = (Enable & (Data[0] ^ Crc[28])) ^ Crc[18]; assign CrcNext[23] = (Enable & (Data[1] ^ Data[0] ^ Crc[29] ^ Crc[28])) ^ Crc[19]; assign CrcNext[24] = (Enable & (Data[2] ^ Data[1] ^ Crc[30] ^ Crc[29])) ^ Crc[20]; assign CrcNext[25] = (Enable & (Data[3] ^ Data[2] ^ Crc[31] ^ Crc[30])) ^ Crc[21]; assign CrcNext[26] = (Enable & (Data[3] ^ Data[0] ^ Crc[31] ^ Crc[28])) ^ Crc[22]; assign CrcNext[27] = (Enable & (Data[1] ^ Crc[29])) ^ Crc[23]; assign CrcNext[28] = (Enable & (Data[2] ^ Crc[30])) ^ Crc[24]; assign CrcNext[29] = (Enable & (Data[3] ^ Crc[31])) ^ Crc[25]; assign CrcNext[30] = Crc[26]; assign CrcNext[31] = Crc[27]; always @ (posedge Clk or posedge Reset) begin if (Reset) Crc <= 32'hffffffff; else if(Initialize) Crc <= 32'hffffffff; else Crc <= CrcNext; end assign CrcError = Crc[31:0] != 32'hc704dd7b; endmodule"
    },
    {
        "file_name": "eth_l3_checksum.v",
        "verilog_design": "module eth_l3_checksum ( MRxClk ,Reset, RxData , ByteCnt, CheckSum ,CSready ); input MRxClk; input Reset; input [7:0] RxData; input [15:0] ByteCnt; output [15:0] CheckSum; output CSready; reg [15:0] CheckSum; reg [31:0] Sum; reg CSready; reg [1:0] StartCalc; reg Divided_2_clk ; reg Divided_4_clk ; reg [7:0] prev_latched_Rx; reg [7:0] prev_latched_Rx1; initial Divided_2_clk=0; initial Divided_4_clk=0; always @ (posedge MRxClk) begin Divided_2_clk <= MRxClk^Divided_2_clk; if (ByteCnt[15:0] >= 16'h17 & ByteCnt[15:0] < (16'h17+16'd20)) begin prev_latched_Rx[7:0] <= RxData[7:0]; prev_latched_Rx1[7:0] <= prev_latched_Rx[7:0]; end end always @ (posedge Divided_2_clk) Divided_4_clk <= Divided_4_clk ^ Divided_2_clk; always @ (posedge Divided_2_clk or posedge Reset ) begin if (Reset) begin CheckSum[15:0] <= 16'd0; CSready <= 1'd0; end else if (ByteCnt[15:0]==16'h15) StartCalc[0] <= (RxData[7:0] == 8'h8); else if (ByteCnt[15:0]==16'h16) begin StartCalc[0] <= (RxData[7:0] == 8'h0) & StartCalc[0] ; CheckSum[15:0] <= 16'h0; Sum[31:0] <= 32'h0; CSready <= 1'b0; end else if (ByteCnt[15:0] >= 16'h17 & ByteCnt[15:0] < (16'h17+16'd20)) begin StartCalc[1]<= (ByteCnt[15:0] > 16'h17) & StartCalc[0] ; end else StartCalc[1:0] <= 2'h0; if (ByteCnt[15:0]-16'h17== 16'd20) begin CSready <= 1'b1; CheckSum[15:0] <= ~(Sum[15:0]+Sum[31:16]); end end always @ (negedge Divided_4_clk) begin if (&StartCalc) Sum[31:0]<= Sum[31:0] + {prev_latched_Rx1[7:0] , RxData[7:0]}; end endmodule"
    },
    {
        "file_name": "eth_random.v",
        "verilog_design": "module eth_random (MTxClk, Reset, StateJam, StateJam_q, RetryCnt, NibCnt, ByteCnt, RandomEq0, RandomEqByteCnt); input MTxClk; input Reset; input StateJam; input StateJam_q; input [3:0] RetryCnt; input [15:0] NibCnt; input [9:0] ByteCnt; output RandomEq0; output RandomEqByteCnt; wire Feedback; reg [9:0] x; wire [9:0] Random; reg [9:0] RandomLatched; always @ (posedge MTxClk or posedge Reset) begin if(Reset) x[9:0] <= 0; else x[9:0] <= {x[8:0], Feedback}; end assign Feedback = ~(x[2] ^ x[9]); assign Random [0] = x[0]; assign Random [1] = (RetryCnt > 1) ? x[1] : 1'b0; assign Random [2] = (RetryCnt > 2) ? x[2] : 1'b0; assign Random [3] = (RetryCnt > 3) ? x[3] : 1'b0; assign Random [4] = (RetryCnt > 4) ? x[4] : 1'b0; assign Random [5] = (RetryCnt > 5) ? x[5] : 1'b0; assign Random [6] = (RetryCnt > 6) ? x[6] : 1'b0; assign Random [7] = (RetryCnt > 7) ? x[7] : 1'b0; assign Random [8] = (RetryCnt > 8) ? x[8] : 1'b0; assign Random [9] = (RetryCnt > 9) ? x[9] : 1'b0; always @ (posedge MTxClk or posedge Reset) begin if(Reset) RandomLatched <= 10'h000; else begin if(StateJam & StateJam_q) RandomLatched <= Random; end end assign RandomEq0 = RandomLatched == 10'h0; assign RandomEqByteCnt = ByteCnt[9:0] == RandomLatched & (&NibCnt[6:0]); endmodule"
    },
    {
        "file_name": "eth_receivecontrol.v",
        "verilog_design": "module eth_receivecontrol (MTxClk, MRxClk, TxReset, RxReset, RxData, RxValid, RxStartFrm, RxEndFrm, RxFlow, ReceiveEnd, MAC, DlyCrcEn, TxDoneIn, TxAbortIn, TxStartFrmOut, ReceivedLengthOK, ReceivedPacketGood, TxUsedDataOutDetected, Pause, ReceivedPauseFrm, AddressOK, RxStatusWriteLatched_sync2, r_PassAll, SetPauseTimer ); input MTxClk; input MRxClk; input TxReset; input RxReset; input [7:0] RxData; input RxValid; input RxStartFrm; input RxEndFrm; input RxFlow; input ReceiveEnd; input [47:0]MAC; input DlyCrcEn; input TxDoneIn; input TxAbortIn; input TxStartFrmOut; input ReceivedLengthOK; input ReceivedPacketGood; input TxUsedDataOutDetected; input RxStatusWriteLatched_sync2; input r_PassAll; output Pause; output ReceivedPauseFrm; output AddressOK; output SetPauseTimer; reg Pause; reg AddressOK; reg TypeLengthOK; reg DetectionWindow; reg OpCodeOK; reg [2:0] DlyCrcCnt; reg [4:0] ByteCnt; reg [15:0] AssembledTimerValue; reg [15:0] LatchedTimerValue; reg ReceivedPauseFrm; reg ReceivedPauseFrmWAddr; reg PauseTimerEq0_sync1; reg PauseTimerEq0_sync2; reg [15:0] PauseTimer; reg Divider2; reg [5:0] SlotTimer; wire [47:0] ReservedMulticast; wire [15:0] TypeLength; wire ResetByteCnt; wire IncrementByteCnt; wire ByteCntEq0; wire ByteCntEq1; wire ByteCntEq2; wire ByteCntEq3; wire ByteCntEq4; wire ByteCntEq5; wire ByteCntEq12; wire ByteCntEq13; wire ByteCntEq14; wire ByteCntEq15; wire ByteCntEq16; wire ByteCntEq17; wire ByteCntEq18; wire DecrementPauseTimer; wire PauseTimerEq0; wire ResetSlotTimer; wire IncrementSlotTimer; wire SlotFinished; assign ReservedMulticast = 48'h0180C2000001; assign TypeLength = 16'h8808; always @ (posedge MRxClk or posedge RxReset) begin if(RxReset) AddressOK <= 1'b0; else if(DetectionWindow & ByteCntEq0) AddressOK <= RxData[7:0] == ReservedMulticast[47:40] | RxData[7:0] == MAC[47:40]; else if(DetectionWindow & ByteCntEq1) AddressOK <= (RxData[7:0] == ReservedMulticast[39:32] | RxData[7:0] == MAC[39:32]) & AddressOK; else if(DetectionWindow & ByteCntEq2) AddressOK <= (RxData[7:0] == ReservedMulticast[31:24] | RxData[7:0] == MAC[31:24]) & AddressOK; else if(DetectionWindow & ByteCntEq3) AddressOK <= (RxData[7:0] == ReservedMulticast[23:16] | RxData[7:0] == MAC[23:16]) & AddressOK; else if(DetectionWindow & ByteCntEq4) AddressOK <= (RxData[7:0] == ReservedMulticast[15:8] | RxData[7:0] == MAC[15:8]) & AddressOK; else if(DetectionWindow & ByteCntEq5) AddressOK <= (RxData[7:0] == ReservedMulticast[7:0] | RxData[7:0] == MAC[7:0]) & AddressOK; else if(ReceiveEnd) AddressOK <= 1'b0; end always @ (posedge MRxClk or posedge RxReset ) begin if(RxReset) TypeLengthOK <= 1'b0; else if(DetectionWindow & ByteCntEq12) TypeLengthOK <= ByteCntEq12 & (RxData[7:0] == TypeLength[15:8]); else if(DetectionWindow & ByteCntEq13) TypeLengthOK <= ByteCntEq13 & (RxData[7:0] == TypeLength[7:0]) & TypeLengthOK; else if(ReceiveEnd) TypeLengthOK <= 1'b0; end always @ (posedge MRxClk or posedge RxReset ) begin if(RxReset) OpCodeOK <= 1'b0; else if(ByteCntEq16) OpCodeOK <= 1'b0; else begin if(DetectionWindow & ByteCntEq14) OpCodeOK <= ByteCntEq14 & RxData[7:0] == 8'h00; if(DetectionWindow & ByteCntEq15) OpCodeOK <= ByteCntEq15 & RxData[7:0] == 8'h01 & OpCodeOK; end end always @ (posedge MRxClk or posedge RxReset ) begin if(RxReset) ReceivedPauseFrmWAddr <= 1'b0; else if(ReceiveEnd) ReceivedPauseFrmWAddr <= 1'b0; else if(ByteCntEq16 & TypeLengthOK & OpCodeOK & AddressOK) ReceivedPauseFrmWAddr <= 1'b1; end always @ (posedge MRxClk or posedge RxReset ) begin if(RxReset) AssembledTimerValue[15:0] <= 16'h0; else if(RxStartFrm) AssembledTimerValue[15:0] <= 16'h0; else begin if(DetectionWindow & ByteCntEq16) AssembledTimerValue[15:8] <= RxData[7:0]; if(DetectionWindow & ByteCntEq17) AssembledTimerValue[7:0] <= RxData[7:0]; end end always @ (posedge MRxClk or posedge RxReset ) begin if(RxReset) DetectionWindow <= 1'b1; else if(ByteCntEq18) DetectionWindow <= 1'b0; else if(ReceiveEnd) DetectionWindow <= 1'b1; end always @ (posedge MRxClk or posedge RxReset ) begin if(RxReset) LatchedTimerValue[15:0] <= 16'h0; else if(DetectionWindow & ReceivedPauseFrmWAddr & ByteCntEq18) LatchedTimerValue[15:0] <= AssembledTimerValue[15:0]; else if(ReceiveEnd) LatchedTimerValue[15:0] <= 16'h0; end always @ (posedge MRxClk or posedge RxReset) begin if(RxReset) DlyCrcCnt <= 3'h0; else if(RxValid & RxEndFrm) DlyCrcCnt <= 3'h0; else if(RxValid & ~RxEndFrm & ~DlyCrcCnt[2]) DlyCrcCnt <= DlyCrcCnt + 3'd1; end assign ResetByteCnt = RxEndFrm; assign IncrementByteCnt = RxValid & DetectionWindow & ~ByteCntEq18 & (~DlyCrcEn | DlyCrcEn & DlyCrcCnt[2]); always @ (posedge MRxClk or posedge RxReset) begin if(RxReset) ByteCnt[4:0] <= 5'h0; else if(ResetByteCnt) ByteCnt[4:0] <= 5'h0; else if(IncrementByteCnt) ByteCnt[4:0] <= ByteCnt[4:0] + 5'd1; end assign ByteCntEq0 = RxValid & ByteCnt[4:0] == 5'h0; assign ByteCntEq1 = RxValid & ByteCnt[4:0] == 5'h1; assign ByteCntEq2 = RxValid & ByteCnt[4:0] == 5'h2; assign ByteCntEq3 = RxValid & ByteCnt[4:0] == 5'h3; assign ByteCntEq4 = RxValid & ByteCnt[4:0] == 5'h4; assign ByteCntEq5 = RxValid & ByteCnt[4:0] == 5'h5; assign ByteCntEq12 = RxValid & ByteCnt[4:0] == 5'h0C; assign ByteCntEq13 = RxValid & ByteCnt[4:0] == 5'h0D; assign ByteCntEq14 = RxValid & ByteCnt[4:0] == 5'h0E; assign ByteCntEq15 = RxValid & ByteCnt[4:0] == 5'h0F; assign ByteCntEq16 = RxValid & ByteCnt[4:0] == 5'h10; assign ByteCntEq17 = RxValid & ByteCnt[4:0] == 5'h11; assign ByteCntEq18 = RxValid & ByteCnt[4:0] == 5'h12 & DetectionWindow; assign SetPauseTimer = ReceiveEnd & ReceivedPauseFrmWAddr & ReceivedPacketGood & ReceivedLengthOK & RxFlow; assign DecrementPauseTimer = SlotFinished & |PauseTimer; always @ (posedge MRxClk or posedge RxReset) begin if(RxReset) PauseTimer[15:0] <= 16'h0; else if(SetPauseTimer) PauseTimer[15:0] <= LatchedTimerValue[15:0]; else if(DecrementPauseTimer) PauseTimer[15:0] <= PauseTimer[15:0] - 16'd1; end assign PauseTimerEq0 = ~(|PauseTimer[15:0]); always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) begin PauseTimerEq0_sync1 <= 1'b1; PauseTimerEq0_sync2 <= 1'b1; end else begin PauseTimerEq0_sync1 <= PauseTimerEq0; PauseTimerEq0_sync2 <= PauseTimerEq0_sync1; end end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) Pause <= 1'b0; else if((TxDoneIn | TxAbortIn | ~TxUsedDataOutDetected) & ~TxStartFrmOut) Pause <= RxFlow & ~PauseTimerEq0_sync2; end always @ (posedge MRxClk or posedge RxReset) begin if(RxReset) Divider2 <= 1'b0; else if(|PauseTimer[15:0] & RxFlow) Divider2 <= ~Divider2; else Divider2 <= 1'b0; end assign ResetSlotTimer = RxReset; assign IncrementSlotTimer = Pause & RxFlow & Divider2; always @ (posedge MRxClk or posedge RxReset) begin if(RxReset) SlotTimer[5:0] <= 6'h0; else if(ResetSlotTimer) SlotTimer[5:0] <= 6'h0; else if(IncrementSlotTimer) SlotTimer[5:0] <= SlotTimer[5:0] + 6'd1; end assign SlotFinished = &SlotTimer[5:0] & IncrementSlotTimer; always @ (posedge MRxClk or posedge RxReset) begin if(RxReset) ReceivedPauseFrm <= 1'b0; else if(RxStatusWriteLatched_sync2 & r_PassAll | ReceivedPauseFrm & (~r_PassAll)) ReceivedPauseFrm <= 1'b0; else if(ByteCntEq16 & TypeLengthOK & OpCodeOK) ReceivedPauseFrm <= 1'b1; end endmodule"
    },
    {
        "file_name": "eth_rxaddrcheck.v",
        "verilog_design": "`include \"timescale.v\" module eth_rxaddrcheck(MRxClk, Reset, RxData, Broadcast ,r_Bro ,r_Pro, ByteCntEq2, ByteCntEq3, ByteCntEq4, ByteCntEq5, ByteCntEq6, ByteCntEq7, HASH0, HASH1, ByteCntEq0, CrcHash, CrcHashGood, StateData, RxEndFrm, Multicast, MAC, RxAbort, AddressMiss, PassAll, ControlFrmAddressOK ); input MRxClk; input Reset; input [7:0] RxData; input Broadcast; input r_Bro; input r_Pro; input ByteCntEq0; input ByteCntEq2; input ByteCntEq3; input ByteCntEq4; input ByteCntEq5; input ByteCntEq6; input ByteCntEq7; input [31:0] HASH0; input [31:0] HASH1; input [5:0] CrcHash; input CrcHashGood; input Multicast; input [47:0] MAC; input [1:0] StateData; input RxEndFrm; input PassAll; input ControlFrmAddressOK; output RxAbort; output AddressMiss; wire BroadcastOK; wire ByteCntEq2; wire ByteCntEq3; wire ByteCntEq4; wire ByteCntEq5; wire RxAddressInvalid; wire RxCheckEn; wire HashBit; wire [31:0] IntHash; reg [7:0] ByteHash; reg MulticastOK; reg UnicastOK; reg RxAbort; reg AddressMiss; assign RxAddressInvalid = ~(UnicastOK | BroadcastOK | MulticastOK | r_Pro); assign BroadcastOK = Broadcast & ~r_Bro; assign RxCheckEn = | StateData; always @ (posedge MRxClk or posedge Reset) begin if(Reset) RxAbort <= 1'b0; else if(RxAddressInvalid & ByteCntEq7 & RxCheckEn) RxAbort <= 1'b1; else RxAbort <= 1'b0; end always @ (posedge MRxClk or posedge Reset) begin if(Reset) AddressMiss <= 1'b0; else if(ByteCntEq0) AddressMiss <= 1'b0; else if(ByteCntEq7 & RxCheckEn) AddressMiss <= (~(UnicastOK | BroadcastOK | MulticastOK | (PassAll & ControlFrmAddressOK))); end always @ (posedge MRxClk or posedge Reset) begin if(Reset) MulticastOK <= 1'b0; else if(RxEndFrm | RxAbort) MulticastOK <= 1'b0; else if(CrcHashGood & Multicast) MulticastOK <= HashBit; end always @ (posedge MRxClk or posedge Reset) begin if(Reset) UnicastOK <= 1'b0; else if(RxCheckEn & ByteCntEq2) UnicastOK <= RxData[7:0] == MAC[47:40]; else if(RxCheckEn & ByteCntEq3) UnicastOK <= ( RxData[7:0] == MAC[39:32]) & UnicastOK; else if(RxCheckEn & ByteCntEq4) UnicastOK <= ( RxData[7:0] == MAC[31:24]) & UnicastOK; else if(RxCheckEn & ByteCntEq5) UnicastOK <= ( RxData[7:0] == MAC[23:16]) & UnicastOK; else if(RxCheckEn & ByteCntEq6) UnicastOK <= ( RxData[7:0] == MAC[15:8]) & UnicastOK; else if(RxCheckEn & ByteCntEq7) UnicastOK <= ( RxData[7:0] == MAC[7:0]) & UnicastOK; else if(RxEndFrm | RxAbort) UnicastOK <= 1'b0; end assign IntHash = (CrcHash[5])? HASH1 : HASH0; always@(CrcHash or IntHash) begin case(CrcHash[4:3]) 2'b00: ByteHash = IntHash[7:0]; 2'b01: ByteHash = IntHash[15:8]; 2'b10: ByteHash = IntHash[23:16]; 2'b11: ByteHash = IntHash[31:24]; endcase end assign HashBit = ByteHash[CrcHash[2:0]]; endmodule"
    },
    {
        "file_name": "eth_transmitcontrol.v",
        "verilog_design": "`include \"eth_fifo.v\" `include \"timescale.v\" module eth_transmitcontrol (MTxClk, TxReset, TxUsedDataIn, TxUsedDataOut, TxDoneIn, TxAbortIn, TxStartFrmIn, TPauseRq, TxUsedDataOutDetected, TxFlow, DlyCrcEn, TxPauseTV, MAC, TxCtrlStartFrm, TxCtrlEndFrm, SendingCtrlFrm, CtrlMux, ControlData, WillSendControlFrame, BlockTxDone ); input MTxClk; input TxReset; input TxUsedDataIn; input TxUsedDataOut; input TxDoneIn; input TxAbortIn; input TxStartFrmIn; input TPauseRq; input TxUsedDataOutDetected; input TxFlow; input DlyCrcEn; input [15:0] TxPauseTV; input [47:0] MAC; output TxCtrlStartFrm; output TxCtrlEndFrm; output SendingCtrlFrm; output CtrlMux; output [7:0] ControlData; output WillSendControlFrame; output BlockTxDone; reg SendingCtrlFrm; reg CtrlMux; reg WillSendControlFrame; reg [3:0] DlyCrcCnt; reg [5:0] ByteCnt; reg ControlEnd_q; reg [7:0] MuxedCtrlData; reg TxCtrlStartFrm; reg TxCtrlStartFrm_q; reg TxCtrlEndFrm; reg [7:0] ControlData; reg TxUsedDataIn_q; reg BlockTxDone; wire IncrementDlyCrcCnt; wire ResetByteCnt; wire IncrementByteCnt; wire ControlEnd; wire IncrementByteCntBy2; wire EnableCnt; always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) WillSendControlFrame <= 1'b0; else if(TxCtrlEndFrm & CtrlMux) WillSendControlFrame <= 1'b0; else if(TPauseRq & TxFlow) WillSendControlFrame <= 1'b1; end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) TxCtrlStartFrm <= 1'b0; else if(TxUsedDataIn_q & CtrlMux) TxCtrlStartFrm <= 1'b0; else if(WillSendControlFrame & ~TxUsedDataOut & (TxDoneIn | TxAbortIn | TxStartFrmIn | (~TxUsedDataOutDetected))) TxCtrlStartFrm <= 1'b1; end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) TxCtrlEndFrm <= 1'b0; else if(ControlEnd | ControlEnd_q) TxCtrlEndFrm <= 1'b1; else TxCtrlEndFrm <= 1'b0; end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) CtrlMux <= 1'b0; else if(WillSendControlFrame & ~TxUsedDataOut) CtrlMux <= 1'b1; else if(TxDoneIn) CtrlMux <= 1'b0; end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) SendingCtrlFrm <= 1'b0; else if(WillSendControlFrame & TxCtrlStartFrm) SendingCtrlFrm <= 1'b1; else if(TxDoneIn) SendingCtrlFrm <= 1'b0; end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) TxUsedDataIn_q <= 1'b0; else TxUsedDataIn_q <= TxUsedDataIn; end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) BlockTxDone <= 1'b0; else if(TxCtrlStartFrm) BlockTxDone <= 1'b1; else if(TxStartFrmIn) BlockTxDone <= 1'b0; end always @ (posedge MTxClk) begin ControlEnd_q <= ControlEnd; TxCtrlStartFrm_q <= TxCtrlStartFrm; end assign IncrementDlyCrcCnt = CtrlMux & TxUsedDataIn & ~DlyCrcCnt[2]; always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) DlyCrcCnt <= 4'h0; else if(ResetByteCnt) DlyCrcCnt <= 4'h0; else if(IncrementDlyCrcCnt) DlyCrcCnt <= DlyCrcCnt + 4'd1; end assign ResetByteCnt = TxReset | (~TxCtrlStartFrm & (TxDoneIn | TxAbortIn)); assign IncrementByteCnt = CtrlMux & (TxCtrlStartFrm & ~TxCtrlStartFrm_q & ~TxUsedDataIn | TxUsedDataIn & ~ControlEnd); assign IncrementByteCntBy2 = CtrlMux & TxCtrlStartFrm & (~TxCtrlStartFrm_q) & TxUsedDataIn; assign EnableCnt = (~DlyCrcEn | DlyCrcEn & (&DlyCrcCnt[1:0])); always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) ByteCnt <= 6'h0; else if(ResetByteCnt) ByteCnt <= 6'h0; else if(IncrementByteCntBy2 & EnableCnt) ByteCnt <= (ByteCnt[5:0] ) + 6'd2; else if(IncrementByteCnt & EnableCnt) ByteCnt <= (ByteCnt[5:0] ) + 6'd1; end assign ControlEnd = ByteCnt[5:0] == 6'h22; always @ (ByteCnt or DlyCrcEn or MAC or TxPauseTV or DlyCrcCnt) begin case(ByteCnt) 6'h0: if(~DlyCrcEn | DlyCrcEn & (&DlyCrcCnt[1:0])) MuxedCtrlData[7:0] = 8'h01; else MuxedCtrlData[7:0] = 8'h0; 6'h2: MuxedCtrlData[7:0] = 8'h80; 6'h4: MuxedCtrlData[7:0] = 8'hC2; 6'h6: MuxedCtrlData[7:0] = 8'h00; 6'h8: MuxedCtrlData[7:0] = 8'h00; 6'hA: MuxedCtrlData[7:0] = 8'h01; 6'hC: MuxedCtrlData[7:0] = MAC[47:40]; 6'hE: MuxedCtrlData[7:0] = MAC[39:32]; 6'h10: MuxedCtrlData[7:0] = MAC[31:24]; 6'h12: MuxedCtrlData[7:0] = MAC[23:16]; 6'h14: MuxedCtrlData[7:0] = MAC[15:8]; 6'h16: MuxedCtrlData[7:0] = MAC[7:0]; 6'h18: MuxedCtrlData[7:0] = 8'h88; 6'h1A: MuxedCtrlData[7:0] = 8'h08; 6'h1C: MuxedCtrlData[7:0] = 8'h00; 6'h1E: MuxedCtrlData[7:0] = 8'h01; 6'h20: MuxedCtrlData[7:0] = TxPauseTV[15:8]; 6'h22: MuxedCtrlData[7:0] = TxPauseTV[7:0]; default: MuxedCtrlData[7:0] = 8'h0; endcase end always @ (posedge MTxClk or posedge TxReset) begin if(TxReset) ControlData[7:0] <= 8'h0; else if(~ByteCnt[0]) ControlData[7:0] <= MuxedCtrlData[7:0]; end endmodule module eth_L2_Uc_Wrapper (MTxClk, TxReset, TxDataIn, MAC, DMAC, TxData_wrapped_out, TxAbortIn, TxStartFrmIn, TxEndFrmOut_uc ,TxEndFrmIn ); input MTxClk; input TxReset; input [7:0] TxDataIn; input TxStartFrmIn; input [47:0] MAC ,DMAC; input TxAbortIn; input TxEndFrmIn; output TxEndFrmOut_uc; output [7:0] TxData_wrapped_out; wire [7:0] TxData_wrapped_out_wire; reg [7:0] TxData_wrapped_out; reg [7:0] ByteCnt; reg Divided_2_clk ; reg write_fifo; reg read_fifo; reg clear; reg [8:0] PreNib15State; wire TxBufferFull; wire TxBufferAlmostFull; wire TxBufferAlmostEmpty; wire TxBufferEmpty; wire [4:0] txfifo_cnt; reg StateCount , StateLeftinQ; initial begin StateCount = 1'b0; read_fifo = 1'b0; StateLeftinQ = 1'b0; PreNib15State = 1'b0; Divided_2_clk=0; end assign TxEndFrmOut_uc = TxBufferEmpty & StateLeftinQ; always @(posedge TxStartFrmIn) begin Divided_2_clk=1; end always@ (posedge MTxClk) begin Divided_2_clk <= MTxClk^Divided_2_clk; case ({TxStartFrmIn,TxEndFrmIn}) 2'b10: if (StateCount==0) StateCount<=1; 2'b01: if (StateCount==1) StateCount<=0; endcase case ({TxEndFrmIn,TxBufferEmpty}) 2'b10: if (StateLeftinQ==0) StateLeftinQ<=1; 2'b01: if (StateLeftinQ==1) StateLeftinQ<=0; endcase end always@ (negedge Divided_2_clk) begin if (StateCount | StateLeftinQ | TxStartFrmIn) begin case (ByteCnt) 7'h0: begin TxData_wrapped_out[7:0] <= DMAC[47:40]; read_fifo<=0; end 7'h1: begin TxData_wrapped_out[7:0] <= DMAC[39:32]; read_fifo<=0; end 7'h2: begin TxData_wrapped_out[7:0] <= DMAC[31:24]; read_fifo<=0; end 7'h3: begin TxData_wrapped_out[7:0] <= DMAC[23:16]; read_fifo<=0; end 7'h4: begin TxData_wrapped_out[7:0] <= DMAC[15:8]; read_fifo<=0; end 7'h5: begin TxData_wrapped_out[7:0] <= DMAC[7:0]; read_fifo<=0; end 7'h6: begin TxData_wrapped_out[7:0] <= MAC[47:40]; read_fifo<=0; end 7'h7: begin TxData_wrapped_out[7:0] <= MAC[39:32]; read_fifo<=0; end 7'h8: begin TxData_wrapped_out[7:0] <= MAC[31:24]; read_fifo<=0; end 7'h9: begin TxData_wrapped_out[7:0] <= MAC[23:16]; read_fifo<=0; end 7'ha: begin TxData_wrapped_out[7:0] <= MAC[15:8]; read_fifo<=0; end 7'hb: begin TxData_wrapped_out[7:0] <= MAC[7:0]; read_fifo<=0; end default: begin read_fifo<=1; TxData_wrapped_out<=TxData_wrapped_out_wire; end endcase end else begin ByteCnt <=0; read_fifo<=0; TxData_wrapped_out<=8'h0; PreNib15State <= 9'h0; end if (StateCount) begin PreNib15State <= PreNib15State + 1; end if (StateCount & PreNib15State >= 8) begin ByteCnt = ByteCnt+1; write_fifo <= 1; end else begin write_fifo<=0; end end eth_fifo #( .DATA_WIDTH(8), .DEPTH(32), .CNT_WIDTH(5)) L2_fifo ( .clk (Divided_2_clk), .reset (TxReset), .data_in (TxDataIn), .write (write_fifo), .read (read_fifo), .clear (TxFifoClear), .data_out (TxData_wrapped_out_wire), .full (TxBufferFull), .almost_full (TxBufferAlmostFull), .almost_empty (TxBufferAlmostEmpty), .empty (TxBufferEmpty), .cnt (txfifo_cnt) ); endmodule"
    },
    {
        "file_name": "eth_txcounters.v",
        "verilog_design": "`include \"timescale.v\" module eth_txcounters (StatePreamble, StateIPG, StateData, StatePAD, StateFCS, StateJam, StateBackOff, StateDefer, StateIdle, StartDefer, StartIPG, StartFCS, StartJam, StartBackoff, TxStartFrm, MTxClk, Reset, MinFL, MaxFL, HugEn, ExDfrEn, PacketFinished_q, DlyCrcEn, StateSFD, ByteCnt, NibCnt, ExcessiveDefer, NibCntEq7, NibCntEq15, MaxFrame, NibbleMinFl, DlyCrcCnt ); input MTxClk; input Reset; input StatePreamble; input StateIPG; input [1:0] StateData; input StatePAD; input StateFCS; input StateJam; input StateBackOff; input StateDefer; input StateIdle; input StateSFD; input StartDefer; input StartIPG; input StartFCS; input StartJam; input StartBackoff; input TxStartFrm; input [15:0] MinFL; input [15:0] MaxFL; input HugEn; input ExDfrEn; input PacketFinished_q; input DlyCrcEn; output [15:0] ByteCnt; output [15:0] NibCnt; output ExcessiveDefer; output NibCntEq7; output NibCntEq15; output MaxFrame; output NibbleMinFl; output [2:0] DlyCrcCnt; wire ExcessiveDeferCnt; wire ResetNibCnt; wire IncrementNibCnt; wire ResetByteCnt; wire IncrementByteCnt; wire ByteCntMax; reg [15:0] NibCnt; reg [15:0] ByteCnt; reg [2:0] DlyCrcCnt; assign IncrementNibCnt = StateIPG | StatePreamble | (|StateData) | StatePAD | StateFCS | StateJam | StateBackOff | StateDefer & ~ExcessiveDefer & TxStartFrm; assign ResetNibCnt = StateDefer & ExcessiveDefer & ~TxStartFrm | StatePreamble & NibCntEq15 | StateJam & NibCntEq7 | StateIdle | StartDefer | StartIPG | StartFCS | StartJam; always @ (posedge MTxClk or posedge Reset) begin if(Reset) NibCnt <= 16'h0; else begin if(ResetNibCnt) NibCnt <= 16'h0; else if(IncrementNibCnt) NibCnt <= NibCnt + 16'd1; end end assign NibCntEq7 = &NibCnt[2:0]; assign NibCntEq15 = &NibCnt[3:0]; assign NibbleMinFl = NibCnt >= (((MinFL-16'd4)<<1) -1); assign ExcessiveDeferCnt = NibCnt[13:0] == 14'h17b7; assign ExcessiveDefer = NibCnt[13:0] == 14'h17b7 & ~ExDfrEn; assign IncrementByteCnt = StateData[1] & ~ByteCntMax | StateBackOff & (&NibCnt[6:0]) | (StatePAD | StateFCS) & NibCnt[0] & ~ByteCntMax; assign ResetByteCnt = StartBackoff | StateIdle & TxStartFrm | PacketFinished_q; always @ (posedge MTxClk or posedge Reset) begin if(Reset) ByteCnt[15:0] <= 16'h0; else begin if(ResetByteCnt) ByteCnt[15:0] <= 16'h0; else if(IncrementByteCnt) ByteCnt[15:0] <= ByteCnt[15:0] + 16'd1; end end assign MaxFrame = ByteCnt[15:0] == MaxFL[15:0] & ~HugEn; assign ByteCntMax = &ByteCnt[15:0]; always @ (posedge MTxClk or posedge Reset) begin if(Reset) DlyCrcCnt <= 3'h0; else begin if(StateData[1] & DlyCrcCnt == 3'h4 | StartJam | PacketFinished_q) DlyCrcCnt <= 3'h0; else if(DlyCrcEn & (StateSFD | StateData[1] & (|DlyCrcCnt[2:0]))) DlyCrcCnt <= DlyCrcCnt + 3'd1; end end endmodule"
    },
    {
        "file_name": "eth_clockgen.v",
        "verilog_design": "`timescale 1ns/10ps module eth_clockgen(Clk, Reset, Divider, MdcEn, MdcEn_n, Mdc); parameter Tp=1; input Clk; input Reset; input [7:0] Divider; output Mdc; output MdcEn; output MdcEn_n; reg Mdc; reg [7:0] Counter; wire CountEq0; wire [7:0] CounterPreset; wire [7:0] TempDivider; assign TempDivider[7:0] = (Divider[7:0]<2)? 8'h02 : Divider[7:0]; assign CounterPreset[7:0] = (TempDivider[7:0]>>1) -1; always @ (posedge Clk or posedge Reset) begin if(Reset) Counter[7:0] <= #Tp 8'h1; else begin if(CountEq0) begin Counter[7:0] <= #Tp CounterPreset[7:0]; end else Counter[7:0] <= #Tp Counter - 8'h1; end end always @ (posedge Clk or posedge Reset) begin if(Reset) Mdc <= #Tp 1'b0; else begin if(CountEq0) Mdc <= #Tp ~Mdc; end end assign CountEq0 = Counter == 8'h0; assign MdcEn = CountEq0 & ~Mdc; assign MdcEn_n = CountEq0 & Mdc; endmodule"
    },
    {
        "file_name": "eth_miim.v",
        "verilog_design": "`timescale 1ns/10ps `include \"eth_shiftreg.v\" `include \"eth_clockgen.v\" `include \"eth_outputcontrol.v\" module eth_miim ( Clk, Reset, Divider, NoPre, CtrlData, Rgad, Fiad, WCtrlData, RStat, ScanStat, Mdo, MdoEn, Mdi, Mdc, Busy, Prsd, LinkFail, Nvalid, WCtrlDataStart, RStatStart, UpdateMIIRX_DATAReg ); input Clk; input Reset; input [7:0] Divider; input [15:0] CtrlData; input [4:0] Rgad; input [4:0] Fiad; input NoPre; input WCtrlData; input RStat; input ScanStat; output Mdo; output MdoEn; input Mdi; output Mdc; output Busy; output LinkFail; output Nvalid; output [15:0] Prsd; output WCtrlDataStart; output RStatStart; output UpdateMIIRX_DATAReg; parameter Tp = 1; reg Nvalid; reg EndBusy_d; reg EndBusy; reg WCtrlData_q1; reg WCtrlData_q2; reg WCtrlData_q3; reg WCtrlDataStart; reg WCtrlDataStart_q; reg WCtrlDataStart_q1; reg WCtrlDataStart_q2; reg RStat_q1; reg RStat_q2; reg RStat_q3; reg RStatStart; reg RStatStart_q1; reg RStatStart_q2; reg ScanStat_q1; reg ScanStat_q2; reg SyncStatMdcEn; wire WriteDataOp; wire ReadStatusOp; wire ScanStatusOp; wire StartOp; wire EndOp; reg InProgress; reg InProgress_q1; reg InProgress_q2; reg InProgress_q3; reg WriteOp; reg [6:0] BitCounter; wire MdcFrame; wire [3:0] ByteSelect; wire MdcEn; wire ShiftedBit; wire LatchByte1_d2; wire LatchByte0_d2; reg LatchByte1_d; reg LatchByte0_d; reg [1:0] LatchByte; reg UpdateMIIRX_DATAReg; always @ (posedge Clk or posedge Reset) begin if(Reset) begin EndBusy_d <= #Tp 1'b0; EndBusy <= #Tp 1'b0; end else begin EndBusy_d <= #Tp ~InProgress_q2 & InProgress_q3; EndBusy <= #Tp EndBusy_d; end end always @ (posedge Clk or posedge Reset) begin if(Reset) UpdateMIIRX_DATAReg <= #Tp 0; else if(EndBusy & ~WCtrlDataStart_q) UpdateMIIRX_DATAReg <= #Tp 1; else UpdateMIIRX_DATAReg <= #Tp 0; end always @ (posedge Clk or posedge Reset) begin if(Reset) begin WCtrlData_q1 <= #Tp 1'b0; WCtrlData_q2 <= #Tp 1'b0; WCtrlData_q3 <= #Tp 1'b0; RStat_q1 <= #Tp 1'b0; RStat_q2 <= #Tp 1'b0; RStat_q3 <= #Tp 1'b0; ScanStat_q1 <= #Tp 1'b0; ScanStat_q2 <= #Tp 1'b0; SyncStatMdcEn <= #Tp 1'b0; end else begin WCtrlData_q1 <= #Tp WCtrlData; WCtrlData_q2 <= #Tp WCtrlData_q1; WCtrlData_q3 <= #Tp WCtrlData_q2; RStat_q1 <= #Tp RStat; RStat_q2 <= #Tp RStat_q1; RStat_q3 <= #Tp RStat_q2; ScanStat_q1 <= #Tp ScanStat; ScanStat_q2 <= #Tp ScanStat_q1; if(MdcEn) SyncStatMdcEn <= #Tp ScanStat_q2; end end always @ (posedge Clk or posedge Reset) begin if(Reset) begin WCtrlDataStart <= #Tp 1'b0; WCtrlDataStart_q <= #Tp 1'b0; RStatStart <= #Tp 1'b0; end else begin if(EndBusy) begin WCtrlDataStart <= #Tp 1'b0; RStatStart <= #Tp 1'b0; end else begin if(WCtrlData_q2 & ~WCtrlData_q3) WCtrlDataStart <= #Tp 1'b1; if(RStat_q2 & ~RStat_q3) RStatStart <= #Tp 1'b1; WCtrlDataStart_q <= #Tp WCtrlDataStart; end end end always @ (posedge Clk or posedge Reset) begin if(Reset) Nvalid <= #Tp 1'b0; else begin if(~InProgress_q2 & InProgress_q3) begin Nvalid <= #Tp 1'b0; end else begin if(ScanStat_q2 & ~SyncStatMdcEn) Nvalid <= #Tp 1'b1; end end end always @ (posedge Clk or posedge Reset) begin if(Reset) begin WCtrlDataStart_q1 <= #Tp 1'b0; WCtrlDataStart_q2 <= #Tp 1'b0; RStatStart_q1 <= #Tp 1'b0; RStatStart_q2 <= #Tp 1'b0; InProgress_q1 <= #Tp 1'b0; InProgress_q2 <= #Tp 1'b0; InProgress_q3 <= #Tp 1'b0; LatchByte0_d <= #Tp 1'b0; LatchByte1_d <= #Tp 1'b0; LatchByte <= #Tp 2'b00; end else begin if(MdcEn) begin WCtrlDataStart_q1 <= #Tp WCtrlDataStart; WCtrlDataStart_q2 <= #Tp WCtrlDataStart_q1; RStatStart_q1 <= #Tp RStatStart; RStatStart_q2 <= #Tp RStatStart_q1; LatchByte[0] <= #Tp LatchByte0_d; LatchByte[1] <= #Tp LatchByte1_d; LatchByte0_d <= #Tp LatchByte0_d2; LatchByte1_d <= #Tp LatchByte1_d2; InProgress_q1 <= #Tp InProgress; InProgress_q2 <= #Tp InProgress_q1; InProgress_q3 <= #Tp InProgress_q2; end end end assign WriteDataOp = WCtrlDataStart_q1 & ~WCtrlDataStart_q2; assign ReadStatusOp = RStatStart_q1 & ~RStatStart_q2; assign ScanStatusOp = SyncStatMdcEn & ~InProgress & ~InProgress_q1 & ~InProgress_q2; assign StartOp = WriteDataOp | ReadStatusOp | ScanStatusOp; reg Busy; always @ (posedge Clk or posedge Reset) if (Reset) Busy <=0; else if(WCtrlData | WCtrlDataStart | RStat | RStatStart | SyncStatMdcEn | EndBusy | InProgress | InProgress_q3 | Nvalid) Busy <=1; else Busy <=0; always @ (posedge Clk or posedge Reset) begin if(Reset) begin InProgress <= #Tp 1'b0; WriteOp <= #Tp 1'b0; end else begin if(MdcEn) begin if(StartOp) begin if(~InProgress) WriteOp <= #Tp WriteDataOp; InProgress <= #Tp 1'b1; end else begin if(EndOp) begin InProgress <= #Tp 1'b0; WriteOp <= #Tp 1'b0; end end end end end always @ (posedge Clk or posedge Reset) begin if(Reset) BitCounter[6:0] <= #Tp 7'h0; else begin if(MdcEn) begin if(InProgress) begin if(NoPre & ( BitCounter == 7'h0 )) BitCounter[6:0] <= #Tp 7'h21; else BitCounter[6:0] <= #Tp BitCounter[6:0] + 1'b1; end else BitCounter[6:0] <= #Tp 7'h0; end end end assign EndOp = BitCounter==63; assign ByteSelect[0] = InProgress & ((NoPre & (BitCounter == 7'h0)) | (~NoPre & (BitCounter == 7'h20))); assign ByteSelect[1] = InProgress & (BitCounter == 7'h28); assign ByteSelect[2] = InProgress & WriteOp & (BitCounter == 7'h30); assign ByteSelect[3] = InProgress & WriteOp & (BitCounter == 7'h38); assign LatchByte1_d2 = InProgress & ~WriteOp & BitCounter == 7'h37; assign LatchByte0_d2 = InProgress & ~WriteOp & BitCounter == 7'h3F; eth_clockgen clkgen(.Clk(Clk), .Reset(Reset), .Divider(Divider[7:0]), .MdcEn(MdcEn), .MdcEn_n(MdcEn_n), .Mdc(Mdc) ); eth_shiftreg shftrg(.Clk(Clk), .Reset(Reset), .MdcEn_n(MdcEn_n), .Mdi(Mdi), .Fiad(Fiad), .Rgad(Rgad), .CtrlData(CtrlData), .WriteOp(WriteOp), .ByteSelect(ByteSelect), .LatchByte(LatchByte), .ShiftedBit(ShiftedBit), .Prsd(Prsd), .LinkFail(LinkFail) ); eth_outputcontrol outctrl(.Clk(Clk), .Reset(Reset), .MdcEn_n(MdcEn_n), .InProgress(InProgress), .ShiftedBit(ShiftedBit), .BitCounter(BitCounter), .WriteOp(WriteOp), .NoPre(NoPre), .Mdo(Mdo), .MdoEn(MdoEn) ); endmodule"
    },
    {
        "file_name": "eth_outputcontrol.v",
        "verilog_design": "`timescale 1ns/10ps module eth_outputcontrol(Clk, Reset, InProgress, ShiftedBit, BitCounter, WriteOp, NoPre, MdcEn_n, Mdo, MdoEn); parameter Tp = 1; input Clk; input Reset; input WriteOp; input NoPre; input InProgress; input ShiftedBit; input [6:0] BitCounter; input MdcEn_n; output Mdo; output MdoEn; wire SerialEn; reg MdoEn_2d; reg MdoEn_d; reg MdoEn; reg Mdo_2d; reg Mdo_d; reg Mdo; assign SerialEn = WriteOp & InProgress & ( BitCounter>31 | ( ( BitCounter == 0 ) & NoPre ) ) | ~WriteOp & InProgress & (( BitCounter>31 & BitCounter<46 ) | ( ( BitCounter == 0 ) & NoPre )); always @ (posedge Clk or posedge Reset) begin if(Reset) begin MdoEn_2d <= #Tp 1'b0; MdoEn_d <= #Tp 1'b0; MdoEn <= #Tp 1'b0; end else begin if(MdcEn_n) begin MdoEn_2d <= #Tp SerialEn | InProgress & BitCounter<32; MdoEn_d <= #Tp MdoEn_2d; MdoEn <= #Tp MdoEn_d; end end end always @ (posedge Clk or posedge Reset) begin if(Reset) begin Mdo_2d <= #Tp 1'b0; Mdo_d <= #Tp 1'b0; Mdo <= #Tp 1'b0; end else begin if(MdcEn_n) begin Mdo_2d <= #Tp ~SerialEn & BitCounter<32; Mdo_d <= #Tp ShiftedBit | Mdo_2d; Mdo <= #Tp Mdo_d; end end end endmodule"
    },
    {
        "file_name": "eth_shiftreg.v",
        "verilog_design": "`timescale 1ns/10ps module eth_shiftreg(Clk, Reset, MdcEn_n, Mdi, Fiad, Rgad, CtrlData, WriteOp, ByteSelect, LatchByte, ShiftedBit, Prsd, LinkFail); parameter Tp=1; input Clk; input Reset; input MdcEn_n; input Mdi; input [4:0] Fiad; input [4:0] Rgad; input [15:0]CtrlData; input WriteOp; input [3:0] ByteSelect; input [1:0] LatchByte; output ShiftedBit; output[15:0]Prsd; output LinkFail; reg [7:0] ShiftReg; reg [15:0]Prsd; reg LinkFail; always @ (posedge Clk or posedge Reset) begin if(Reset) begin ShiftReg[7:0] <= #Tp 8'h0; Prsd[15:0] <= #Tp 16'h0; LinkFail <= #Tp 1'b0; end else begin if(MdcEn_n) begin if(|ByteSelect) begin case (ByteSelect[3:0]) 4'h1 : ShiftReg[7:0] <= #Tp {2'b01, ~WriteOp, WriteOp, Fiad[4:1]}; 4'h2 : ShiftReg[7:0] <= #Tp {Fiad[0], Rgad[4:0], 2'b10}; 4'h4 : ShiftReg[7:0] <= #Tp CtrlData[15:8]; 4'h8 : ShiftReg[7:0] <= #Tp CtrlData[7:0]; default : ShiftReg[7:0] <= #Tp 8'h0; endcase end else begin ShiftReg[7:0] <= #Tp {ShiftReg[6:0], Mdi}; if(LatchByte[0]) begin Prsd[7:0] <= #Tp {ShiftReg[6:0], Mdi}; if(Rgad == 5'h01) LinkFail <= #Tp ~ShiftReg[1]; end else begin if(LatchByte[1]) Prsd[15:8] <= #Tp {ShiftReg[6:0], Mdi}; end end end end end assign ShiftedBit = ShiftReg[7]; endmodule"
    },
    {
        "file_name": "flow_ctrl.v",
        "verilog_design": "module flow_ctrl ( Reset , Clk , tx_pause_en , xoff_cpu , xon_cpu , pause_quanta , pause_quanta_val , pause_apply , pause_quanta_sub , xoff_gen , xoff_gen_complete , xon_gen , xon_gen_complete ); input Reset ; input Clk ; input tx_pause_en ; input xoff_cpu ; input xon_cpu ; input [15:0] pause_quanta ; input pause_quanta_val ; output pause_apply ; input pause_quanta_sub ; output xoff_gen ; input xoff_gen_complete ; output xon_gen ; input xon_gen_complete ; reg xoff_cpu_dl1 ; reg xoff_cpu_dl2 ; reg xon_cpu_dl1 ; reg xon_cpu_dl2 ; reg [15:0] pause_quanta_dl1 ; reg pause_quanta_val_dl1 ; reg pause_quanta_val_dl2 ; reg pause_apply ; reg xoff_gen ; reg xon_gen ; reg [15:0] pause_quanta_counter ; reg tx_pause_en_dl1 ; reg tx_pause_en_dl2 ; always @ (posedge Clk or posedge Reset) if (Reset) begin xoff_cpu_dl1 <=0; xoff_cpu_dl2 <=0; end else begin xoff_cpu_dl1 <=xoff_cpu; xoff_cpu_dl2 <=xoff_cpu_dl1; end always @ (posedge Clk or posedge Reset) if (Reset) begin xon_cpu_dl1 <=0; xon_cpu_dl2 <=0; end else begin xon_cpu_dl1 <=xon_cpu; xon_cpu_dl2 <=xon_cpu_dl1; end always @ (posedge Clk or posedge Reset) if (Reset) begin pause_quanta_dl1 <=0; end else begin pause_quanta_dl1 <=pause_quanta; end always @ (posedge Clk or posedge Reset) if (Reset) begin pause_quanta_val_dl1 <=0; pause_quanta_val_dl2 <=0; end else begin pause_quanta_val_dl1 <=pause_quanta_val; pause_quanta_val_dl2 <=pause_quanta_val_dl1; end always @ (posedge Clk or posedge Reset) if (Reset) begin tx_pause_en_dl1 <=0; tx_pause_en_dl2 <=0; end else begin tx_pause_en_dl1 <=tx_pause_en; tx_pause_en_dl2 <=tx_pause_en_dl1; end always @ (posedge Clk or posedge Reset) if (Reset) xoff_gen <=0; else if (xoff_gen_complete) xoff_gen <=0; else if (xoff_cpu_dl1&&!xoff_cpu_dl2) xoff_gen <=1; always @ (posedge Clk or posedge Reset) if (Reset) xon_gen <=0; else if (xon_gen_complete) xon_gen <=0; else if (xon_cpu_dl1&&!xon_cpu_dl2) xon_gen <=1; always @ (posedge Clk or posedge Reset) if (Reset) pause_quanta_counter <=0; else if(pause_quanta_val_dl1&&!pause_quanta_val_dl2) pause_quanta_counter <=pause_quanta_dl1; else if(pause_quanta_sub&&pause_quanta_counter!=0) pause_quanta_counter <=pause_quanta_counter-1; always @ (posedge Clk or posedge Reset) if (Reset) pause_apply <=0; else if(pause_quanta_counter==0) pause_apply <=0; else if (tx_pause_en_dl2) pause_apply <=1; endmodule"
    },
    {
        "file_name": "MAC_rx_ctrl.v",
        "verilog_design": "module MAC_rx_ctrl ( Reset , Clk , MCrs_dv , MRxD , MRxErr , CRC_en , CRC_init , CRC_err , MAC_add_en , MAC_rx_add_chk_err , broadcast_ptr , broadcast_drop , pause_quanta , pause_quanta_val , Fifo_data , Fifo_data_en , Fifo_data_err , Fifo_data_end , Fifo_full , Rx_pkt_type_rmon , Rx_pkt_length_rmon , Rx_apply_rmon , Rx_pkt_err_type_rmon , RX_IFG_SET , RX_MAX_LENGTH, RX_MIN_LENGTH ); input Reset ; input Clk ; input MCrs_dv ; input [7:0] MRxD ; input MRxErr ; output CRC_en ; output CRC_init; input CRC_err ; output MAC_add_en ; input MAC_rx_add_chk_err ; output broadcast_ptr ; input broadcast_drop ; output [15:0] pause_quanta ; output pause_quanta_val ; output [7:0] Fifo_data ; output Fifo_data_en ; output Fifo_data_err ; output Fifo_data_end ; input Fifo_full; output [15:0] Rx_pkt_length_rmon ; output Rx_apply_rmon ; output [2:0] Rx_pkt_err_type_rmon ; output [2:0] Rx_pkt_type_rmon ; input [5:0] RX_IFG_SET ; input [15:0] RX_MAX_LENGTH ; input [6:0] RX_MIN_LENGTH ; parameter State_idle =4'd00; parameter State_preamble =4'd01; parameter State_SFD =4'd02; parameter State_data =4'd03; parameter State_checkCRC =4'd04; parameter State_OkEnd =4'd07; parameter State_drop =4'd08; parameter State_ErrEnd =4'd09; parameter State_CRCErrEnd =4'd10; parameter State_FFFullDrop =4'd11; parameter State_FFFullErrEnd =4'd12; parameter State_IFG =4'd13; parameter Pause_idle =4'd0; parameter Pause_pre_syn =4'd1; parameter Pause_quanta_hi =4'd2; parameter Pause_quanta_lo =4'd3; parameter Pause_syn =4'd4; reg [3:0] Current_state ; reg [3:0] Next_state; reg [3:0] Pause_current ; reg [3:0] Pause_next; reg [5:0] IFG_counter; reg Crs_dv ; reg [7:0] RxD ; reg [7:0] RxD_dl1 ; reg RxErr ; reg [15:0] Frame_length_counter; reg Too_long; reg Too_short; reg Fifo_data_en; reg Fifo_data_end; reg Fifo_data_err; reg CRC_en; reg CRC_init; reg Rx_apply_rmon; reg Rx_apply_rmon_tmp; reg Rx_apply_rmon_tmp_pl1; reg [2:0] Rx_pkt_err_type_rmon; reg MAC_add_en; reg [2:0] Rx_pkt_type_rmon; reg [7:0] pause_quanta_h ; reg [15:0] pause_quanta ; reg pause_quanta_val ; reg pause_quanta_val_tmp; reg pause_frame_ptr ; reg broadcast_ptr ; always @ (posedge Reset or posedge Clk) if (Reset) begin Crs_dv <=0; RxD <=0; RxErr <=0; end else begin Crs_dv <=MCrs_dv ; RxD <=MRxD ; RxErr <=MRxErr ; end always @ (posedge Reset or posedge Clk) if (Reset) RxD_dl1 <=0; else RxD_dl1 <=RxD; always @ (posedge Reset or posedge Clk) if (Reset) Current_state <=State_idle; else Current_state <=Next_state; always @ (*) case (Current_state) State_idle: if (Crs_dv&&RxD==8'h55) Next_state =State_preamble; else Next_state =Current_state; State_preamble: if (!Crs_dv) Next_state =State_ErrEnd; else if (RxErr) Next_state =State_drop; else if (RxD==8'hd5) Next_state =State_SFD; else if (RxD==8'h55) Next_state =Current_state; else Next_state =State_drop; State_SFD: if (!Crs_dv) Next_state =State_ErrEnd; else if (RxErr) Next_state =State_drop; else Next_state =State_data; State_data: if (!Crs_dv&&!Too_short&&!Too_long) Next_state =State_checkCRC; else if (!Crs_dv&&(Too_short||Too_long)) Next_state =State_ErrEnd; else if (Fifo_full) Next_state =State_FFFullErrEnd; else if (RxErr||MAC_rx_add_chk_err||Too_long||broadcast_drop) Next_state =State_drop; else Next_state =State_data; State_checkCRC: if (CRC_err) Next_state =State_CRCErrEnd; else Next_state =State_OkEnd; State_drop: if (!Crs_dv) Next_state =State_ErrEnd; else Next_state =Current_state; State_OkEnd: Next_state =State_IFG; State_ErrEnd: Next_state =State_IFG; State_CRCErrEnd: Next_state =State_IFG; State_FFFullDrop: if (!Crs_dv) Next_state =State_IFG; else Next_state =Current_state; State_FFFullErrEnd: Next_state =State_FFFullDrop; State_IFG: if (IFG_counter==RX_IFG_SET-4) Next_state =State_idle; else Next_state =Current_state; default: Next_state =State_idle; endcase always @ (posedge Reset or posedge Clk) if (Reset) IFG_counter <=0; else if (Current_state!=State_IFG) IFG_counter <=0; else IFG_counter <=IFG_counter + 1; assign Fifo_data =RxD_dl1; always @(Current_state) if (Current_state==State_data) Fifo_data_en =1; else Fifo_data_en =0; always @(Current_state) if (Current_state==State_ErrEnd||Current_state==State_OkEnd ||Current_state==State_CRCErrEnd||Current_state==State_FFFullErrEnd) Fifo_data_end =1; else Fifo_data_end =0; always @(Current_state) if (Current_state==State_ErrEnd||Current_state==State_CRCErrEnd||Current_state==State_FFFullErrEnd) Fifo_data_err =1; else Fifo_data_err =0; always @(Current_state) if (Current_state==State_data) CRC_en =1; else CRC_en =0; always @(Current_state) if (Current_state==State_SFD) CRC_init =1; else CRC_init =0; always @ (posedge Clk or posedge Reset) if (Reset) Frame_length_counter <=0; else if (Current_state==State_SFD) Frame_length_counter <=1; else if (Current_state==State_data) Frame_length_counter <=Frame_length_counter+ 1'b1; always @ (Frame_length_counter or RX_MIN_LENGTH) if (Frame_length_counter<RX_MIN_LENGTH) Too_short =1; else Too_short =0; always @ (*) if (Frame_length_counter>RX_MAX_LENGTH) Too_long =1; else Too_long =0; assign Rx_pkt_length_rmon=Frame_length_counter-1'b1; always @ (posedge Clk or posedge Reset) if (Reset) Rx_apply_rmon_tmp <=0; else if (Current_state==State_OkEnd||Current_state==State_ErrEnd ||Current_state==State_CRCErrEnd||Current_state==State_FFFullErrEnd) Rx_apply_rmon_tmp <=1; else Rx_apply_rmon_tmp <=0; always @ (posedge Clk or posedge Reset) if (Reset) Rx_apply_rmon_tmp_pl1 <=0; else Rx_apply_rmon_tmp_pl1 <=Rx_apply_rmon_tmp; always @ (posedge Clk or posedge Reset) if (Reset) Rx_apply_rmon <=0; else if (Current_state==State_OkEnd||Current_state==State_ErrEnd ||Current_state==State_CRCErrEnd||Current_state==State_FFFullErrEnd) Rx_apply_rmon <=1; else if (Rx_apply_rmon_tmp_pl1) Rx_apply_rmon <=0; always @ (posedge Clk or posedge Reset) if (Reset) Rx_pkt_err_type_rmon <=0; else if (Current_state==State_CRCErrEnd) Rx_pkt_err_type_rmon <=3'b001 ; else if (Current_state==State_FFFullErrEnd) Rx_pkt_err_type_rmon <=3'b010 ; else if (Current_state==State_ErrEnd) Rx_pkt_err_type_rmon <=3'b011 ; else if(Current_state==State_OkEnd) Rx_pkt_err_type_rmon <=3'b100 ; always @ (posedge Clk or posedge Reset) if (Reset) Rx_pkt_type_rmon <=0; else if (Current_state==State_OkEnd&&pause_frame_ptr) Rx_pkt_type_rmon <=3'b100 ; else if(Current_state==State_SFD&&Next_state==State_data) Rx_pkt_type_rmon <={1'b0,MRxD[7:6]}; always @ (posedge Clk or posedge Reset) if (Reset) broadcast_ptr <=0; else if(Current_state==State_IFG) broadcast_ptr <=0; else if(Current_state==State_SFD&&Next_state==State_data&&MRxD[7:6]==2'b11) broadcast_ptr <=1; always @ (Frame_length_counter or Fifo_data_en) if(Frame_length_counter>=1&&Frame_length_counter<=6) MAC_add_en <=Fifo_data_en; else MAC_add_en <=0; always @ (posedge Clk or posedge Reset) if (Reset) Pause_current <=Pause_idle; else Pause_current <=Pause_next; always @ (*) case (Pause_current) Pause_idle : if(Current_state==State_SFD) Pause_next =Pause_pre_syn; else Pause_next =Pause_current; Pause_pre_syn: case (Frame_length_counter) 16'd1: if (RxD_dl1==8'h01) Pause_next =Pause_current; else Pause_next =Pause_idle; 16'd2: if (RxD_dl1==8'h80) Pause_next =Pause_current; else Pause_next =Pause_idle; 16'd3: if (RxD_dl1==8'hc2) Pause_next =Pause_current; else Pause_next =Pause_idle; 16'd4: if (RxD_dl1==8'h00) Pause_next =Pause_current; else Pause_next =Pause_idle; 16'd5: if (RxD_dl1==8'h00) Pause_next =Pause_current; else Pause_next =Pause_idle; 16'd6: if (RxD_dl1==8'h01) Pause_next =Pause_current; else Pause_next =Pause_idle; 16'd13: if (RxD_dl1==8'h88) Pause_next =Pause_current; else Pause_next =Pause_idle; 16'd14: if (RxD_dl1==8'h08) Pause_next =Pause_current; else Pause_next =Pause_idle; 16'd15: if (RxD_dl1==8'h00) Pause_next =Pause_current; else Pause_next =Pause_idle; 16'd16: if (RxD_dl1==8'h01) Pause_next =Pause_quanta_hi; else Pause_next =Pause_idle; default: Pause_next =Pause_current; endcase Pause_quanta_hi : Pause_next =Pause_quanta_lo; Pause_quanta_lo : Pause_next =Pause_syn; Pause_syn : if (Current_state==State_IFG) Pause_next =Pause_idle; else Pause_next =Pause_current; default: Pause_next =Pause_idle; endcase always @ (posedge Clk or posedge Reset) if (Reset) pause_quanta_h <=0; else if(Pause_current==Pause_quanta_hi) pause_quanta_h <=RxD_dl1; always @ (posedge Clk or posedge Reset) if (Reset) pause_quanta <=0; else if(Pause_current==Pause_quanta_lo) pause_quanta <={pause_quanta_h,RxD_dl1}; always @ (posedge Clk or posedge Reset) if (Reset) pause_quanta_val_tmp <=0; else if(Current_state==State_OkEnd&&Pause_current==Pause_syn) pause_quanta_val_tmp <=1; else pause_quanta_val_tmp <=0; always @ (posedge Clk or posedge Reset) if (Reset) pause_quanta_val <=0; else if(Current_state==State_OkEnd&&Pause_current==Pause_syn||pause_quanta_val_tmp) pause_quanta_val <=1; else pause_quanta_val <=0; always @ (posedge Clk or posedge Reset) if (Reset) pause_frame_ptr <=0; else if(Pause_current==Pause_syn) pause_frame_ptr <=1; else pause_frame_ptr <=0; endmodule"
    },
    {
        "file_name": "Phy_sim.v",
        "verilog_design": "`timescale 1ns/100ps module Phy_sim ( input Gtx_clk , output Rx_clk , output Tx_clk , input Tx_er , input Tx_en , input [7:0] Txd , output Rx_er , output Rx_dv , output [7:0] Rxd , output Crs , output Col , input [2:0] Speed ); reg Clk_25m ; reg Clk_2_5m ; always begin #20 Clk_25m=0; #20 Clk_25m=1; end always begin #200 Clk_2_5m=0; #200 Clk_2_5m=1; end assign Rx_clk=Speed[2]?Gtx_clk:Speed[1]?Clk_25m:Speed[0]?Clk_2_5m:0; assign Tx_clk=Speed[2]?Gtx_clk:Speed[1]?Clk_25m:Speed[0]?Clk_2_5m:0; assign Rx_dv =Tx_en ; assign Rxd =Txd ; assign Rx_er =0 ; assign Crs =Tx_en ; assign Col =0 ; endmodule"
    },
    {
        "file_name": "Ramdon_gen.v",
        "verilog_design": "module Ramdon_gen( Reset , Clk , Init , RetryCnt , Random_time_meet ); input Reset ; input Clk ; input Init ; input [3:0] RetryCnt ; output Random_time_meet; reg [9:0] Random_sequence ; reg [9:0] Ramdom ; reg [9:0] Ramdom_counter ; reg [7:0] Slot_time_counter; reg Random_time_meet; always @ (posedge Clk or posedge Reset) if (Reset) Random_sequence <=0; else Random_sequence <={Random_sequence[8:0],~(Random_sequence[2]^Random_sequence[9])}; always @ (RetryCnt or Random_sequence) case (RetryCnt) 4'h0 : Ramdom={9'b0,Random_sequence[0]}; 4'h1 : Ramdom={8'b0,Random_sequence[1:0]}; 4'h2 : Ramdom={7'b0,Random_sequence[2:0]}; 4'h3 : Ramdom={6'b0,Random_sequence[3:0]}; 4'h4 : Ramdom={5'b0,Random_sequence[4:0]}; 4'h5 : Ramdom={4'b0,Random_sequence[5:0]}; 4'h6 : Ramdom={3'b0,Random_sequence[6:0]}; 4'h7 : Ramdom={2'b0,Random_sequence[7:0]}; 4'h8 : Ramdom={1'b0,Random_sequence[8:0]}; 4'h9 : Ramdom={ Random_sequence[9:0]}; default : Ramdom={ Random_sequence[9:0]}; endcase always @ (posedge Clk or posedge Reset) if (Reset) Slot_time_counter <=0; else if(Init) Slot_time_counter <=0; else if(!Random_time_meet) Slot_time_counter <=Slot_time_counter+1; always @ (posedge Clk or posedge Reset) if (Reset) Ramdom_counter <=0; else if (Init) Ramdom_counter <=Ramdom; else if (Ramdom_counter!=0&&Slot_time_counter==255) Ramdom_counter <=Ramdom_counter -1 ; always @ (posedge Clk or posedge Reset) if (Reset) Random_time_meet <=1; else if (Init) Random_time_meet <=0; else if (Ramdom_counter==0) Random_time_meet <=1; endmodule"
    },
    {
        "file_name": "reg_int_sim.v",
        "verilog_design": "module reg_int_sim ( input Reset , input Clk_reg , output [4:0] Tx_Hwmark , output [4:0] Tx_Lwmark , output pause_frame_send_en , output [15:0] pause_quanta_set , output MAC_tx_add_en , output FullDuplex , output [3:0] MaxRetry , output [5:0] IFGset , output [7:0] MAC_tx_add_prom_data , output [2:0] MAC_tx_add_prom_add , output MAC_tx_add_prom_wr , output tx_pause_en , output xoff_cpu , output xon_cpu , output MAC_rx_add_chk_en , output [7:0] MAC_rx_add_prom_data , output [2:0] MAC_rx_add_prom_add , output MAC_rx_add_prom_wr , output broadcast_filter_en , output [15:0] broadcast_MAX , output RX_APPEND_CRC , output CRC_chk_en , output [5:0] RX_IFG_SET , output [15:0] RX_MAX_LENGTH , output [6:0] RX_MIN_LENGTH , output [5:0] CPU_rd_addr , output CPU_rd_apply , input CPU_rd_grant , input [31:0] CPU_rd_dout , output Line_loop_en , output [2:0] Speed , input Busy , input LinkFail , input Nvalid , input [15:0] Prsd , input UpdateMIIRX_DATAReg ); assign Tx_Hwmark =5'h1e; assign Tx_Lwmark =5'h19; assign pause_frame_send_en =0; assign pause_quanta_set =0; assign MAC_tx_add_en =0; assign FullDuplex =1; assign MaxRetry =2; assign IFGset =10; assign MAC_tx_add_prom_data =0; assign MAC_tx_add_prom_add =0; assign MAC_tx_add_prom_wr =0; assign tx_pause_en =0; assign xoff_cpu =0; assign xon_cpu =0; assign MAC_rx_add_chk_en =0; assign MAC_rx_add_prom_data =0; assign MAC_rx_add_prom_add =0; assign MAC_rx_add_prom_wr =0; assign broadcast_filter_en =0; assign broadcast_MAX =10; assign RX_APPEND_CRC =0; assign CRC_chk_en =1; assign RX_IFG_SET =10; assign RX_MAX_LENGTH =1518; assign RX_MIN_LENGTH =64; assign CPU_rd_addr =0; assign CPU_rd_apply =0; assign Line_loop_en =0; assign Speed =3'b001; endmodule"
    },
    {
        "file_name": "RMON_addr_gen.v",
        "verilog_design": "module RMON_addr_gen( Clk , Reset , Pkt_type_rmon , Pkt_length_rmon , Apply_rmon , Pkt_err_type_rmon , Reg_apply , Reg_addr , Reg_data , Reg_next , Reg_drop_apply ); input Clk ; input Reset ; input [2:0] Pkt_type_rmon ; input [15:0] Pkt_length_rmon ; input Apply_rmon ; input [2:0] Pkt_err_type_rmon ; output Reg_apply ; output [4:0] Reg_addr ; output [15:0] Reg_data ; input Reg_next ; output Reg_drop_apply ; parameter StateIdle =4'd0; parameter StatePktLength =4'd1; parameter StatePktNumber =4'd2; parameter StatePktType =4'd3; parameter StatePktRange =4'd4; reg [3:0] CurrentState ; reg [3:0] NextState; reg [2:0] PktTypeReg ; reg [15:0] PktLengthReg ; reg [2:0] PktErrTypeReg ; reg Reg_apply ; reg [4:0] Reg_addr ; reg [15:0] Reg_data ; reg Reg_drop_apply ; reg Apply_rmon_dl1; reg Apply_rmon_dl2; reg Apply_rmon_pulse; reg [2:0] Pkt_type_rmon_dl1 ; reg [15:0] Pkt_length_rmon_dl1 ; reg [2:0] Pkt_err_type_rmon_dl1 ; always @(posedge Clk or posedge Reset) if (Reset) begin Pkt_type_rmon_dl1 <=0; Pkt_length_rmon_dl1 <=0; Pkt_err_type_rmon_dl1 <=0; end else begin Pkt_type_rmon_dl1 <=Pkt_type_rmon ; Pkt_length_rmon_dl1 <=Pkt_length_rmon ; Pkt_err_type_rmon_dl1 <=Pkt_err_type_rmon ; end always @(posedge Clk or posedge Reset) if (Reset) begin Apply_rmon_dl1 <=0; Apply_rmon_dl2 <=0; end else begin Apply_rmon_dl1 <=Apply_rmon; Apply_rmon_dl2 <=Apply_rmon_dl1; end always @(Apply_rmon_dl1 or Apply_rmon_dl2) if (Apply_rmon_dl1&!Apply_rmon_dl2) Apply_rmon_pulse =1; else Apply_rmon_pulse =0; always @(posedge Clk or posedge Reset) if (Reset) begin PktTypeReg <=0; PktLengthReg <=0; PktErrTypeReg <=0; end else if (Apply_rmon_pulse&&CurrentState==StateIdle) begin PktTypeReg <=Pkt_type_rmon_dl1 ; PktLengthReg <=Pkt_length_rmon_dl1 ; PktErrTypeReg <=Pkt_err_type_rmon_dl1 ; end always @(posedge Clk or posedge Reset) if (Reset) CurrentState <=StateIdle; else CurrentState <=NextState; always @(CurrentState or Apply_rmon_pulse or Reg_next) case (CurrentState) StateIdle: if (Apply_rmon_pulse) NextState =StatePktLength; else NextState =StateIdle; StatePktLength: if (Reg_next) NextState =StatePktNumber; else NextState =CurrentState; StatePktNumber: if (Reg_next) NextState =StatePktType; else NextState =CurrentState; StatePktType: if (Reg_next) NextState =StatePktRange; else NextState =CurrentState; StatePktRange: if (Reg_next) NextState =StateIdle; else NextState =CurrentState; default: NextState =StateIdle; endcase always @ (CurrentState) if (CurrentState==StatePktLength||CurrentState==StatePktNumber|| CurrentState==StatePktType||CurrentState==StatePktRange) Reg_apply =1; else Reg_apply =0; always @ (posedge Clk or posedge Reset) if (Reset) Reg_addr <=0; else case (CurrentState) StatePktLength: Reg_addr <=5'd00; StatePktNumber: Reg_addr <=5'd01; StatePktType: case(PktTypeReg) 3'b011: Reg_addr <=5'd02; 3'b001: Reg_addr <=5'd03; 3'b100: Reg_addr <=5'd16; default: Reg_addr <=5'd04; endcase StatePktRange: case(PktErrTypeReg) 3'b001: Reg_addr <=5'd05; 3'b010: Reg_addr <=5'd06; 3'b011: Reg_addr <=5'd07; 3'b100: if (PktLengthReg<64) Reg_addr <=5'd08; else if (PktLengthReg==64) Reg_addr <=5'd09; else if (PktLengthReg<128) Reg_addr <=5'd10; else if (PktLengthReg<256) Reg_addr <=5'd11; else if (PktLengthReg<512) Reg_addr <=5'd12; else if (PktLengthReg<1024) Reg_addr <=5'd13; else if (PktLengthReg<1519) Reg_addr <=5'd14; else Reg_addr <=5'd15; default: Reg_addr <=5'd05; endcase default: Reg_addr <=5'd05; endcase always @ (CurrentState or PktLengthReg) case (CurrentState) StatePktLength: Reg_data =PktLengthReg; StatePktNumber: Reg_data =1; StatePktType: Reg_data =1; StatePktRange: Reg_data =1; default: Reg_data =0; endcase always @ (posedge Clk or posedge Reset) if (Reset) Reg_drop_apply <=0; else if (CurrentState!=StateIdle&&Apply_rmon_pulse) Reg_drop_apply <=1; else Reg_drop_apply <=0; endmodule"
    },
    {
        "file_name": "RMON_ctrl.v",
        "verilog_design": "module RMON_CTRL ( Clk , Reset , Reg_apply_0 , Reg_addr_0 , Reg_data_0 , Reg_next_0 , Reg_apply_1 , Reg_addr_1 , Reg_data_1 , Reg_next_1 , Addra , Dina , Douta , Wea , CPU_rd_addr , CPU_rd_apply , CPU_rd_grant , CPU_rd_dout ); input Clk ; input Reset ; input Reg_apply_0 ; input [4:0] Reg_addr_0 ; input [15:0] Reg_data_0 ; output Reg_next_0 ; input Reg_apply_1 ; input [4:0] Reg_addr_1 ; input [15:0] Reg_data_1 ; output Reg_next_1 ; output [5:0] Addra ; output [31:0] Dina ; input [31:0] Douta ; output Wea ; input [5:0] CPU_rd_addr ; input CPU_rd_apply ; output CPU_rd_grant ; output [31:0] CPU_rd_dout ; parameter StateCPU =4'd00; parameter StateMAC0 =4'd01; parameter StateMAC1 =4'd02; reg [3:0] CurrentState ; reg [3:0] NextState; reg [3:0] CurrentState_reg; reg [4:0] StepCounter; reg [31:0] DoutaReg; reg [5:0] Addra ; reg [31:0] Dina; reg Reg_next_0 ; reg Reg_next_1 ; reg Write; reg Read; reg Pipeline; reg [31:0] CPU_rd_dout ; reg CPU_rd_apply_reg ; always @(posedge Clk or posedge Reset) if (Reset) CurrentState <=StateMAC0; else CurrentState <=NextState; always @(posedge Clk or posedge Reset) if (Reset) CurrentState_reg <=StateMAC0; else if(CurrentState!=StateCPU) CurrentState_reg <=CurrentState; always @(CurrentState or CPU_rd_apply_reg or Reg_apply_0 or CurrentState_reg or Reg_apply_1 or StepCounter ) case(CurrentState) StateMAC0: if(!Reg_apply_0&&CPU_rd_apply_reg) NextState =StateCPU; else if(!Reg_apply_0) NextState =StateMAC1; else NextState =CurrentState; StateMAC1: if(!Reg_apply_1&&CPU_rd_apply_reg) NextState =StateCPU; else if(!Reg_apply_1) NextState =StateMAC0; else NextState =CurrentState; StateCPU: if (StepCounter==3) case (CurrentState_reg) StateMAC0 :NextState =StateMAC0 ; StateMAC1 :NextState =StateMAC1 ; default :NextState =StateMAC0; endcase else NextState =CurrentState; default: NextState =StateMAC0; endcase always @(posedge Clk or posedge Reset) if (Reset) StepCounter <=0; else if(NextState!=CurrentState) StepCounter <=0; else if (StepCounter!=4'hf) StepCounter <=StepCounter + 1; always @(StepCounter) if( StepCounter==1||StepCounter==4|| StepCounter==7||StepCounter==10) Read =1; else Read =0; always @(StepCounter or CurrentState) if( StepCounter==2||StepCounter==5|| StepCounter==8||StepCounter==11) Pipeline =1; else Pipeline =0; always @(StepCounter or CurrentState) if( StepCounter==3||StepCounter==6|| StepCounter==9||StepCounter==12) Write =1; else Write =0; always @(posedge Clk or posedge Reset) if (Reset) DoutaReg <=0; else if (Read) DoutaReg <=Douta; always @(*) case(CurrentState) StateMAC0 : Addra={1'd0 ,Reg_addr_0 }; StateMAC1 : Addra={1'd1 ,Reg_addr_1 }; StateCPU: Addra=CPU_rd_addr; default: Addra=0; endcase always @(posedge Clk or posedge Reset) if (Reset) Dina <=0; else case(CurrentState) StateMAC0 : Dina<=Douta+Reg_data_0 ; StateMAC1 : Dina<=Douta+Reg_data_1 ; StateCPU: Dina<=0; default: Dina<=0; endcase assign Wea =Write; always @(CurrentState or Pipeline) if(CurrentState==StateMAC0) Reg_next_0 =Pipeline; else Reg_next_0 =0; always @(CurrentState or Pipeline) if(CurrentState==StateMAC1) Reg_next_1 =Pipeline; else Reg_next_1 =0; reg CPU_rd_apply_dl1; reg CPU_rd_apply_dl2; always @ (posedge Clk or posedge Reset) if (Reset) begin CPU_rd_apply_dl1 <=0; CPU_rd_apply_dl2 <=0; end else begin CPU_rd_apply_dl1 <=CPU_rd_apply; CPU_rd_apply_dl2 <=CPU_rd_apply_dl1; end always @ (posedge Clk or posedge Reset) if (Reset) CPU_rd_apply_reg <=0; else if (CPU_rd_apply_dl1&!CPU_rd_apply_dl2) CPU_rd_apply_reg <=1; else if (CurrentState==StateCPU&&Write) CPU_rd_apply_reg <=0; assign CPU_rd_grant =!CPU_rd_apply_reg; always @ (posedge Clk or posedge Reset) if (Reset) CPU_rd_dout <=0; else if (Pipeline&&CurrentState==StateCPU) CPU_rd_dout <=Douta; endmodule"
    },
    {
        "file_name": "ack_counter.v",
        "verilog_design": "module ack_counter ( clock , reset , ready, tx_start , max_count, tx_ack ); input clock; input reset; input ready; input tx_start; input [15:0] max_count; output tx_ack; wire clock; wire reset; wire ready; wire tx_start; wire [15:0] max_count; reg tx_ack; reg start_count; reg start_count_del; reg [15:0] counter; always @ (reset or tx_start or counter or max_count) begin if (reset) begin start_count <= 0; end else if (tx_start) begin start_count <= 1; end else if ((counter == max_count) & !ready) begin start_count <= 0; end end always @ (posedge clock or posedge reset) begin if (reset) begin counter <= 0; end else if (counter == max_count) begin counter <= 0; end else if (start_count) begin counter <= counter + 1; end end always @ (posedge clock or posedge reset) begin if (reset) begin start_count_del <= 0; tx_ack <= 0; end else begin start_count_del <= start_count; tx_ack <= ~start_count & start_count_del; end end endmodule"
    },
    {
        "file_name": "counter.v",
        "verilog_design": "`timescale 100ps / 10ps module counter(clk, reset, load, en, value); input clk; input reset; input load; input en; parameter WIDTH = 8; output[WIDTH-1:0] value; reg [WIDTH-1:0] value; always @(posedge clk or posedge reset) if (reset) value <= 0; else begin if (load) value <= 0; else if (en) value <= value + 1; end endmodule"
    },
    {
        "file_name": "rxClkgen.v",
        "verilog_design": "`include \"timescale.v\" `include \"xgiga_define.v\" module rxClkgen(rxclk_in, reset, rxclk, rxclk_180, locked); input rxclk_in; input reset; output rxclk; output rxclk_180; output locked; wire rxclk; wire rxclk_180; assign rxclk = rxclk_in; assign rxclk_180 = ~rxclk; assign locked = ~reset; endmodule"
    },
    {
        "file_name": "rxLinkFaultState.v",
        "verilog_design": "`include \"timescale.v\" `include \"xgiga_define.v\" module rxLinkFaultState(rxclk, reset, local_fault, remote_fault, link_fault); input rxclk; input reset; input local_fault; input remote_fault; output[1:0] link_fault; parameter TP =1; parameter IDLE = 0, LinkFaultDetect = 1, NewFaultType = 2, GetFault = 3; wire fault_type; wire get_one_fault; wire no_new_type; reg[2:0] linkstate, linkstate_next; reg[5:0] col_cnt; reg seq_cnt; reg[1:0] seq_type; reg[1:0] last_seq_type; reg[1:0] link_fault; reg reset_col_cnt; wire seq_cnt_3; wire col_cnt_64; assign fault_type = {local_fault, remote_fault}; assign get_one_fault = local_fault | remote_fault; assign no_new_type = (seq_type == last_seq_type); assign col_cnt_64 = & col_cnt; always@(posedge rxclk or posedge reset)begin if (reset) begin seq_type <=#TP 0; seq_cnt <=#TP 0; last_seq_type <=#TP 0; reset_col_cnt<= #TP 1; link_fault <=#TP 2'b00; linkstate<= #TP IDLE; end else begin seq_type <= #TP fault_type; last_seq_type <=#TP seq_type; case (linkstate) IDLE: begin linkstate <=#TP IDLE; reset_col_cnt <= #TP 1; seq_cnt <= #TP 0; link_fault <= #TP 2'b00; if (get_one_fault) linkstate<=#TP LinkFaultDetect; end LinkFaultDetect: begin linkstate <=#TP LinkFaultDetect; reset_col_cnt <=#TP 1; if (get_one_fault & no_new_type) begin if (seq_cnt) begin linkstate <=#TP IDLE; link_fault <=#TP seq_type; end else seq_cnt <=#TP seq_cnt + 1; end else if(~get_one_fault) begin reset_col_cnt <=#TP 0; if (col_cnt_64) linkstate <=#TP IDLE; end else if(get_one_fault & ~no_new_type) linkstate <=#TP NewFaultType; end NewFaultType: begin seq_cnt <=#TP 0; linkstate <=#TP LinkFaultDetect; reset_col_cnt<=#TP 1; end endcase end end always@(posedge rxclk or posedge reset) begin if (reset) col_cnt <=#TP 0; else if (reset_col_cnt) col_cnt <=#TP 0; else col_cnt <=#TP col_cnt + 1; end endmodule"
    },
    {
        "file_name": "rxNumCounter.v",
        "verilog_design": "`include \"timescale.v\" `include \"xgiga_define.v\" `include \"counter.v\" module rxNumCounter(rxclk, reset, receiving, frame_cnt); input rxclk; input reset; input receiving; output[`COUNTER_WIDTH-1:0] frame_cnt; parameter TP =1; counter data_counter(.clk(rxclk), .reset(reset), .load(~receiving), .en(receiving), .value(frame_cnt)); endmodule"
    },
    {
        "file_name": "rxStateMachine.v",
        "verilog_design": "`include \"timescale.v\" `include \"xgiga_define.v\" module rxStateMachine(rxclk, reset, recv_enable, get_sfd, local_invalid, length_error, crc_check_valid, crc_check_invalid, start_da, start_lt, receiving, receiving_d1, good_frame_get, bad_frame_get, get_error_code, wait_crc_check, get_terminator,check_reset); input rxclk; input reset; input recv_enable; input get_sfd; input local_invalid; input length_error; input get_terminator; input crc_check_valid; input crc_check_invalid; input get_error_code; input check_reset; output start_da; output start_lt; output receiving; output receiving_d1; output good_frame_get; output bad_frame_get; output wait_crc_check; parameter IDLE = 0, rxReceiveDA = 1, rxReceiveLT = 2, rxReceiveData = 4; parameter rxGetError = 8, rxIFGWait = 16; parameter TP =1; wire start_da; wire start_lt; wire receiving; reg good_frame_get; reg bad_frame_get; reg[4:0] rxstate, rxstate_next; always@(rxstate, get_sfd, local_invalid, recv_enable, get_error_code, length_error, get_terminator, reset)begin if (reset) begin rxstate_next <=#TP IDLE; end else begin case (rxstate) IDLE: begin if (get_sfd && recv_enable) rxstate_next <=#TP rxReceiveDA; else rxstate_next <=#TP IDLE; end rxReceiveDA: begin rxstate_next <=#TP rxReceiveLT; end rxReceiveLT: begin rxstate_next <=#TP rxReceiveData; end rxReceiveData: begin if (local_invalid |length_error| get_error_code) rxstate_next <=#TP rxGetError; else if (get_terminator) rxstate_next <=#TP rxIFGWait; else rxstate_next <=#TP rxReceiveData; end rxGetError: begin if (get_sfd && recv_enable) rxstate_next <=#TP rxReceiveDA; else rxstate_next <=#TP IDLE; end rxIFGWait : begin if (get_sfd && recv_enable) rxstate_next <=#TP rxReceiveDA; else rxstate_next <=#TP IDLE; end endcase end end always@(posedge rxclk or posedge reset) begin if (reset) rxstate <=#TP IDLE; else rxstate <=#TP rxstate_next; end assign start_da = rxstate[0]; assign start_lt = rxstate[1]; assign receiving = rxstate[2] | rxstate[1] | rxstate[0]; reg receiving_d1; always@(posedge rxclk or posedge reset) begin if (reset) begin receiving_d1<=#TP 0; end else begin receiving_d1<=#TP receiving; end end reg wait_crc_check; always@(posedge rxclk or posedge reset) begin if (reset) wait_crc_check <=#TP 0; else if (rxstate[4]) wait_crc_check <=#TP 1'b1; else if (crc_check_valid || crc_check_invalid||length_error) wait_crc_check <=#TP 1'b0; else wait_crc_check <=#TP wait_crc_check; end always@(posedge rxclk or posedge reset)begin if (reset) begin bad_frame_get <=#TP 0; good_frame_get <=#TP 0; end else if(rxstate[3] || crc_check_invalid || length_error)begin bad_frame_get <=#TP 1'b1; good_frame_get <=#TP 1'b0; end else if (crc_check_valid)begin good_frame_get <=#TP 1'b1; bad_frame_get <=#TP 1'b0; end else if (check_reset)begin good_frame_get <=#TP 1'b0; bad_frame_get <=#TP 1'b0; end end endmodule"
    },
    {
        "file_name": "rxStatModule.v",
        "verilog_design": "`include \"timescale.v\" `include \"xgiga_define.v\" module rxStatModule(rxclk, reset, good_frame_get,crc_check_invalid, large_error, small_error, receiving, padded_frame, pause_frame, broad_valid, multi_valid, length_65_127, length_128_255, length_256_511, length_512_1023, length_1024_max, jumbo_frame, get_error_code, rxStatRegPlus); input rxclk; input reset; input good_frame_get; input large_error; input small_error; input crc_check_invalid; input receiving; input padded_frame; input pause_frame; input broad_valid; input multi_valid; input length_65_127; input length_128_255; input length_256_511; input length_512_1023; input length_1024_max; input jumbo_frame; input get_error_code; output [17:0] rxStatRegPlus; parameter TP =1; wire[17:0] rxStatRegPlus_tmp; assign rxStatRegPlus_tmp[0] = good_frame_get; assign rxStatRegPlus_tmp[1] = crc_check_invalid; assign rxStatRegPlus_tmp[2] = broad_valid & good_frame_get; assign rxStatRegPlus_tmp[3] = multi_valid & good_frame_get; assign rxStatRegPlus_tmp[4] = padded_frame & good_frame_get; assign rxStatRegPlus_tmp[5] = length_65_127 & good_frame_get; assign rxStatRegPlus_tmp[6] = length_128_255 & good_frame_get; assign rxStatRegPlus_tmp[7] = length_256_511 & good_frame_get; assign rxStatRegPlus_tmp[8] = length_512_1023 & good_frame_get; assign rxStatRegPlus_tmp[9] = length_1024_max & good_frame_get; assign rxStatRegPlus_tmp[10] = pause_frame & good_frame_get; assign rxStatRegPlus_tmp[11] = large_error; assign rxStatRegPlus_tmp[12] = pause_frame & good_frame_get; assign rxStatRegPlus_tmp[13] = 0; assign rxStatRegPlus_tmp[14] = jumbo_frame & good_frame_get; assign rxStatRegPlus_tmp[15] = small_error; assign rxStatRegPlus_tmp[16] = receiving & get_error_code; assign rxStatRegPlus_tmp[17] = receiving; reg[17:0] rxStatRegPlus; always@(posedge rxclk or posedge reset) begin if(reset) rxStatRegPlus <=#TP 0; else rxStatRegPlus <=#TP rxStatRegPlus_tmp; end endmodule"
    },
    {
        "file_name": "apb.v",
        "verilog_design": "`timescale 1ns/1ps module apb( input PCLK, input PRESETn, input PSELx, input PWRITE, input PENABLE, input [31:0] PADDR, input [31:0] PWDATA, input [31:0] READ_DATA_ON_RX, input ERROR, input TX_EMPTY, input RX_EMPTY, output [31:0] PRDATA, output reg [13:0] INTERNAL_I2C_REGISTER_CONFIG, output reg [13:0] INTERNAL_I2C_REGISTER_TIMEOUT, output [31:0] WRITE_DATA_ON_TX, output WR_ENA, output RD_ENA, output PREADY, output PSLVERR, output INT_RX, output INT_TX ); assign WR_ENA = (PWRITE == 1'b1 & PENABLE == 1'b1 & PADDR == 32'd0 & PSELx == 1'b1)? 1'b1:1'b0; assign RD_ENA = (PWRITE == 1'b0 & PENABLE == 1'b1 & PADDR == 32'd4 & PSELx == 1'b1)? 1'b1:1'b0; assign PREADY = ((WR_ENA == 1'b1 | RD_ENA == 1'b1 | PADDR == 32'd8 | PADDR == 32'd12) & (PENABLE == 1'b1 & PSELx == 1'b1))? 1'b1:1'b0; assign WRITE_DATA_ON_TX = (PADDR == 32'd0)? PWDATA:PWDATA; assign PRDATA = (PADDR == 32'd4)? READ_DATA_ON_RX:READ_DATA_ON_RX; assign PSLVERR = ERROR; assign INT_TX = TX_EMPTY; assign INT_RX = RX_EMPTY; always@(posedge PCLK) begin if(!PRESETn) begin INTERNAL_I2C_REGISTER_CONFIG <= 14'd0; INTERNAL_I2C_REGISTER_TIMEOUT <= 14'd0; end else begin if(PADDR == 32'd8 && PSELx == 1'b1 && PWRITE == 1'b1 && PREADY == 1'b1) begin INTERNAL_I2C_REGISTER_CONFIG <= PWDATA[13:0]; end else if(PADDR == 32'd12 && PSELx == 1'b1 && PWRITE == 1'b1 && PREADY == 1'b1) begin INTERNAL_I2C_REGISTER_TIMEOUT <= PWDATA[13:0]; end else begin INTERNAL_I2C_REGISTER_CONFIG <= INTERNAL_I2C_REGISTER_CONFIG; end end end endmodule"
    },
    {
        "file_name": "can_btl.v",
        "verilog_design": "`include \"timescale.v\" `include \"can_defines.v\" module can_btl ( clk, rst, rx, tx, baud_r_presc, sync_jump_width, time_segment1, time_segment2, triple_sampling, sample_point, sampled_bit, sampled_bit_q, tx_point, hard_sync, rx_idle, rx_inter, transmitting, transmitter, go_rx_inter, tx_next, go_overload_frame, go_error_frame, go_tx, send_ack, node_error_passive ); parameter Tp = 1; input clk; input rst; input rx; input tx; input [5:0] baud_r_presc; input [1:0] sync_jump_width; input [3:0] time_segment1; input [2:0] time_segment2; input triple_sampling; input rx_idle; input rx_inter; input transmitting; input transmitter; input go_rx_inter; input tx_next; input go_overload_frame; input go_error_frame; input go_tx; input send_ack; input node_error_passive; output sample_point; output sampled_bit; output sampled_bit_q; output tx_point; output hard_sync; reg [6:0] clk_cnt; reg clk_en; reg clk_en_q; reg sync_blocked; reg hard_sync_blocked; reg sampled_bit; reg sampled_bit_q; reg [4:0] quant_cnt; reg [3:0] delay; reg sync; reg seg1; reg seg2; reg resync_latched; reg sample_point; reg [1:0] sample; reg tx_point; reg tx_next_sp; wire go_sync; wire go_seg1; wire go_seg2; wire [7:0] preset_cnt; wire sync_window; wire resync; assign preset_cnt = (baud_r_presc + 1'b1)<<1; assign hard_sync = (rx_idle | rx_inter) & (~rx) & sampled_bit & (~hard_sync_blocked); assign resync = (~rx_idle) & (~rx_inter) & (~rx) & sampled_bit & (~sync_blocked); always @ (posedge clk or posedge rst) begin if (rst) clk_cnt <= 7'h0; else if (clk_cnt >= (preset_cnt-1'b1)) clk_cnt <=#Tp 7'h0; else clk_cnt <=#Tp clk_cnt + 1'b1; end always @ (posedge clk or posedge rst) begin if (rst) clk_en <= 1'b0; else if ({1'b0, clk_cnt} == (preset_cnt-1'b1)) clk_en <=#Tp 1'b1; else clk_en <=#Tp 1'b0; end always @ (posedge clk or posedge rst) begin if (rst) clk_en_q <= 1'b0; else clk_en_q <=#Tp clk_en; end assign go_sync = clk_en_q & seg2 & (quant_cnt[2:0] == time_segment2) & (~hard_sync) & (~resync); assign go_seg1 = clk_en_q & (sync | hard_sync | (resync & seg2 & sync_window) | (resync_latched & sync_window)); assign go_seg2 = clk_en_q & (seg1 & (~hard_sync) & (quant_cnt == (time_segment1 + delay))); always @ (posedge clk or posedge rst) begin if (rst) tx_point <= 1'b0; else tx_point <=#Tp ~tx_point & seg2 & ( clk_en & (quant_cnt[2:0] == time_segment2) | (clk_en | clk_en_q) & (resync | hard_sync) ); end always @ (posedge clk or posedge rst) begin if (rst) resync_latched <= 1'b0; else if (resync & seg2 & (~sync_window)) resync_latched <=#Tp 1'b1; else if (go_seg1) resync_latched <= 1'b0; end always @ (posedge clk or posedge rst) begin if (rst) sync <= 1'b0; else if (clk_en_q) sync <=#Tp go_sync; end always @ (posedge clk or posedge rst) begin if (rst) seg1 <= 1'b1; else if (go_seg1) seg1 <=#Tp 1'b1; else if (go_seg2) seg1 <=#Tp 1'b0; end always @ (posedge clk or posedge rst) begin if (rst) seg2 <= 1'b0; else if (go_seg2) seg2 <=#Tp 1'b1; else if (go_sync | go_seg1) seg2 <=#Tp 1'b0; end always @ (posedge clk or posedge rst) begin if (rst) quant_cnt <= 5'h0; else if (go_sync | go_seg1 | go_seg2) quant_cnt <=#Tp 5'h0; else if (clk_en_q) quant_cnt <=#Tp quant_cnt + 1'b1; end always @ (posedge clk or posedge rst) begin if (rst) delay <= 4'h0; else if (resync & seg1 & (~transmitting | transmitting & (tx_next_sp | (tx & (~rx))))) delay <=#Tp (quant_cnt > {3'h0, sync_jump_width})? ({2'h0, sync_jump_width} + 1'b1) : (quant_cnt + 1'b1); else if (go_sync | go_seg1) delay <=#Tp 4'h0; end assign sync_window = ((time_segment2 - quant_cnt[2:0]) < ( sync_jump_width + 1'b1)); always @ (posedge clk or posedge rst) begin if (rst) sample <= 2'b11; else if (clk_en_q) sample <= {sample[0], rx}; end always @ (posedge clk or posedge rst) begin if (rst) begin sampled_bit <= 1'b1; sampled_bit_q <= 1'b1; sample_point <= 1'b0; end else if (go_error_frame) begin sampled_bit_q <=#Tp sampled_bit; sample_point <=#Tp 1'b0; end else if (clk_en_q & (~hard_sync)) begin if (seg1 & (quant_cnt == (time_segment1 + delay))) begin sample_point <=#Tp 1'b1; sampled_bit_q <=#Tp sampled_bit; if (triple_sampling) sampled_bit <=#Tp (sample[0] & sample[1]) | ( sample[0] & rx) | (sample[1] & rx); else sampled_bit <=#Tp rx; end end else sample_point <=#Tp 1'b0; end always @ (posedge clk or posedge rst) begin if (rst) tx_next_sp <= 1'b0; else if (go_overload_frame | (go_error_frame & (~node_error_passive)) | go_tx | send_ack) tx_next_sp <=#Tp 1'b0; else if (go_error_frame & node_error_passive) tx_next_sp <=#Tp 1'b1; else if (sample_point) tx_next_sp <=#Tp tx_next; end always @ (posedge clk or posedge rst) begin if (rst) sync_blocked <=#Tp 1'b1; else if (clk_en_q) begin if (resync) sync_blocked <=#Tp 1'b1; else if (go_seg2) sync_blocked <=#Tp 1'b0; end end always @ (posedge clk or posedge rst) begin if (rst) hard_sync_blocked <=#Tp 1'b0; else if (hard_sync & clk_en_q | (transmitting & transmitter | go_tx) & tx_point & (~tx_next)) hard_sync_blocked <=#Tp 1'b1; else if (go_rx_inter | (rx_idle | rx_inter) & sample_point & sampled_bit) hard_sync_blocked <=#Tp 1'b0; end endmodule"
    },
    {
        "file_name": "can_crc.v",
        "verilog_design": "`include \"timescale.v\" module can_crc (clk, data, enable, initialize, crc); parameter Tp = 1; input clk; input data; input enable; input initialize; output [14:0] crc; reg [14:0] crc; wire crc_next; wire [14:0] crc_tmp; assign crc_next = data ^ crc[14]; assign crc_tmp = {crc[13:0], 1'b0}; always @ (posedge clk) begin if(initialize) crc <= #Tp 15'h0; else if (enable) begin if (crc_next) crc <= #Tp crc_tmp ^ 15'h4599; else crc <= #Tp crc_tmp; end end endmodule"
    },
    {
        "file_name": "can_fifo.v",
        "verilog_design": "`include \"timescale.v\" `include \"can_defines.v\" module can_fifo ( clk, rst, wr, data_in, addr, data_out, fifo_selected, reset_mode, release_buffer, extended_mode, overrun, info_empty, info_cnt `ifdef CAN_BIST , mbist_si_i, mbist_so_o, mbist_ctrl_i `endif ); parameter Tp = 1; input clk; input rst; input wr; input [7:0] data_in; input [5:0] addr; input reset_mode; input release_buffer; input extended_mode; input fifo_selected; output [7:0] data_out; output overrun; output info_empty; output [6:0] info_cnt; `ifdef CAN_BIST input mbist_si_i; output mbist_so_o; input [`CAN_MBIST_CTRL_WIDTH - 1:0] mbist_ctrl_i; wire mbist_s_0; `endif `ifdef ALTERA_RAM `else `ifdef ACTEL_APA_RAM `else `ifdef XILINX_RAM `else `ifdef ARTISAN_RAM reg overrun_info[0:63]; `else `ifdef VIRTUALSILICON_RAM reg overrun_info[0:63]; `else reg [7:0] fifo [0:63]; reg [3:0] length_fifo[0:63]; reg overrun_info[0:63]; `endif `endif `endif `endif `endif reg [5:0] rd_pointer; reg [5:0] wr_pointer; reg [5:0] read_address; reg [5:0] wr_info_pointer; reg [5:0] rd_info_pointer; reg wr_q; reg [3:0] len_cnt; reg [6:0] fifo_cnt; reg [6:0] info_cnt; reg latch_overrun; reg initialize_memories; wire [3:0] length_info; wire write_length_info; wire fifo_empty; wire fifo_full; wire info_full; assign write_length_info = (~wr) & wr_q; always @ (posedge clk or posedge rst) begin if (rst) wr_q <=#Tp 1'b0; else if (reset_mode) wr_q <=#Tp 1'b0; else wr_q <=#Tp wr; end always @ (posedge clk or posedge rst) begin if (rst) len_cnt <= 4'h0; else if (reset_mode | write_length_info) len_cnt <=#Tp 4'h0; else if (wr & (~fifo_full)) len_cnt <=#Tp len_cnt + 1'b1; end always @ (posedge clk or posedge rst) begin if (rst) wr_info_pointer <= 6'h0; else if (write_length_info & (~info_full) | initialize_memories) wr_info_pointer <=#Tp wr_info_pointer + 1'b1; else if (reset_mode) wr_info_pointer <=#Tp rd_info_pointer; end always @ (posedge clk or posedge rst) begin if (rst) rd_info_pointer <= 6'h0; else if (release_buffer & (~info_full)) rd_info_pointer <=#Tp rd_info_pointer + 1'b1; end always @ (posedge clk or posedge rst) begin if (rst) rd_pointer <= 5'h0; else if (release_buffer & (~fifo_empty)) rd_pointer <=#Tp rd_pointer + {2'h0, length_info}; end always @ (posedge clk or posedge rst) begin if (rst) wr_pointer <= 5'h0; else if (reset_mode) wr_pointer <=#Tp rd_pointer; else if (wr & (~fifo_full)) wr_pointer <=#Tp wr_pointer + 1'b1; end always @ (posedge clk or posedge rst) begin if (rst) latch_overrun <= 1'b0; else if (reset_mode | write_length_info) latch_overrun <=#Tp 1'b0; else if (wr & fifo_full) latch_overrun <=#Tp 1'b1; end always @ (posedge clk or posedge rst) begin if (rst) fifo_cnt <= 7'h0; else if (reset_mode) fifo_cnt <=#Tp 7'h0; else if (wr & (~release_buffer) & (~fifo_full)) fifo_cnt <=#Tp fifo_cnt + 1'b1; else if ((~wr) & release_buffer & (~fifo_empty)) fifo_cnt <=#Tp fifo_cnt - {3'h0, length_info}; else if (wr & release_buffer & (~fifo_full) & (~fifo_empty)) fifo_cnt <=#Tp fifo_cnt - {3'h0, length_info} + 1'b1; end assign fifo_full = fifo_cnt == 7'd64; assign fifo_empty = fifo_cnt == 7'd0; always @ (posedge clk or posedge rst) begin if (rst) info_cnt <=#Tp 7'h0; else if (reset_mode) info_cnt <=#Tp 7'h0; else if (write_length_info ^ release_buffer) begin if (release_buffer & (~info_empty)) info_cnt <=#Tp info_cnt - 1'b1; else if (write_length_info & (~info_full)) info_cnt <=#Tp info_cnt + 1'b1; end end assign info_full = info_cnt == 7'd64; assign info_empty = info_cnt == 7'd0; always @ (extended_mode or rd_pointer or addr) begin if (extended_mode) read_address = rd_pointer + (addr - 6'd16); else read_address = rd_pointer + (addr - 6'd20); end always @ (posedge clk or posedge rst) begin if (rst) initialize_memories <= 1'b1; else if (&wr_info_pointer) initialize_memories <=#Tp 1'b0; end `ifdef ALTERA_RAM lpm_ram_dp fifo ( .q (data_out), .rdclock (clk), .wrclock (clk), .data (data_in), .wren (wr & (~fifo_full)), .rden (fifo_selected), .wraddress (wr_pointer), .rdaddress (read_address) ); defparam fifo.lpm_width = 8; defparam fifo.lpm_widthad = 6; defparam fifo.lpm_numwords = 64; lpm_ram_dp info_fifo ( .q (length_info), .rdclock (clk), .wrclock (clk), .data (len_cnt & {4{~initialize_memories}}), .wren (write_length_info & (~info_full) | initialize_memories), .wraddress (wr_info_pointer), .rdaddress (rd_info_pointer) ); defparam info_fifo.lpm_width = 4; defparam info_fifo.lpm_widthad = 6; defparam info_fifo.lpm_numwords = 64; lpm_ram_dp overrun_fifo ( .q (overrun), .rdclock (clk), .wrclock (clk), .data ((latch_overrun | (wr & fifo_full)) & (~initialize_memories)), .wren (write_length_info & (~info_full) | initialize_memories), .wraddress (wr_info_pointer), .rdaddress (rd_info_pointer) ); defparam overrun_fifo.lpm_width = 1; defparam overrun_fifo.lpm_widthad = 6; defparam overrun_fifo.lpm_numwords = 64; `else `ifdef ACTEL_APA_RAM actel_ram_64x8_sync fifo ( .DO (data_out), .RCLOCK (clk), .WCLOCK (clk), .DI (data_in), .PO (), .WRB (~(wr & (~fifo_full))), .RDB (~fifo_selected), .WADDR (wr_pointer), .RADDR (read_address) ); actel_ram_64x4_sync info_fifo ( .DO (length_info), .RCLOCK (clk), .WCLOCK (clk), .DI (len_cnt & {4{~initialize_memories}}), .PO (), .WRB (~(write_length_info & (~info_full) | initialize_memories)), .RDB (1'b0), .WADDR (wr_info_pointer), .RADDR (rd_info_pointer) ); actel_ram_64x1_sync overrun_fifo ( .DO (overrun), .RCLOCK (clk), .WCLOCK (clk), .DI ((latch_overrun | (wr & fifo_full)) & (~initialize_memories)), .PO (), .WRB (~(write_length_info & (~info_full) | initialize_memories)), .RDB (1'b0), .WADDR (wr_info_pointer), .RADDR (rd_info_pointer) ); `else `ifdef XILINX_RAM RAMB4_S8_S8 fifo ( .DOA(), .DOB(data_out), .ADDRA({3'h0, wr_pointer}), .CLKA(clk), .DIA(data_in), .ENA(1'b1), .RSTA(1'b0), .WEA(wr & (~fifo_full)), .ADDRB({3'h0, read_address}), .CLKB(clk), .DIB(8'h0), .ENB(1'b1), .RSTB(1'b0), .WEB(1'b0) ); RAMB4_S4_S4 info_fifo ( .DOA(), .DOB(length_info), .ADDRA({4'h0, wr_info_pointer}), .CLKA(clk), .DIA(len_cnt & {4{~initialize_memories}}), .ENA(1'b1), .RSTA(1'b0), .WEA(write_length_info & (~info_full) | initialize_memories), .ADDRB({4'h0, rd_info_pointer}), .CLKB(clk), .DIB(4'h0), .ENB(1'b1), .RSTB(1'b0), .WEB(1'b0) ); RAMB4_S1_S1 overrun_fifo ( .DOA(), .DOB(overrun), .ADDRA({6'h0, wr_info_pointer}), .CLKA(clk), .DIA((latch_overrun | (wr & fifo_full)) & (~initialize_memories)), .ENA(1'b1), .RSTA(1'b0), .WEA(write_length_info & (~info_full) | initialize_memories), .ADDRB({6'h0, rd_info_pointer}), .CLKB(clk), .DIB(1'h0), .ENB(1'b1), .RSTB(1'b0), .WEB(1'b0) ); `else `ifdef VIRTUALSILICON_RAM `ifdef CAN_BIST vs_hdtp_64x8_bist fifo `else vs_hdtp_64x8 fifo `endif ( .RCK (clk), .WCK (clk), .RADR (read_address), .WADR (wr_pointer), .DI (data_in), .DOUT (data_out), .REN (~fifo_selected), .WEN (~(wr & (~fifo_full))) `ifdef CAN_BIST , .mbist_si_i (mbist_si_i), .mbist_so_o (mbist_s_0), .mbist_ctrl_i (mbist_ctrl_i) `endif ); `ifdef CAN_BIST vs_hdtp_64x4_bist info_fifo `else vs_hdtp_64x4 info_fifo `endif ( .RCK (clk), .WCK (clk), .RADR (rd_info_pointer), .WADR (wr_info_pointer), .DI (len_cnt & {4{~initialize_memories}}), .DOUT (length_info), .REN (1'b0), .WEN (~(write_length_info & (~info_full) | initialize_memories)) `ifdef CAN_BIST , .mbist_si_i (mbist_s_0), .mbist_so_o (mbist_so_o), .mbist_ctrl_i (mbist_ctrl_i) `endif ); always @ (posedge clk) begin if (write_length_info & (~info_full) | initialize_memories) overrun_info[wr_info_pointer] <=#Tp (latch_overrun | (wr & fifo_full)) & (~initialize_memories); end assign overrun = overrun_info[rd_info_pointer]; `else `ifdef ARTISAN_RAM `ifdef CAN_BIST art_hstp_64x8_bist fifo ( .CLKR (clk), .CLKW (clk), .AR (read_address), .AW (wr_pointer), .D (data_in), .Q (data_out), .REN (~fifo_selected), .WEN (~(wr & (~fifo_full))), .mbist_si_i (mbist_si_i), .mbist_so_o (mbist_s_0), .mbist_ctrl_i (mbist_ctrl_i) ); art_hstp_64x4_bist info_fifo ( .CLKR (clk), .CLKW (clk), .AR (rd_info_pointer), .AW (wr_info_pointer), .D (len_cnt & {4{~initialize_memories}}), .Q (length_info), .REN (1'b0), .WEN (~(write_length_info & (~info_full) | initialize_memories)), .mbist_si_i (mbist_s_0), .mbist_so_o (mbist_so_o), .mbist_ctrl_i (mbist_ctrl_i) ); `else art_hsdp_64x8 fifo ( .CENA (1'b0), .CENB (1'b0), .CLKA (clk), .CLKB (clk), .AA (read_address), .AB (wr_pointer), .DA (8'h00), .DB (data_in), .QA (data_out), .QB (), .OENA (~fifo_selected), .OENB (1'b1), .WENA (1'b1), .WENB (~(wr & (~fifo_full))) ); art_hsdp_64x4 info_fifo ( .CENA (1'b0), .CENB (1'b0), .CLKA (clk), .CLKB (clk), .AA (rd_info_pointer), .AB (wr_info_pointer), .DA (4'h0), .DB (len_cnt & {4{~initialize_memories}}), .QA (length_info), .QB (), .OENA (1'b0), .OENB (1'b1), .WENA (1'b1), .WENB (~(write_length_info & (~info_full) | initialize_memories)) ); `endif always @ (posedge clk) begin if (write_length_info & (~info_full) | initialize_memories) overrun_info[wr_info_pointer] <=#Tp (latch_overrun | (wr & fifo_full)) & (~initialize_memories); end assign overrun = overrun_info[rd_info_pointer]; `else always @ (posedge clk) begin if (wr & (~fifo_full)) fifo[wr_pointer] <=#Tp data_in; end assign data_out = fifo[read_address]; always @ (posedge clk) begin if (write_length_info & (~info_full) | initialize_memories) length_fifo[wr_info_pointer] <=#Tp len_cnt & {4{~initialize_memories}}; end assign length_info = length_fifo[rd_info_pointer]; always @ (posedge clk) begin if (write_length_info & (~info_full) | initialize_memories) overrun_info[wr_info_pointer] <=#Tp (latch_overrun | (wr & fifo_full)) & (~initialize_memories); end assign overrun = overrun_info[rd_info_pointer]; `endif `endif `endif `endif `endif endmodule"
    },
    {
        "file_name": "can_ibo.v",
        "verilog_design": "module can_ibo ( di, do_can ); input [7:0] di; output [7:0] do_can; assign do_can[0] = di[7]; assign do_can[1] = di[6]; assign do_can[2] = di[5]; assign do_can[3] = di[4]; assign do_can[4] = di[3]; assign do_can[5] = di[2]; assign do_can[6] = di[1]; assign do_can[7] = di[0]; endmodule"
    },
    {
        "file_name": "can_register_asyn.v",
        "verilog_design": "`include \"timescale.v\" module can_register_asyn ( data_in, data_out, we, clk, rst ); parameter WIDTH = 8; parameter RESET_VALUE = 0; input [WIDTH-1:0] data_in; input we; input clk; input rst; output [WIDTH-1:0] data_out; reg [WIDTH-1:0] data_out; always @ (posedge clk or posedge rst) begin if (rst) data_out<=#1 RESET_VALUE; else if (we) data_out<=#1 data_in; end endmodule"
    },
    {
        "file_name": "can_register_asyn_syn.v",
        "verilog_design": "`include \"timescale.v\" module can_register_asyn_syn ( data_in, data_out, we, clk, rst, rst_sync ); parameter WIDTH = 8; parameter RESET_VALUE = 0; input [WIDTH-1:0] data_in; input we; input clk; input rst; input rst_sync; output [WIDTH-1:0] data_out; reg [WIDTH-1:0] data_out; always @ (posedge clk or posedge rst) begin if(rst) data_out<=#1 RESET_VALUE; else if (rst_sync) data_out<=#1 RESET_VALUE; else if (we) data_out<=#1 data_in; end endmodule"
    },
    {
        "file_name": "can_register.v",
        "verilog_design": "`include \"timescale.v\" module can_register ( data_in, data_out, we, clk ); parameter WIDTH = 8; input [WIDTH-1:0] data_in; input we; input clk; output [WIDTH-1:0] data_out; reg [WIDTH-1:0] data_out; always @ (posedge clk) begin if (we) data_out<=#1 data_in; end endmodule"
    },
    {
        "file_name": "can_register_syn.v",
        "verilog_design": "`include \"timescale.v\" module can_register_syn ( data_in, data_out, we, clk, rst_sync ); parameter WIDTH = 8; parameter RESET_VALUE = 0; input [WIDTH-1:0] data_in; input we; input clk; input rst_sync; output [WIDTH-1:0] data_out; reg [WIDTH-1:0] data_out; always @ (posedge clk) begin if (rst_sync) data_out<=#1 RESET_VALUE; else if (we) data_out<=#1 data_in; end endmodule"
    },
    {
        "file_name": "can_acf.v",
        "verilog_design": "`include \"timescale.v\" `include \"can_defines.v\" module can_acf ( clk, rst, id, reset_mode, acceptance_filter_mode, extended_mode, acceptance_code_0, acceptance_code_1, acceptance_code_2, acceptance_code_3, acceptance_mask_0, acceptance_mask_1, acceptance_mask_2, acceptance_mask_3, go_rx_crc_lim, go_rx_inter, go_error_frame, data0, data1, rtr1, rtr2, ide, no_byte0, no_byte1, id_ok ); parameter Tp = 1; input clk; input rst; input [28:0] id; input reset_mode; input acceptance_filter_mode; input extended_mode; input [7:0] acceptance_code_0; input [7:0] acceptance_code_1; input [7:0] acceptance_code_2; input [7:0] acceptance_code_3; input [7:0] acceptance_mask_0; input [7:0] acceptance_mask_1; input [7:0] acceptance_mask_2; input [7:0] acceptance_mask_3; input go_rx_crc_lim; input go_rx_inter; input go_error_frame; input [7:0] data0; input [7:0] data1; input rtr1; input rtr2; input ide; input no_byte0; input no_byte1; output id_ok; reg id_ok; wire match; wire match_sf_std; wire match_sf_ext; wire match_df_std; wire match_df_ext; assign match = ( (id[3] == acceptance_code_0[0] | acceptance_mask_0[0] ) & (id[4] == acceptance_code_0[1] | acceptance_mask_0[1] ) & (id[5] == acceptance_code_0[2] | acceptance_mask_0[2] ) & (id[6] == acceptance_code_0[3] | acceptance_mask_0[3] ) & (id[7] == acceptance_code_0[4] | acceptance_mask_0[4] ) & (id[8] == acceptance_code_0[5] | acceptance_mask_0[5] ) & (id[9] == acceptance_code_0[6] | acceptance_mask_0[6] ) & (id[10] == acceptance_code_0[7] | acceptance_mask_0[7] ) ); assign match_sf_std = ( (id[3] == acceptance_code_0[0] | acceptance_mask_0[0] ) & (id[4] == acceptance_code_0[1] | acceptance_mask_0[1] ) & (id[5] == acceptance_code_0[2] | acceptance_mask_0[2] ) & (id[6] == acceptance_code_0[3] | acceptance_mask_0[3] ) & (id[7] == acceptance_code_0[4] | acceptance_mask_0[4] ) & (id[8] == acceptance_code_0[5] | acceptance_mask_0[5] ) & (id[9] == acceptance_code_0[6] | acceptance_mask_0[6] ) & (id[10] == acceptance_code_0[7] | acceptance_mask_0[7] ) & (rtr1 == acceptance_code_1[4] | acceptance_mask_1[4] ) & (id[0] == acceptance_code_1[5] | acceptance_mask_1[5] ) & (id[1] == acceptance_code_1[6] | acceptance_mask_1[6] ) & (id[2] == acceptance_code_1[7] | acceptance_mask_1[7] ) & (data0[0] == acceptance_code_2[0] | acceptance_mask_2[0] | no_byte0) & (data0[1] == acceptance_code_2[1] | acceptance_mask_2[1] | no_byte0) & (data0[2] == acceptance_code_2[2] | acceptance_mask_2[2] | no_byte0) & (data0[3] == acceptance_code_2[3] | acceptance_mask_2[3] | no_byte0) & (data0[4] == acceptance_code_2[4] | acceptance_mask_2[4] | no_byte0) & (data0[5] == acceptance_code_2[5] | acceptance_mask_2[5] | no_byte0) & (data0[6] == acceptance_code_2[6] | acceptance_mask_2[6] | no_byte0) & (data0[7] == acceptance_code_2[7] | acceptance_mask_2[7] | no_byte0) & (data1[0] == acceptance_code_3[0] | acceptance_mask_3[0] | no_byte1) & (data1[1] == acceptance_code_3[1] | acceptance_mask_3[1] | no_byte1) & (data1[2] == acceptance_code_3[2] | acceptance_mask_3[2] | no_byte1) & (data1[3] == acceptance_code_3[3] | acceptance_mask_3[3] | no_byte1) & (data1[4] == acceptance_code_3[4] | acceptance_mask_3[4] | no_byte1) & (data1[5] == acceptance_code_3[5] | acceptance_mask_3[5] | no_byte1) & (data1[6] == acceptance_code_3[6] | acceptance_mask_3[6] | no_byte1) & (data1[7] == acceptance_code_3[7] | acceptance_mask_3[7] | no_byte1) ); assign match_sf_ext = ( (id[21] == acceptance_code_0[0] | acceptance_mask_0[0] ) & (id[22] == acceptance_code_0[1] | acceptance_mask_0[1] ) & (id[23] == acceptance_code_0[2] | acceptance_mask_0[2] ) & (id[24] == acceptance_code_0[3] | acceptance_mask_0[3] ) & (id[25] == acceptance_code_0[4] | acceptance_mask_0[4] ) & (id[26] == acceptance_code_0[5] | acceptance_mask_0[5] ) & (id[27] == acceptance_code_0[6] | acceptance_mask_0[6] ) & (id[28] == acceptance_code_0[7] | acceptance_mask_0[7] ) & (id[13] == acceptance_code_1[0] | acceptance_mask_1[0] ) & (id[14] == acceptance_code_1[1] | acceptance_mask_1[1] ) & (id[15] == acceptance_code_1[2] | acceptance_mask_1[2] ) & (id[16] == acceptance_code_1[3] | acceptance_mask_1[3] ) & (id[17] == acceptance_code_1[4] | acceptance_mask_1[4] ) & (id[18] == acceptance_code_1[5] | acceptance_mask_1[5] ) & (id[19] == acceptance_code_1[6] | acceptance_mask_1[6] ) & (id[20] == acceptance_code_1[7] | acceptance_mask_1[7] ) & (id[5] == acceptance_code_2[0] | acceptance_mask_2[0] ) & (id[6] == acceptance_code_2[1] | acceptance_mask_2[1] ) & (id[7] == acceptance_code_2[2] | acceptance_mask_2[2] ) & (id[8] == acceptance_code_2[3] | acceptance_mask_2[3] ) & (id[9] == acceptance_code_2[4] | acceptance_mask_2[4] ) & (id[10] == acceptance_code_2[5] | acceptance_mask_2[5] ) & (id[11] == acceptance_code_2[6] | acceptance_mask_2[6] ) & (id[12] == acceptance_code_2[7] | acceptance_mask_2[7] ) & (rtr2 == acceptance_code_3[2] | acceptance_mask_3[2] ) & (id[0] == acceptance_code_3[3] | acceptance_mask_3[3] ) & (id[1] == acceptance_code_3[4] | acceptance_mask_3[4] ) & (id[2] == acceptance_code_3[5] | acceptance_mask_3[5] ) & (id[3] == acceptance_code_3[6] | acceptance_mask_3[6] ) & (id[4] == acceptance_code_3[7] | acceptance_mask_3[7] ) ); assign match_df_std = (((id[3] == acceptance_code_0[0] | acceptance_mask_0[0] ) & (id[4] == acceptance_code_0[1] | acceptance_mask_0[1] ) & (id[5] == acceptance_code_0[2] | acceptance_mask_0[2] ) & (id[6] == acceptance_code_0[3] | acceptance_mask_0[3] ) & (id[7] == acceptance_code_0[4] | acceptance_mask_0[4] ) & (id[8] == acceptance_code_0[5] | acceptance_mask_0[5] ) & (id[9] == acceptance_code_0[6] | acceptance_mask_0[6] ) & (id[10] == acceptance_code_0[7] | acceptance_mask_0[7] ) & (rtr1 == acceptance_code_1[4] | acceptance_mask_1[4] ) & (id[0] == acceptance_code_1[5] | acceptance_mask_1[5] ) & (id[1] == acceptance_code_1[6] | acceptance_mask_1[6] ) & (id[2] == acceptance_code_1[7] | acceptance_mask_1[7] ) & (data0[0] == acceptance_code_3[0] | acceptance_mask_3[0] | no_byte0) & (data0[1] == acceptance_code_3[1] | acceptance_mask_3[1] | no_byte0) & (data0[2] == acceptance_code_3[2] | acceptance_mask_3[2] | no_byte0) & (data0[3] == acceptance_code_3[3] | acceptance_mask_3[3] | no_byte0) & (data0[4] == acceptance_code_1[0] | acceptance_mask_1[0] | no_byte0) & (data0[5] == acceptance_code_1[1] | acceptance_mask_1[1] | no_byte0) & (data0[6] == acceptance_code_1[2] | acceptance_mask_1[2] | no_byte0) & (data0[7] == acceptance_code_1[3] | acceptance_mask_1[3] | no_byte0) ) | ((id[3] == acceptance_code_2[0] | acceptance_mask_2[0] ) & (id[4] == acceptance_code_2[1] | acceptance_mask_2[1] ) & (id[5] == acceptance_code_2[2] | acceptance_mask_2[2] ) & (id[6] == acceptance_code_2[3] | acceptance_mask_2[3] ) & (id[7] == acceptance_code_2[4] | acceptance_mask_2[4] ) & (id[8] == acceptance_code_2[5] | acceptance_mask_2[5] ) & (id[9] == acceptance_code_2[6] | acceptance_mask_2[6] ) & (id[10] == acceptance_code_2[7] | acceptance_mask_2[7] ) & (rtr1 == acceptance_code_3[4] | acceptance_mask_3[4] ) & (id[0] == acceptance_code_3[5] | acceptance_mask_3[5] ) & (id[1] == acceptance_code_3[6] | acceptance_mask_3[6] ) & (id[2] == acceptance_code_3[7] | acceptance_mask_3[7] ) ) ); assign match_df_ext = (((id[21] == acceptance_code_0[0] | acceptance_mask_0[0] ) & (id[22] == acceptance_code_0[1] | acceptance_mask_0[1] ) & (id[23] == acceptance_code_0[2] | acceptance_mask_0[2] ) & (id[24] == acceptance_code_0[3] | acceptance_mask_0[3] ) & (id[25] == acceptance_code_0[4] | acceptance_mask_0[4] ) & (id[26] == acceptance_code_0[5] | acceptance_mask_0[5] ) & (id[27] == acceptance_code_0[6] | acceptance_mask_0[6] ) & (id[28] == acceptance_code_0[7] | acceptance_mask_0[7] ) & (id[13] == acceptance_code_1[0] | acceptance_mask_1[0] ) & (id[14] == acceptance_code_1[1] | acceptance_mask_1[1] ) & (id[15] == acceptance_code_1[2] | acceptance_mask_1[2] ) & (id[16] == acceptance_code_1[3] | acceptance_mask_1[3] ) & (id[17] == acceptance_code_1[4] | acceptance_mask_1[4] ) & (id[18] == acceptance_code_1[5] | acceptance_mask_1[5] ) & (id[19] == acceptance_code_1[6] | acceptance_mask_1[6] ) & (id[20] == acceptance_code_1[7] | acceptance_mask_1[7] ) ) | ((id[21] == acceptance_code_2[0] | acceptance_mask_2[0] ) & (id[22] == acceptance_code_2[1] | acceptance_mask_2[1] ) & (id[23] == acceptance_code_2[2] | acceptance_mask_2[2] ) & (id[24] == acceptance_code_2[3] | acceptance_mask_2[3] ) & (id[25] == acceptance_code_2[4] | acceptance_mask_2[4] ) & (id[26] == acceptance_code_2[5] | acceptance_mask_2[5] ) & (id[27] == acceptance_code_2[6] | acceptance_mask_2[6] ) & (id[28] == acceptance_code_2[7] | acceptance_mask_2[7] ) & (id[13] == acceptance_code_3[0] | acceptance_mask_3[0] ) & (id[14] == acceptance_code_3[1] | acceptance_mask_3[1] ) & (id[15] == acceptance_code_3[2] | acceptance_mask_3[2] ) & (id[16] == acceptance_code_3[3] | acceptance_mask_3[3] ) & (id[17] == acceptance_code_3[4] | acceptance_mask_3[4] ) & (id[18] == acceptance_code_3[5] | acceptance_mask_3[5] ) & (id[19] == acceptance_code_3[6] | acceptance_mask_3[6] ) & (id[20] == acceptance_code_3[7] | acceptance_mask_3[7] ) ) ); always @ (posedge clk or posedge rst) begin if (rst) id_ok <= 1'b0; else if (go_rx_crc_lim) begin if (extended_mode) begin if (~acceptance_filter_mode) begin if (ide) id_ok <=#Tp match_df_ext; else id_ok <=#Tp match_df_std; end else begin if (ide) id_ok <=#Tp match_sf_ext; else id_ok <=#Tp match_sf_std; end end else id_ok <=#Tp match; end else if (reset_mode | go_rx_inter | go_error_frame) id_ok <=#Tp 1'b0; end endmodule"
    },
    {
        "file_name": "eth_fifo.v",
        "verilog_design": "`include \"ethmac_defines.v\" `include \"timescale.v\" module eth_fifo (data_in, data_out, clk, reset, write, read, clear, almost_full, full, almost_empty, empty, cnt); parameter DATA_WIDTH = 32; parameter DEPTH = 8; parameter CNT_WIDTH = 4; input clk; input reset; input write; input read; input clear; input [DATA_WIDTH-1:0] data_in; output [DATA_WIDTH-1:0] data_out; output almost_full; output full; output almost_empty; output empty; output [CNT_WIDTH-1:0] cnt; `ifdef ETH_FIFO_XILINX `else `ifdef ETH_ALTERA_ALTSYNCRAM `else reg [DATA_WIDTH-1:0] fifo [0:DEPTH-1]; reg [DATA_WIDTH-1:0] data_out; `endif `endif reg [CNT_WIDTH-1:0] cnt; reg [CNT_WIDTH-2:0] read_pointer; reg [CNT_WIDTH-2:0] write_pointer; always @ (posedge clk or posedge reset) begin if(reset) cnt <= 0; else if(clear) cnt <= { {(CNT_WIDTH-1){1'b0}}, read^write}; else if(read ^ write) if(read) cnt <= cnt - 1; else cnt <= cnt + 1; end always @ (posedge clk or posedge reset) begin if(reset) read_pointer <= 0; else if(clear) read_pointer <= { {(CNT_WIDTH-2){1'b0}}, read}; else if(read & ~empty) read_pointer <= read_pointer + 1'b1; end always @ (posedge clk or posedge reset) begin if(reset) write_pointer <= 0; else if(clear) write_pointer <= { {(CNT_WIDTH-2){1'b0}}, write}; else if(write & ~full) write_pointer <= write_pointer + 1'b1; end assign empty = ~(|cnt); assign almost_empty = cnt == 1; assign full = cnt == DEPTH; assign almost_full = &cnt[CNT_WIDTH-2:0]; `ifdef ETH_FIFO_XILINX xilinx_dist_ram_16x32 fifo ( .data_out(data_out), .we(write & ~full), .data_in(data_in), .read_address( clear ? {CNT_WIDTH-1{1'b0}} : read_pointer), .write_address(clear ? {CNT_WIDTH-1{1'b0}} : write_pointer), .wclk(clk) ); `else `ifdef ETH_ALTERA_ALTSYNCRAM altera_dpram_16x32 altera_dpram_16x32_inst ( .data (data_in), .wren (write & ~full), .wraddress (clear ? {CNT_WIDTH-1{1'b0}} : write_pointer), .rdaddress (clear ? {CNT_WIDTH-1{1'b0}} : read_pointer ), .clock (clk), .q (data_out) ); `else always @ (posedge clk) begin if(write & clear) fifo[0] <= data_in; else if(write & ~full) fifo[write_pointer] <= data_in; end always @ (posedge clk) begin if(clear) data_out <= fifo[0]; else data_out <= fifo[read_pointer]; end `endif `endif endmodule"
    },
    {
        "file_name": "Phy_int.v",
        "verilog_design": "module Phy_int ( Reset , MAC_rx_clk , MAC_tx_clk , MCrs_dv , MRxD , MRxErr , MTxD , MTxEn , MCRS , Tx_er , Tx_en , Txd , Rx_er , Rx_dv , Rxd , Crs , Col , Line_loop_en , Speed ); input Reset ; input MAC_rx_clk ; input MAC_tx_clk ; output MCrs_dv ; output [7:0] MRxD ; output MRxErr ; input [7:0] MTxD ; input MTxEn ; output MCRS ; output Tx_er ; output Tx_en ; output [7:0] Txd ; input Rx_er ; input Rx_dv ; input [7:0] Rxd ; input Crs ; input Col ; input Line_loop_en ; input [2:0] Speed ; reg [7:0] MTxD_dl1 ; reg MTxEn_dl1 ; reg Tx_odd_data_ptr ; reg Rx_odd_data_ptr ; reg Tx_en ; reg [7:0] Txd ; reg MCrs_dv ; reg [7:0] MRxD ; reg Rx_er_dl1 ; reg Rx_dv_dl1 ; reg Rx_dv_dl2 ; reg [7:0] Rxd_dl1 ; reg [7:0] Rxd_dl2 ; reg Crs_dl1 ; reg Col_dl1 ; always @ (posedge MAC_tx_clk or posedge Reset) if (Reset) begin MTxD_dl1 <=0; MTxEn_dl1 <=0; end else begin MTxD_dl1 <=MTxD ; MTxEn_dl1 <=MTxEn ; end always @ (posedge MAC_tx_clk or posedge Reset) if (Reset) Tx_odd_data_ptr <=0; else if (!MTxD_dl1) Tx_odd_data_ptr <=0; else Tx_odd_data_ptr <=!Tx_odd_data_ptr; always @ (posedge MAC_tx_clk or posedge Reset) if (Reset) Txd <=0; else if(Speed[2]&&MTxEn_dl1) Txd <=MTxD_dl1; else if(MTxEn_dl1&&!Tx_odd_data_ptr) Txd <={4'b0,MTxD_dl1[3:0]}; else if(MTxEn_dl1&&Tx_odd_data_ptr) Txd <={4'b0,MTxD_dl1[7:4]}; else Txd <=0; always @ (posedge MAC_tx_clk or posedge Reset) if (Reset) Tx_en <=0; else if(MTxEn_dl1) Tx_en <=1; else Tx_en <=0; assign Tx_er=0; always @ (posedge MAC_rx_clk or posedge Reset) if (Reset) begin Rx_er_dl1 <=0; Rx_dv_dl1 <=0; Rx_dv_dl2 <=0 ; Rxd_dl1 <=0; Rxd_dl2 <=0; Crs_dl1 <=0; Col_dl1 <=0; end else begin Rx_er_dl1 <=Rx_er ; Rx_dv_dl1 <=Rx_dv ; Rx_dv_dl2 <=Rx_dv_dl1 ; Rxd_dl1 <=Rxd ; Rxd_dl2 <=Rxd_dl1 ; Crs_dl1 <=Crs ; Col_dl1 <=Col ; end assign MRxErr =Rx_er_dl1 ; assign MCRS =Crs_dl1 ; always @ (posedge MAC_rx_clk or posedge Reset) if (Reset) MCrs_dv <=0; else if(Line_loop_en) MCrs_dv <=Tx_en; else if(Rx_dv_dl2) MCrs_dv <=1; else MCrs_dv <=0; always @ (posedge MAC_rx_clk or posedge Reset) if (Reset) Rx_odd_data_ptr <=0; else if (!Rx_dv_dl1) Rx_odd_data_ptr <=0; else Rx_odd_data_ptr <=!Rx_odd_data_ptr; always @ (posedge MAC_rx_clk or posedge Reset) if (Reset) MRxD <=0; else if(Line_loop_en) MRxD <=Txd; else if(Speed[2]&&Rx_dv_dl2) MRxD <=Rxd_dl2; else if(Rx_dv_dl1&&Rx_odd_data_ptr) MRxD <={Rxd_dl1[3:0],Rxd_dl2[3:0]}; endmodule"
    },
    {
        "file_name": "fpu_add.v",
        "verilog_design": "`timescale 1ns / 100ps module fpu_add( clk, rst, enable, opa, opb, sign, sum_2, exponent_2); input clk; input rst; input enable; input [63:0] opa, opb; output sign; output [55:0] sum_2; output [10:0] exponent_2; reg sign; reg [10:0] exponent_a; reg [10:0] exponent_b; reg [51:0] mantissa_a; reg [51:0] mantissa_b; reg expa_gt_expb; reg [10:0] exponent_small; reg [10:0] exponent_large; reg [51:0] mantissa_small; reg [51:0] mantissa_large; reg small_is_denorm; reg large_is_denorm; reg large_norm_small_denorm; reg [10:0] exponent_diff; reg [55:0] large_add; reg [55:0] small_add; reg [55:0] small_shift; wire small_shift_nonzero = |small_shift[55:0]; wire small_is_nonzero = (exponent_small > 0) | |mantissa_small[51:0]; wire small_fraction_enable = small_is_nonzero & !small_shift_nonzero; wire [55:0] small_shift_2 = { 55'b0, 1'b1 }; reg [55:0] small_shift_3; reg [55:0] sum; wire sum_overflow = sum[55]; reg [55:0] sum_2; reg [10:0] exponent; wire sum_leading_one = sum_2[54]; reg denorm_to_norm; reg [10:0] exponent_2; always @(posedge clk) begin if (rst) begin sign <= 0; exponent_a <= 0; exponent_b <= 0; mantissa_a <= 0; mantissa_b <= 0; expa_gt_expb <= 0; exponent_small <= 0; exponent_large <= 0; mantissa_small <= 0; mantissa_large <= 0; small_is_denorm <= 0; large_is_denorm <= 0; large_norm_small_denorm <= 0; exponent_diff <= 0; large_add <= 0; small_add <= 0; small_shift <= 0; small_shift_3 <= 0; sum <= 0; sum_2 <= 0; exponent <= 0; denorm_to_norm <= 0; exponent_2 <= 0; end else if (enable) begin sign <= opa[63]; exponent_a <= opa[62:52]; exponent_b <= opb[62:52]; mantissa_a <= opa[51:0]; mantissa_b <= opb[51:0]; expa_gt_expb <= exponent_a > exponent_b; exponent_small <= expa_gt_expb ? exponent_b : exponent_a; exponent_large <= expa_gt_expb ? exponent_a : exponent_b; mantissa_small <= expa_gt_expb ? mantissa_b : mantissa_a; mantissa_large <= expa_gt_expb ? mantissa_a : mantissa_b; small_is_denorm <= !(exponent_small > 0); large_is_denorm <= !(exponent_large > 0); large_norm_small_denorm <= (small_is_denorm && !large_is_denorm); exponent_diff <= exponent_large - exponent_small - large_norm_small_denorm; large_add <= { 1'b0, !large_is_denorm, mantissa_large, 2'b0 }; small_add <= { 1'b0, !small_is_denorm, mantissa_small, 2'b0 }; small_shift <= small_add >> exponent_diff; small_shift_3 <= small_fraction_enable ? small_shift_2 : small_shift; sum <= large_add + small_shift_3; sum_2 <= sum_overflow ? sum >> 1 : sum; exponent <= sum_overflow ? exponent_large + 1: exponent_large; denorm_to_norm <= sum_leading_one & large_is_denorm; exponent_2 <= denorm_to_norm ? exponent + 1 : exponent; end end endmodule"
    },
    {
        "file_name": "control_unit.v",
        "verilog_design": "module control_unit ( output reg [ 2:0] sbox_sel, output reg [ 1:0] rk_sel, output reg [ 1:0] key_out_sel, output reg [ 1:0] col_sel, output reg [ 3:0] key_en, output reg [ 3:0] col_en, output [ 3:0] round, output reg bypass_rk, output reg bypass_key_en, output reg key_sel, output reg iv_cnt_en, output reg iv_cnt_sel, output reg key_derivation_en, output end_comp, output key_init, output key_gen, output mode_ctr, output mode_cbc, output last_round, output encrypt_decrypt, input [1:0] operation_mode, input [1:0] aes_mode, input start, input disable_core, input clk, input rst_n ); localparam AES_CR = 4'd00; localparam AES_SR = 4'd01; localparam AES_DINR = 4'd02; localparam AES_DOUTR = 4'd03; localparam AES_KEYR0 = 4'd04; localparam AES_KEYR1 = 4'd05; localparam AES_KEYR2 = 4'd06; localparam AES_KEYR3 = 4'd07; localparam AES_IVR0 = 4'd08; localparam AES_IVR1 = 4'd09; localparam AES_IVR2 = 4'd10; localparam AES_IVR3 = 4'd11; localparam ENCRYPTION = 2'b00; localparam KEY_DERIVATION = 2'b01; localparam DECRYPTION = 2'b10; localparam DECRYP_W_DERIV = 2'b11; localparam ECB = 2'b00; localparam CBC = 2'b01; localparam CTR = 2'b10; localparam COL_0 = 3'b000; localparam COL_1 = 3'b001; localparam COL_2 = 3'b010; localparam COL_3 = 3'b011; localparam G_FUNCTION = 3'b100; localparam COL = 2'b00; localparam MIXCOL_IN = 2'b01; localparam MIXCOL_OUT = 2'b10; localparam KEY_0 = 2'b00; localparam KEY_1 = 2'b01; localparam KEY_2 = 2'b10; localparam KEY_3 = 2'b11; localparam SHIFT_ROWS = 2'b00; localparam ADD_RK_OUT = 2'b01; localparam INPUT = 2'b10; localparam KEY_HOST = 1'b0; localparam KEY_OUT = 1'b1; localparam KEY_DIS = 4'b0000; localparam EN_KEY_0 = 4'b0001; localparam EN_KEY_1 = 4'b0010; localparam EN_KEY_2 = 4'b0100; localparam EN_KEY_3 = 4'b1000; localparam KEY_ALL = 4'b1111; localparam COL_DIS = 4'b0000; localparam EN_COL_0 = 4'b0001; localparam EN_COL_1 = 4'b0010; localparam EN_COL_2 = 4'b0100; localparam EN_COL_3 = 4'b1000; localparam COL_ALL = 4'b1111; localparam IV_CNT = 1'b1; localparam IV_BUS = 1'b0; localparam ENABLE = 1'b1; localparam DISABLE = 1'b0; localparam NUMBER_ROUND = 4'd10; localparam NUMBER_ROUND_INC = 4'd11; localparam INITIAL_ROUND = 4'd00; localparam IDLE = 4'd00; localparam ROUND0_COL0 = 4'd01; localparam ROUND0_COL1 = 4'd02; localparam ROUND0_COL2 = 4'd03; localparam ROUND0_COL3 = 4'd04; localparam ROUND_KEY0 = 4'd05; localparam ROUND_COL0 = 4'd06; localparam ROUND_COL1 = 4'd07; localparam ROUND_COL2 = 4'd08; localparam ROUND_COL3 = 4'd09; localparam READY = 4'd10; localparam GEN_KEY0 = 4'd11; localparam GEN_KEY1 = 4'd12; localparam GEN_KEY2 = 4'd13; localparam GEN_KEY3 = 4'd14; localparam NOP = 4'd15; reg [3:0] state, next_state; reg [3:0] rd_count; reg rd_count_en; wire op_key_derivation; wire first_round; wire [1:0] op_mode; wire enc_dec; always @(posedge clk or negedge rst_n) begin if(!rst_n) state <= IDLE; else if(disable_core) state <= IDLE; else state <= next_state; end assign encrypt_decrypt = (op_mode == ENCRYPTION || op_mode == KEY_DERIVATION || state == GEN_KEY0 || state == GEN_KEY1 ||state == GEN_KEY2 || state == GEN_KEY3 ); assign enc_dec = encrypt_decrypt | mode_ctr; assign key_gen = (state == ROUND_KEY0); assign op_key_derivation = (op_mode == KEY_DERIVATION); assign mode_ctr = (aes_mode == CTR); assign mode_cbc = (aes_mode == CBC); assign key_init = start; assign op_mode = (mode_ctr) ? ENCRYPTION : operation_mode; always @(*) begin next_state = state; case(state) IDLE: begin if(!start) next_state = IDLE; else case(op_mode) ENCRYPTION : next_state = ROUND0_COL0; DECRYPTION : next_state = ROUND0_COL3; KEY_DERIVATION: next_state = GEN_KEY0; DECRYP_W_DERIV: next_state = GEN_KEY0; default : next_state = IDLE; endcase end ROUND0_COL0: begin next_state = (enc_dec) ? ROUND0_COL1 : ROUND_KEY0; end ROUND0_COL1: begin next_state = (enc_dec) ? ROUND0_COL2 : ROUND0_COL0; end ROUND0_COL2: begin next_state = (enc_dec) ? ROUND0_COL3 : ROUND0_COL1; end ROUND0_COL3: begin next_state = (enc_dec) ? ROUND_KEY0 : ROUND0_COL2; end ROUND_KEY0 : begin if(!first_round) begin next_state = (last_round) ? READY : NOP; end else begin next_state = (enc_dec) ? ROUND_COL0 : ROUND_COL3; end end NOP : begin next_state = (enc_dec) ? ROUND_COL0 : ROUND_COL3; end ROUND_COL0 : begin next_state = (enc_dec) ? ROUND_COL1 : ROUND_KEY0; end ROUND_COL1 : begin next_state = (enc_dec) ? ROUND_COL2 : ROUND_COL0; end ROUND_COL2 : begin next_state = (enc_dec) ? ROUND_COL3 : ROUND_COL1; end ROUND_COL3 : begin if(last_round && enc_dec) next_state = READY; else next_state = (enc_dec) ? ROUND_KEY0 : ROUND_COL2; end GEN_KEY0 : begin next_state = GEN_KEY1; end GEN_KEY1 : begin next_state = GEN_KEY2; end GEN_KEY2 : begin next_state = GEN_KEY3; end GEN_KEY3 : begin if(last_round) next_state = (op_key_derivation) ? READY : ROUND0_COL3; else next_state = GEN_KEY0; end READY : begin next_state = IDLE; end endcase end assign end_comp = (state == READY)?ENABLE:DISABLE; always @(*) begin sbox_sel = COL_0; rk_sel = COL; bypass_rk = DISABLE; key_out_sel = KEY_0; col_sel = INPUT; key_sel = KEY_HOST; key_en = KEY_DIS; col_en = COL_DIS; rd_count_en = DISABLE; iv_cnt_en = DISABLE; iv_cnt_sel = IV_BUS; bypass_key_en = DISABLE; key_derivation_en = DISABLE; case(state) ROUND0_COL0: begin sbox_sel = COL_0; rk_sel = COL; bypass_rk = ENABLE; bypass_key_en = ENABLE; key_out_sel = KEY_0; col_sel = (enc_dec) ? ADD_RK_OUT : SHIFT_ROWS; col_en = (enc_dec) ? EN_COL_0 : COL_ALL; end ROUND0_COL1: begin sbox_sel = COL_1; rk_sel = COL; bypass_rk = ENABLE; bypass_key_en = ENABLE; key_out_sel = KEY_1; col_sel = ADD_RK_OUT; col_en = EN_COL_1; if(!enc_dec) begin key_sel = KEY_OUT; key_en = EN_KEY_1; end end ROUND0_COL2: begin sbox_sel = COL_2; rk_sel = COL; bypass_rk = ENABLE; bypass_key_en = ENABLE; key_out_sel = KEY_2; col_sel = ADD_RK_OUT; col_en = EN_COL_2; if(!enc_dec) begin key_sel = KEY_OUT; key_en = EN_KEY_2; end end ROUND0_COL3: begin sbox_sel = COL_3; rk_sel = COL; bypass_key_en = ENABLE; key_out_sel = KEY_3; col_sel = (enc_dec) ? SHIFT_ROWS : ADD_RK_OUT; col_en = (enc_dec) ? COL_ALL : EN_COL_3; bypass_rk = ENABLE; if(!enc_dec) begin key_sel = KEY_OUT; key_en = EN_KEY_3; end end ROUND_KEY0: begin sbox_sel = G_FUNCTION; key_sel = KEY_OUT; key_en = EN_KEY_0; rd_count_en = ENABLE; end ROUND_COL0: begin sbox_sel = COL_0; rk_sel = (last_round) ? MIXCOL_IN : MIXCOL_OUT; key_out_sel = KEY_0; key_sel = KEY_OUT; if(enc_dec) key_en = EN_KEY_1; if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round)) col_sel = INPUT; else begin if(!enc_dec) col_sel = (last_round) ? ADD_RK_OUT : SHIFT_ROWS; else col_sel = ADD_RK_OUT; end if(enc_dec) col_en = EN_COL_0; else col_en = (last_round) ? EN_COL_0 : COL_ALL; end ROUND_COL1: begin sbox_sel = COL_1; rk_sel = (last_round) ? MIXCOL_IN : MIXCOL_OUT; key_out_sel = KEY_1; key_sel = KEY_OUT; if(enc_dec) key_en = EN_KEY_2; else key_en = EN_KEY_1; if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round)) col_sel = INPUT; else col_sel = ADD_RK_OUT; col_en = EN_COL_1; end ROUND_COL2: begin sbox_sel = COL_2; rk_sel = (last_round) ? MIXCOL_IN : MIXCOL_OUT; key_out_sel = KEY_2; key_sel = KEY_OUT; if(enc_dec) key_en = EN_KEY_3; else key_en = EN_KEY_2; if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round)) col_sel = INPUT; else col_sel = ADD_RK_OUT; col_en = EN_COL_2; end ROUND_COL3: begin sbox_sel = COL_3; rk_sel = (last_round) ? MIXCOL_IN : MIXCOL_OUT; key_out_sel = KEY_3; key_sel = KEY_OUT; if(!enc_dec) key_en = EN_KEY_3; if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round)) col_sel = INPUT; else begin if(enc_dec) col_sel = (last_round) ? ADD_RK_OUT : SHIFT_ROWS; else col_sel = ADD_RK_OUT; end if(enc_dec) col_en = (last_round) ? EN_COL_3 : COL_ALL; else col_en = EN_COL_3; if(mode_ctr && last_round) begin iv_cnt_en = ENABLE; iv_cnt_sel = IV_CNT; end end GEN_KEY0: begin sbox_sel = G_FUNCTION; rd_count_en = ENABLE; end GEN_KEY1: begin key_en = EN_KEY_1 | EN_KEY_0; key_sel = KEY_OUT; bypass_key_en = ENABLE; end GEN_KEY2: begin key_en = EN_KEY_2; key_sel = KEY_OUT; bypass_key_en = ENABLE; end GEN_KEY3: begin key_en = EN_KEY_3; key_sel = KEY_OUT; bypass_key_en = ENABLE; end READY: begin if(op_mode == KEY_DERIVATION) key_derivation_en = ENABLE; end endcase end always @(posedge clk or negedge rst_n) begin if(!rst_n) rd_count <= INITIAL_ROUND; else if(state == IDLE || (state == GEN_KEY3 && last_round)) rd_count <= INITIAL_ROUND; else if(rd_count_en) rd_count <= rd_count + 1'b1; end assign round = rd_count; assign first_round = (rd_count == INITIAL_ROUND); assign last_round = (rd_count == NUMBER_ROUND || rd_count == NUMBER_ROUND_INC); endmodule"
    },
    {
        "file_name": "phasecomparator.v",
        "verilog_design": "module phasecomparator(InputSignal, OutputSignal, MainClock, Lead, Lag); input InputSignal, OutputSignal; input MainClock; output Lead, Lag; reg [1:0] InputSignalEdgeDet; always @(posedge MainClock) begin InputSignalEdgeDet <= { InputSignalEdgeDet[0], InputSignal }; end wire InputSignalEdge = (InputSignalEdgeDet == 2'b01); reg Lead, Lag; always @(posedge MainClock) begin Lag <= ((InputSignalEdge == 1'b1) && (OutputSignal == 1'b0)); Lead <= ((InputSignalEdge == 1'b1) && (OutputSignal == 1'b1)); end endmodule"
    },
    {
        "file_name": "wptr_handler.v",
        "verilog_design": "module wptr_handler #(parameter PTR_WIDTH=3) ( input wclk, wrst_n, w_en, input [PTR_WIDTH:0] g_rptr_sync, output reg [PTR_WIDTH:0] b_wptr, g_wptr, output reg full ); wire [PTR_WIDTH:0] b_wptr_next; wire [PTR_WIDTH:0] g_wptr_next; reg wrap_around; wire wfull; assign b_wptr_next = b_wptr+(w_en & !full); assign g_wptr_next = (b_wptr_next >>1)^b_wptr_next; always@(posedge wclk or negedge wrst_n) begin if(!wrst_n) begin b_wptr <= 0; g_wptr <= 0; end else begin b_wptr <= b_wptr_next; g_wptr <= g_wptr_next; end end always@(posedge wclk or negedge wrst_n) begin if(!wrst_n) full <= 0; else full <= wfull; end assign wfull = (g_wptr_next == {~g_rptr_sync[PTR_WIDTH:PTR_WIDTH-1], g_rptr_sync[PTR_WIDTH-2:0]}); endmodule"
    },
    {
        "file_name": "rptr_handler.v",
        "verilog_design": "module rptr_handler #(parameter PTR_WIDTH=3) ( input rclk, rrst_n, r_en, input [PTR_WIDTH:0] g_wptr_sync, output reg [PTR_WIDTH:0] b_rptr, g_rptr, output reg empty ); wire [PTR_WIDTH:0] b_rptr_next; wire [PTR_WIDTH:0] g_rptr_next; assign b_rptr_next = b_rptr + (r_en & !empty); assign g_rptr_next = (b_rptr_next >>1)^b_rptr_next; assign rempty = (g_wptr_sync == g_rptr_next); always@(posedge rclk or negedge rrst_n) begin if(!rrst_n) begin b_rptr <= 0; g_rptr <= 0; end else begin b_rptr <= b_rptr_next; g_rptr <= g_rptr_next; end end always@(posedge rclk or negedge rrst_n) begin if(!rrst_n) empty <= 1; else empty <= rempty; end endmodule"
    },
    {
        "file_name": "synchronizer.v",
        "verilog_design": "module synchronizer #(parameter WIDTH=3) ( input clk, input rst_n, input [WIDTH:0] d_in, output reg [WIDTH:0] d_out); reg [WIDTH:0] q1; always@(posedge clk) begin if(!rst_n) begin q1 <= 0; d_out <= 0; end else begin q1 <= d_in; d_out <= q1; end end endmodule"
    },
    {
        "file_name": "fifo_mem.v",
        "verilog_design": "module fifo_mem #(parameter DEPTH=8, DATA_WIDTH=8, PTR_WIDTH=3) ( input wclk, w_en, rclk, r_en, input [PTR_WIDTH:0] b_wptr, b_rptr, input [DATA_WIDTH-1:0] data_in, input full, empty, output reg [DATA_WIDTH-1:0] data_out ); reg [DATA_WIDTH-1:0] fifo[0:DEPTH-1]; always@(posedge wclk) begin if(w_en & !full) begin fifo[b_wptr[PTR_WIDTH-1:0]] <= data_in; end end always@(posedge rclk) begin data_out <= fifo[b_rptr[PTR_WIDTH-1:0]]; end endmodule"
    },
    {
        "file_name": "MAC_tx_Ctrl.v",
        "verilog_design": "module MAC_tx_ctrl ( Reset , Clk , CRC_init , Frame_data , Data_en , CRC_rd , CRC_end , CRC_out , Random_init , RetryCnt , Random_time_meet , pause_apply , pause_quanta_sub , xoff_gen , xoff_gen_complete , xon_gen , xon_gen_complete , Fifo_data , Fifo_rd , Fifo_eop , Fifo_da , Fifo_rd_finish , Fifo_rd_retry , Fifo_ra , Fifo_data_err_empty , Fifo_data_err_full , TxD , TxEn , CRS , MAC_tx_addr_rd , MAC_tx_addr_data , MAC_tx_addr_init , Tx_pkt_type_rmon , Tx_pkt_length_rmon , Tx_apply_rmon , Tx_pkt_err_type_rmon, pause_frame_send_en , pause_quanta_set , MAC_tx_add_en , FullDuplex , MaxRetry , IFGset ); input Reset ; input Clk ; output CRC_init ; output [7:0] Frame_data ; output Data_en ; output CRC_rd ; input CRC_end ; input [7:0] CRC_out ; output Random_init ; output [3:0] RetryCnt ; input Random_time_meet ; input pause_apply ; output pause_quanta_sub ; input xoff_gen ; output xoff_gen_complete ; input xon_gen ; output xon_gen_complete ; input [7:0] Fifo_data ; output Fifo_rd ; input Fifo_eop ; input Fifo_da ; output Fifo_rd_finish ; output Fifo_rd_retry ; input Fifo_ra ; input Fifo_data_err_empty ; input Fifo_data_err_full ; output [7:0] TxD ; output TxEn ; input CRS ; output MAC_tx_addr_init ; output MAC_tx_addr_rd ; input [7:0] MAC_tx_addr_data ; output [2:0] Tx_pkt_type_rmon ; output [15:0] Tx_pkt_length_rmon ; output Tx_apply_rmon ; output [2:0] Tx_pkt_err_type_rmon; input pause_frame_send_en ; input [15:0] pause_quanta_set ; input MAC_tx_add_en ; input FullDuplex ; input [3:0] MaxRetry ; input [5:0] IFGset ; parameter StateIdle =4'd00; parameter StatePreamble =4'd01; parameter StateSFD =4'd02; parameter StateData =4'd03; parameter StatePause =4'd04; parameter StatePAD =4'd05; parameter StateFCS =4'd06; parameter StateIFG =4'd07; parameter StateJam =4'd08; parameter StateBackOff =4'd09; parameter StateJamDrop =4'd10; parameter StateFFEmptyDrop =4'd11; parameter StateSwitchNext =4'd12; parameter StateDefer =4'd13; parameter StateSendPauseFrame =4'd14; reg [3:0] Current_state ; reg [3:0] Next_state; reg [5:0] IFG_counter; reg [4:0] Preamble_counter; reg [7:0] TxD_tmp ; reg TxEn_tmp ; reg [15:0] Tx_pkt_length_rmon ; reg Tx_apply_rmon ; reg Tx_apply_rmon_tmp ; reg Tx_apply_rmon_tmp_pl1; reg [2:0] Tx_pkt_err_type_rmon; reg [3:0] RetryCnt ; reg Random_init ; reg Fifo_rd_finish ; reg Fifo_rd_retry ; reg [7:0] TxD ; reg TxEn ; reg CRC_init ; reg Data_en ; reg CRC_rd ; reg Fifo_rd ; reg MAC_tx_addr_rd ; reg MAC_header_slot ; reg MAC_header_slot_tmp ; reg [2:0] Tx_pkt_type_rmon ; wire Collision ; reg MAC_tx_addr_init ; reg Src_MAC_ptr ; reg [7:0] IPLengthCounter ; reg [1:0] PADCounter ; reg [7:0] JamCounter ; reg PktDrpEvenPtr ; reg [7:0] pause_counter ; reg pause_quanta_sub ; reg pause_frame_send_en_dl1 ; reg [15:0] pause_quanta_set_dl1 ; reg xoff_gen_complete ; reg xon_gen_complete ; always @(posedge Clk or posedge Reset) if (Reset) begin pause_frame_send_en_dl1 <=0; pause_quanta_set_dl1 <=0; end else begin pause_frame_send_en_dl1 <=pause_frame_send_en ; pause_quanta_set_dl1 <=pause_quanta_set ; end assign Collision=TxEn&CRS; always @(posedge Clk or posedge Reset) if (Reset) pause_counter <=0; else if (Current_state!=StatePause) pause_counter <=0; else pause_counter <=pause_counter+1; always @(posedge Clk or posedge Reset) if (Reset) IPLengthCounter <=0; else if (Current_state==StateDefer) IPLengthCounter <=0; else if (IPLengthCounter!=8'hff&&(Current_state==StateData||Current_state==StateSendPauseFrame||Current_state==StatePAD)) IPLengthCounter <=IPLengthCounter+1; always @(posedge Clk or posedge Reset) if (Reset) PADCounter <=0; else if (Current_state!=StatePAD) PADCounter <=0; else PADCounter <=PADCounter+1; always @(posedge Clk or posedge Reset) if (Reset) Current_state <=StateDefer; else Current_state <=Next_state; always @ (*) case (Current_state) StateDefer: if ((FullDuplex)||(!FullDuplex&&!CRS)) Next_state=StateIFG; else Next_state=Current_state; StateIFG: if (!FullDuplex&&CRS) Next_state=StateDefer; else if ((FullDuplex&&IFG_counter==IFGset-4)||(!FullDuplex&&!CRS&&IFG_counter==IFGset-4)) Next_state=StateIdle; else Next_state=Current_state; StateIdle: if (!FullDuplex&&CRS) Next_state=StateDefer; else if (pause_apply) Next_state=StatePause; else if ((FullDuplex&&Fifo_ra)||(!FullDuplex&&!CRS&&Fifo_ra)||(pause_frame_send_en_dl1&&(xoff_gen||xon_gen))) Next_state=StatePreamble; else Next_state=Current_state; StatePause: if (pause_counter==512/8) Next_state=StateDefer; else Next_state=Current_state; StatePreamble: if (!FullDuplex&&Collision) Next_state=StateJam; else if ((FullDuplex&&Preamble_counter==6)||(!FullDuplex&&!Collision&&Preamble_counter==6)) Next_state=StateSFD; else Next_state=Current_state; StateSFD: if (!FullDuplex&&Collision) Next_state=StateJam; else if (pause_frame_send_en_dl1&&(xoff_gen||xon_gen)) Next_state=StateSendPauseFrame; else Next_state=StateData; StateSendPauseFrame: if (IPLengthCounter==17) Next_state=StatePAD; else Next_state=Current_state; StateData: if (!FullDuplex&&Collision) Next_state=StateJam; else if (Fifo_data_err_empty) Next_state=StateFFEmptyDrop; else if (Fifo_eop&&IPLengthCounter>=59) Next_state=StateFCS; else if (Fifo_eop) Next_state=StatePAD; else Next_state=StateData; StatePAD: if (!FullDuplex&&Collision) Next_state=StateJam; else if (IPLengthCounter>=59) Next_state=StateFCS; else Next_state=Current_state; StateJam: if (RetryCnt<=MaxRetry&&JamCounter==16) Next_state=StateBackOff; else if (RetryCnt>MaxRetry) Next_state=StateJamDrop; else Next_state=Current_state; StateBackOff: if (Random_time_meet) Next_state =StateDefer; else Next_state =Current_state; StateFCS: if (!FullDuplex&&Collision) Next_state =StateJam; else if (CRC_end) Next_state =StateSwitchNext; else Next_state =Current_state; StateFFEmptyDrop: if (Fifo_eop) Next_state =StateSwitchNext; else Next_state =Current_state; StateJamDrop: if (Fifo_eop) Next_state =StateSwitchNext; else Next_state =Current_state; StateSwitchNext: Next_state =StateDefer; default: Next_state =StateDefer; endcase always @ (posedge Clk or posedge Reset) if (Reset) JamCounter <=0; else if (Current_state!=StateJam) JamCounter <=0; else if (Current_state==StateJam) JamCounter <=JamCounter+1; always @ (posedge Clk or posedge Reset) if (Reset) RetryCnt <=0; else if (Current_state==StateSwitchNext) RetryCnt <=0; else if (Current_state==StateJam&&Next_state==StateBackOff) RetryCnt <=RetryCnt + 1; always @ (posedge Clk or posedge Reset) if (Reset) IFG_counter <=0; else if (Current_state!=StateIFG) IFG_counter <=0; else IFG_counter <=IFG_counter + 1; always @ (posedge Clk or posedge Reset) if (Reset) Preamble_counter <=0; else if (Current_state!=StatePreamble) Preamble_counter <=0; else Preamble_counter <=Preamble_counter+ 1; always @ (posedge Clk or posedge Reset) if (Reset) PktDrpEvenPtr <=0; else if(Current_state==StateJamDrop||Current_state==StateFFEmptyDrop) PktDrpEvenPtr <=~PktDrpEvenPtr; always @(Current_state) if (Current_state==StateSFD) CRC_init =1; else CRC_init =0; assign Frame_data=TxD_tmp; always @(Current_state) if (Current_state==StateData||Current_state==StateSendPauseFrame||Current_state==StatePAD) Data_en =1; else Data_en =0; always @(Current_state) if (Current_state==StateFCS) CRC_rd =1; else CRC_rd =0; always @(Current_state or Next_state) if (Current_state==StateJam&&Next_state==StateBackOff) Random_init =1; else Random_init =0; always @ (*) if (Current_state==StateData || Current_state==StateSFD&&!(pause_frame_send_en_dl1&&(xoff_gen||xon_gen)) || Current_state==StateJamDrop&&PktDrpEvenPtr|| Current_state==StateFFEmptyDrop&&PktDrpEvenPtr ) Fifo_rd =1; else Fifo_rd =0; always @ (Current_state) if (Current_state==StateSwitchNext) Fifo_rd_finish =1; else Fifo_rd_finish =0; always @ (Current_state) if (Current_state==StateJam) Fifo_rd_retry =1; else Fifo_rd_retry =0; always @(Current_state) if (Current_state==StatePreamble||Current_state==StateSFD|| Current_state==StateData||Current_state==StateSendPauseFrame|| Current_state==StateFCS||Current_state==StatePAD||Current_state==StateJam) TxEn_tmp =1; else TxEn_tmp =0; always @(*) case (Current_state) StatePreamble: TxD_tmp =8'h55; StateSFD: TxD_tmp =8'hd5; StateData: if (Src_MAC_ptr&&MAC_tx_add_en) TxD_tmp =MAC_tx_addr_data; else TxD_tmp =Fifo_data; StateSendPauseFrame: if (Src_MAC_ptr&&MAC_tx_add_en) TxD_tmp =MAC_tx_addr_data; else case (IPLengthCounter) 7'd0: TxD_tmp =8'h01; 7'd1: TxD_tmp =8'h80; 7'd2: TxD_tmp =8'hc2; 7'd3: TxD_tmp =8'h00; 7'd4: TxD_tmp =8'h00; 7'd5: TxD_tmp =8'h01; 7'd12: TxD_tmp =8'h88; 7'd13: TxD_tmp =8'h08; 7'd14: TxD_tmp =8'h00; 7'd15: TxD_tmp =8'h01; 7'd16: TxD_tmp =xon_gen?8'b0:pause_quanta_set_dl1[15:8]; 7'd17: TxD_tmp =xon_gen?8'b0:pause_quanta_set_dl1[7:0]; default:TxD_tmp =0; endcase StatePAD: TxD_tmp =8'h00; StateJam: TxD_tmp =8'h01; StateFCS: TxD_tmp =CRC_out; default: TxD_tmp =2'b0; endcase always @ (posedge Clk or posedge Reset) if (Reset) begin TxD <=0; TxEn <=0; end else begin TxD <=TxD_tmp; TxEn <=TxEn_tmp; end always @ (posedge Clk or posedge Reset) if (Reset) Tx_pkt_length_rmon <=0; else if (Current_state==StateSFD) Tx_pkt_length_rmon <=0; else if (Current_state==StateData||Current_state==StateSendPauseFrame||Current_state==StatePAD||Current_state==StateFCS) Tx_pkt_length_rmon <=Tx_pkt_length_rmon+1; always @ (posedge Clk or posedge Reset) if (Reset) Tx_apply_rmon_tmp <=0; else if ((Fifo_eop&&Current_state==StateJamDrop)|| (Fifo_eop&&Current_state==StateFFEmptyDrop)|| CRC_end) Tx_apply_rmon_tmp <=1; else Tx_apply_rmon_tmp <=0; always @ (posedge Clk or posedge Reset) if (Reset) Tx_apply_rmon_tmp_pl1 <=0; else Tx_apply_rmon_tmp_pl1 <=Tx_apply_rmon_tmp; always @ (posedge Clk or posedge Reset) if (Reset) Tx_apply_rmon <=0; else if ((Fifo_eop&&Current_state==StateJamDrop)|| (Fifo_eop&&Current_state==StateFFEmptyDrop)|| CRC_end) Tx_apply_rmon <=1; else if (Tx_apply_rmon_tmp_pl1) Tx_apply_rmon <=0; always @ (posedge Clk or posedge Reset) if (Reset) Tx_pkt_err_type_rmon <=0; else if(Fifo_eop&&Current_state==StateJamDrop) Tx_pkt_err_type_rmon <=3'b001; else if(Fifo_eop&&Current_state==StateFFEmptyDrop) Tx_pkt_err_type_rmon <=3'b010; else if(Fifo_eop&&Fifo_data_err_full) Tx_pkt_err_type_rmon <=3'b011; else if(CRC_end) Tx_pkt_err_type_rmon <=3'b100; always @ (posedge Clk or posedge Reset) if (Reset) MAC_header_slot_tmp <=0; else if(Current_state==StateSFD&&Next_state==StateData) MAC_header_slot_tmp <=1; else MAC_header_slot_tmp <=0; always @ (posedge Clk or posedge Reset) if (Reset) MAC_header_slot <=0; else MAC_header_slot <=MAC_header_slot_tmp; always @ (posedge Clk or posedge Reset) if (Reset) Tx_pkt_type_rmon <=0; else if (Current_state==StateSendPauseFrame) Tx_pkt_type_rmon <=3'b100; else if(MAC_header_slot) Tx_pkt_type_rmon <={1'b0,TxD[7:6]}; always @(Tx_pkt_length_rmon) if (Tx_pkt_length_rmon>=6&&Tx_pkt_length_rmon<=11) Src_MAC_ptr =1; else Src_MAC_ptr =0; always @ (posedge Clk or posedge Reset) if (Reset) MAC_tx_addr_rd <=0; else if ((Tx_pkt_length_rmon>=4&&Tx_pkt_length_rmon<=9)&&(MAC_tx_add_en||Current_state==StateSendPauseFrame)) MAC_tx_addr_rd <=1; else MAC_tx_addr_rd <=0; always @ (Tx_pkt_length_rmon or Fifo_rd) if ((Tx_pkt_length_rmon==3)&&Fifo_rd) MAC_tx_addr_init=1; else MAC_tx_addr_init=0; always @ (posedge Clk or posedge Reset) if (Reset) pause_quanta_sub <=0; else if(pause_counter==512/8) pause_quanta_sub <=1; else pause_quanta_sub <=0; always @ (posedge Clk or posedge Reset) if (Reset) xoff_gen_complete <=0; else if(Current_state==StateDefer&&xoff_gen) xoff_gen_complete <=1; else xoff_gen_complete <=0; always @ (posedge Clk or posedge Reset) if (Reset) xon_gen_complete <=0; else if(Current_state==StateDefer&&xon_gen) xon_gen_complete <=1; else xon_gen_complete <=0; endmodule"
    }
]
