module i_fpu_exceptions(
input		[63:0]	out_1,
input		inexact_trigger,
input		subtract,
input	[1:0]	rmode,
input	[1:0]	mantissa_in,
input		in_et_zero,
input		sub_inf,
input		round_nearest,
input		[63:0]	out_0,
input	[10:0]  exp_2046 ,
input		inexact,
input		a_NaN,
input		[62:0]	inf_round_down,
input		opb_inf,
input		mul_inf,
input		div_inf,
input		clk,
input		overflow_trigger ,
input	[63:0]	in_except,
input		SNaN_trigger,
input		out_inf_trigger,
input	[63:0]	out,
input		overflow,
input		div_by_0,
input		opa_QNaN,
input	[63:0]	opb,
input		multiply,
input		[62:0] NaN_input_0, 
input		divide,
input		addsub_inf,
input		opb_SNaN,
input		addsub_inf_invalid,
input		rst,
input		opb_et_zero,
input		underflow_trigger,			
input		underflow,
input		div_by_inf,
input	[10:0]  exp_2047 ,
input		SNaN_input,
input		opb_pos_inf,
input		mul_0_by_inf,
input		enable,
input	[2:0]	fpu_op,
input		[63:0]	out_2,
input		add,
input		add_inf,
input		opa_neg_inf,
input	[63:0]	opa,
input		div_inf_by_inf,
input		out_neg_inf,
input		opa_pos_inf,
input		round_to_neg_inf,
input		invalid,
input		opa_et_zero,
input		round_to_pos_inf,
input		NaN_out_trigger,
input	[51:0]  mantissa_max ,
input		ex_enable,
input	[11:0]	exponent_in,
input		invalid_trigger,
input		[62:0]	out_inf,
input		opb_QNaN,
input		opa_SNaN,
input		opb_neg_inf,
input		exception,
input		enable_trigger,
input		div_uf,								
input		mul_uf,
input		round_to_zero,
input		input_et_zero,
input		out_pos_inf,
input		div_0_by_0,
input		opa_inf,
input		inf_round_down_trigger,
input	 	except_trigger,
input		[62:0] NaN_input ,
input           [62:0] NaN_output_0,
input           [62:0] NaN_output

);

assert property(@(posedge clk) (enable == 1) |-> (in_et_zero == !(|in_except[62:0]));
assert property(@(posedge clk) (enable == 1) |-> (opa_et_zero == !(|opa[62:0]));
assert property(@(posedge clk) (enable == 1) |-> (opb_et_zero == !(|opb[62:0]));
assert property(@(posedge clk) (enable == 1) |-> (input_et_zero == !(|in_except[62:0]));
assert property(@(posedge clk) (enable == 1) |-> (add == (fpu_op == 3'b000));
assert property(@(posedge clk) (enable == 1) |-> (subtract == (fpu_op == 3'b001));
assert property(@(posedge clk) (enable == 1) |-> (multiply == (fpu_op == 3'b010));
assert property(@(posedge clk) (enable == 1) |-> (divide == (fpu_op == 3'b011));
assert property(@(posedge clk) (enable == 1) |-> (opa_QNaN == ((opa[62:52] == 2047) & |opa[51:0] & opa[51]));
assert property(@(posedge clk) (enable == 1) |-> (opb_QNaN == ((opb[62:52] == 2047) & |opb[51:0] & opb[51]));
assert property(@(posedge clk) (enable == 1) |-> (opa_SNaN == ((opa[62:52] == 2047) & |opa[51:0] & !opa[51]));
assert property(@(posedge clk) (enable == 1) |-> (opb_SNaN == ((opb[62:52] == 2047) & |opb[51:0] & !opb[51]));
assert property(@(posedge clk) (enable == 1) |-> (opa_pos_inf == (!opa[63] & (opa[62:52] == 2047) & !(|opa[51:0])));
assert property(@(posedge clk) (enable == 1) |-> (opb_pos_inf == (!opb[63] & (opb[62:52] == 2047) & !(|opb[51:0])));
assert property(@(posedge clk) (enable == 1) |-> (opa_neg_inf == (opa[63] & (opa[62:52] == 2047) & !(|opa[51:0])));
assert property(@(posedge clk) (enable == 1) |-> (opb_neg_inf == (opb[63] & (opb[62:52] == 2047) & !(|opb[51:0])));
assert property(@(posedge clk) (enable == 1) |-> (opa_inf == ((opa[62:52] == 2047) & !(|opa[51:0])));
assert property(@(posedge clk) (enable == 1) |-> (opb_inf == ((opb[62:52] == 2047) & !(|opb[51:0])));
assert property(@(posedge clk) (enable == 1) |-> (NaN_input == (opa_QNaN | opb_QNaN | opa_SNaN | opb_SNaN));
assert property(@(posedge clk) (enable == 1) |-> (SNaN_input == (opa_SNaN | opb_SNaN));
assert property(@(posedge clk) (enable == 1) |-> (a_NaN == (opa_QNaN | opa_SNaN));
assert property(@(posedge clk) (enable == 1) |-> (div_by_0 == (divide & opb_et_zero & !opa_et_zero));
assert property(@(posedge clk) (enable == 1) |-> (div_0_by_0 == (divide & opb_et_zero & opa_et_zero));
assert property(@(posedge clk) (enable == 1) |-> (div_inf_by_inf == (divide & opa_inf & opb_inf));
assert property(@(posedge clk) (enable == 1) |-> (div_by_inf == (divide & !opa_inf & opb_inf));
assert property(@(posedge clk) (enable == 1) |-> (mul_0_by_inf == (multiply & ((opa_inf & opb_et_zero) | (opa_et_zero & opb_inf))));
assert property(@(posedge clk) (enable == 1) |-> (mul_inf == (multiply & (opa_inf | opb_inf) & !mul_0_by_inf));
assert property(@(posedge clk) (enable == 1
endmodule