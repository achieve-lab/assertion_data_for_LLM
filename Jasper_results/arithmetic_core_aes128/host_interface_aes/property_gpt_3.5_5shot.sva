module i_host_interface(
	input [31:0] col_bus,
input cnt_en,
input wr_err,
input first_block_set,
	input int_ccf,
	input col_rd_en,
	input [1:0] key_sel,
	input col_wr_en,
input [31:0] bus_out_mux,
	input [1:0] data_type,
input dma_in_en,
input enable,
	input [3:0] key_en,
input errc,
	input PWRITE,
	input [31:0] key_bus,
	input [31:0] PRDATA,
input [2:0] state, next_state,
	input [31:0] iv_bus,
	input [12:0] PWDATA,
input wr_err_en,
input ccf_ie,
	input [1:0] mode,
	input PCLK,
input enable_clear,
input aes_cr_wr_en,
input write_completed,
input [10:0] aes_cr,
input key_deriv,
	input start_core,
input [1:0] chmod_in,
	input dma_req_rd,
	input ccf_set,
input [1:0] mode_in,
input rd_err,
input ccf,
input dma_req,
	input PSEL,
	input [3:0] PADDR,
input read_en,
	input disable_core,
	input [3:0] iv_en,
input [31:0] bus_out,
input err_ie,
input access_permission,
	input [1:0] col_addr,
	input [3:0] iv_sel,
	input PENABLE,
input ccfc,
input read_completed,
	input dma_req_wr,
	input int_err,
	input [1:0] chmod,
input first_block_clear,
input dma_out_en,
input rd_err_en,
input [1:0] cnt,
	input PRESETn,
	input DEFAULT_CLOCK,
	input DEFAULT_RESET,
input write_en,
	input first_block
);

assert property @(posedge PCLK) (int_ccf && int_err) |-> disable_core == 1'b1;
assert property @(posedge PCLK) (PADDR == AES_CR && PENABLE && PWRITE && PWDATA[0] == 1'b1) |-> aes_cr[0] == 1'b1;
assert property @(posedge PCLK) (PADDR == AES_CR && PENABLE && PWRITE && PWDATA[0] == 1'b0) |-> aes_cr[0] == 1'b0;
assert property @(posedge PCLK) (PADDR == AES_CR && PENABLE && PWRITE && PWDATA[2:1] == 2'b00) |-> aes_cr[2:1] == 2'b00;
assert property @(posedge PCLK) (PADDR == AES_CR && PENABLE && PWRITE && PWDATA[2:1] == 2'b01 && PWDATA[6:5] == 2'b10) |-> aes_cr[4:3] == 2'b10;
assert property @(posedge PCLK) (PADDR == AES_CR && PENABLE && PWRITE && PWDATA[2:1] == 2'b01 && PWDATA[6:5] == 2'b01) |-> aes_cr[4:3] == 2'b01;
assert property @(posedge PCLK) (PADDR == AES_CR && PENABLE && PWRITE && PWDATA[2:1] == 2'b01 && PWDATA[6:5] == 2'b00) |-> aes_cr[4:3] == 2'b00;
assert property @(posedge PCLK) (PADDR == AES_CR && PENABLE && PWRITE && PWDATA[12:9] == 4'b0000) |-> aes_cr[10:7] == 4'b0000;
assert property @(posedge PCLK) (PADDR == AES_CR && PENABLE && PWRITE && PWDATA[12:9] == 4'b1111) |-> aes_cr[10:7] == 4'b1111;
assert property @(posedge PCLK) (PADDR == AES_DINR && write_en && cnt_en) |-> cnt == cnt + 1'b1;
assert property @(posedge PCLK) (PADDR == AES_DINR && write_en && cnt_en) |-> cnt == 2'b11;
assert property @(posedge PCLK) (PADDR == AES_DOUTR && read_en && PENABLE && read_completed) |-> cnt == 2'b11;
assert property @(posedge PCLK) (PADDR == AES_DOUTR && read_en && PENABLE && read_completed) |-> cnt == cnt + 1'b1;
assert property @(posedge PCLK) (PADDR == AES_DINR && write_en && state == INPUT) |-> col_wr_en == 1'b1;
assert property @(posedge PCLK) (PADDR == AES_DINR && write_en && state == INPUT) |-> col_wr_en == 1'b0;
assert property @(posedge PCLK) (PADDR == AES_DOUTR && read_en && state == OUTPUT) |-> col_rd_en == 1'b1;
assert property @(posedge PCLK) (PADDR == AES_DOUTR && read_en && state == OUTPUT) |-> col_rd_en == 1'b0;
assert property @(posedge PCLK) (PADDR == AES_DINR && write_en && (state != INPUT && state != IDLE)) |-> wr_err_en == 1'b1;
assert property @(posedge PCLK) (PADDR == AES_DINR && write_en && (state != INPUT && state != IDLE)) |-> wr_err_en == 1'b0;
assert property @(posedge PCLK) (!PRESETn) |-> dma_req == 1'b0;
assert property @(posedge PCLK) (!PRESETn) |-> dma_req == cnt[0];
assert property @(posedge PCLK) (dma_req_wr && enable && (state == INPUT || state == IDLE)) |-> dma_req == 1'b1;
assert property @(posedge PCLK) (dma_req_rd && enable && (state == OUTPUT)) |-> dma_req == 1'b1;
assert property @(posedge PCLK) (PADDR == AES_CR && write_en && PENABLE && PWDATA[4:3] == 2'b01 && PWDATA[6:5] == 2'b01 && enable && access_permission) |-> aes_cr[4:3] == 2'b01;
assert property @(posedge PCLK) (PADDR == AES_CR && write_en && PENABLE &&
endmodule