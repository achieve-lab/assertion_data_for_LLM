module i_eth_miim(
input           WCtrlData_q2,       // Write Control Data operation delayed 2 Clk cycles
input          LatchByte1_d2,
input          MdcEn,              // MII Management Data Clock Enable signal is asserted for one Clk period before Mdc rises.
input           LatchByte0_d,
input          StartOp,            // Start Operation (start of any of the preceding operations)
input           UpdateMIIRX_DATAReg,// Updates MII RX_DATA inputister with read data
input           WCtrlData_q3,       // Write Control Data operation delayed 3 Clk cycles
input           LatchByte1_d,
input           WCtrlDataStart_q1,  // Start Write Control Data Command delayed 1 Mdc cycle
input           InProgress,         // Operation in progress
input           EndBusy,            // End Busy signal (stops the operation in progress)
input        Busy,               // Busy Signal
input           WCtrlData_q1,       // Write Control Data operation delayed 1 Clk cycle
input           RStat_q1,           // Read Status operation delayed 1 Clk cycle
input          WriteDataOp,        // Write Data Operation (positive edge detected)
input   [4:0] Fiad,               // PHY Address
input   [7:0] Divider,            // Divider for the host clock
input          LatchByte0_d2,
input           InProgress_q2,      // Operation in progress delayed 2 Mdc cycles
input          MdcFrame,           // Frame window for limiting the Mdc
input         WCtrlData,          // Write Control Data operation
input           SyncStatMdcEn,      // Scan Status operation delayed at least cycles and synchronized to MdcEn
input           InProgress_q3,      // Operation in progress delayed 3 Mdc cycles
input           WCtrlDataStart_q2,  // Start Write Control Data Command delayed 2 Mdc cycles
input           RStatStart_q1,      // Start Read Status Command delayed 1 Mdc cycle
input        Nvalid,             // Invalid Status (qualifier for the valid scan result)
input         NoPre,              // No Preamble (no 32-bit preamble)
input          ReadStatusOp,       // Read Status Operation (positive edge detected)
input          ScanStatusOp,       // Scan Status Operation (positive edge detected)
input         Mdi,
input           ScanStat_q2,        // Scan Status operation delayed 2 cycles
input           RStat_q2,           // Read Status operation delayed 2 Clk cycles
input           WriteOp,            // Write Operation Latch (When asserted, write operation is in progress)
input        WCtrlDataStart,     // This signals resets the WCTRLDATA bit in the MIIM Command inputister
input  [15:0] CtrlData,           // Control Data (to be written to the PHY input.)
input        RStatStart,         // This signal resets the RSTAT BIT in the MIIM Command inputister
input           ScanStat_q1,        // Scan Status operation delayed 1 cycle
input          EndOp,              // End of Operation
input         ScanStat,           // Scan Status operation
input         Reset,              // General Reset
input           InProgress_q1,      // Operation in progress delayed 1 Mdc cycle
input     [6:0] BitCounter,         // Bit Counter
input        Mdc,                // MII Management Data Clock
input           RStat_q3,           // Read Status operation delayed 3 Clk cycles
input [15:0] Prsd,               // Read Status Data (data read from the PHY)
input           EndBusy_d,          // Pre-end Busy signal
input           WCtrlDataStart_q,
input         Clk,                // Host Clock
input           RStatStart_q2,      // Start Read Status Command delayed 2 Mdc cycles
input         RStat,              // Read Status operation

input           MdoEn_2d,
input         ShiftedBit,         // This bit is input of the shift inputister and is connected to the Mdo signal
input           MdoEn_d,
input           Mdo_d,
input           Mdo,                // MII Management Data Output
input           Mdo_2d,
input           MdoEn,
input          SerialEn,
input   [7:0] ShiftReg,         // Shift inputister for shifting the data in and out
input       MdcEn_n,          // Enable signal is asserted for one Clk period before Mdc falls.
input [4:0] Rgad,             // Register address (within the selected PHY)
input [3:0] ByteSelect,       // Byte select
input [1:0] LatchByte,        // Byte select for latching (read operation)
input      LinkFail,         // Link Integrity Signal
input TempDivider,
input Counter,
input CounterPreset,
input CountEq0
);

assert property(@(posedge Clk)  (Reset) |-> (EndBusy_d == 0));assert property(@(posedge Clk)  (Reset) |-> (EndBusy == 0));assert property(@(posedge Clk)  (EndBusy & ~WCtrlDataStart_q) |-> (UpdateMIIRX_DATAReg == 1));assert property(@(posedge Clk)  (~EndBusy & ~WCtrlDataStart_q) |-> (UpdateMIIRX_DATAReg == 0));assert property(@(posedge Clk)  (Reset) |-> (WCtrlData_q1 == 0));assert property(@(posedge Clk)  (Reset) |-> (WCtrlData_q2 == 0));assert property(@(posedge Clk)  (Reset) |-> (WCtrlData_q3 == 0));assert property(@(posedge Clk)  (Reset) |-> (RStat_q1 == 0));assert property(@(posedge Clk)  (Reset) |-> (RStat_q2 == 0));assert property(@(posedge Clk)  (Reset) |-> (RStat_q3 == 0));assert property(@(posedge Clk)  (Reset) |-> (ScanStat_q1 == 0));assert property(@(posedge Clk)  (Reset) |-> (ScanStat_q2 == 0));assert property(@(posedge Clk)  (Reset) |-> (SyncStatMdcEn == 0));assert property(@(posedge Clk)  (MdcEn) |-> (SyncStatMdcEn == ScanStat_q2));assert property(@(posedge Clk)  (Reset) |-> (WCtrlDataStart == 0));assert property(@(posedge Clk)  (Reset) |-> (WCtrlDataStart_q == 0));assert property(@(posedge Clk)  (Reset) |-> (RStatStart == 0));assert property(@(posedge Clk)  (EndBusy) |-> (WCtrlDataStart == 0));assert property(@(posedge Clk)  (EndBusy) |-> (RStatStart == 0));assert property(@(posedge Clk)  (WCtrlData_q2 & ~WCtrlData_q3) |-> (WCtrlDataStart == 1));assert property(@(posedge Clk)  (RStat_q2 & ~RStat_q3) |-> (RStatStart == 1));assert property(@(posedge Clk)  (Reset) |-> (Nvalid == 0));assert property(@(posedge Clk)  (~InProgress_q2 & InProgress_q3) |-> (Nvalid == 0));assert property(@(posedge Clk)  (ScanStat_q2 & ~SyncStatMdcEn) |-> (Nvalid == 1));assert property(@(posedge Clk)  (Reset) |-> (WCtrlDataStart_q1 == 0));assert property(@(posedge Clk)  (Reset) |-> (WCtrlDataStart_q2 == 0));assert property(@(posedge Clk)  (Reset) |-> (RStatStart_q1 == 0));assert property(@(posedge Clk)  (Reset) |-> (RStatStart_q2 == 0));assert property(@(posedge Clk)  (Reset) |-> (InProgress_q1 == 0));assert property(@(posedge Clk)  (Reset) |-> (InProgress_q2 == 0));assert property(@(posedge Clk)  (Reset) |-> (InProgress_q3 == 0));assert property(@(posedge Clk)  (Reset) |-> (LatchByte0_d == 0));assert property(@(posedge Clk)  (Reset) |-> (LatchByte1_d == 0));assert property(@(posedge Clk)  (Reset) |-> (LatchByte == 2'b00));assert property(@(posedge Clk)  (MdcEn) |-> (WCtrlDataStart_q1 == WCtrlDataStart));assert property(@(posedge Clk)  (MdcEn) |-> (WCtrlDataStart_q2 == WCtrlDataStart_q1));assert property(@(posedge Clk)  (MdcEn) |-> (RStatStart_q1 == RStatStart));assert property(@(posedge Clk)  (MdcEn) |-> (RStatStart_q2 == RStatStart_q1));assert property(@(posedge Clk)  (MdcEn) |-> (LatchByte[0] == LatchByte0_d));assert property(@(posedge Clk)  (MdcEn) |-> (LatchByte[1] == LatchByte1_d));assert property(@(posedge Clk)  (MdcEn) |-> (LatchByte0_d == LatchByte0_d2));assert property(@(posedge Clk)  (MdcEn) |-> (LatchByte1_d == LatchByte1_d2));assert property(@(posedge Clk)  (MdcEn) |-> (InProgress_q1 == InProgress));assert property(@(posedge Clk)  (MdcEn) |-> (InProgress_q2 == InProgress_q1));assert property(@(posedge Clk)  (MdcEn) |-> (InProgress_q3 == InProgress_q2));assert property(@(posedge Clk)  (Reset) |-> (Busy == 0));assert property(@(posedge Clk)  (WCtrlData | WCtrlDataStart | RStat | RStatStart | SyncStatMdcEn | EndBusy | InProgress | InProgress_q3 | Nvalid) |-> (Busy == 1));assert property(@(posedge Clk)  (~(WCtrlData | WCtrlDataStart | RStat | RStatStart | SyncStatMdcEn | EndBusy | InProgress | InProgress_q3 | Nvalid)) |-> (Busy == 0));assert property(@(posedge Clk)  (Reset) |-> (InProgress == 0));assert property(@(posedge Clk)  (Reset) |-> (WriteOp == 0));assert property(@(posedge Clk)  (MdcEn & StartOp & ~InProgress) |-> (WriteOp == WriteDataOp));assert property(@(posedge Clk)  (MdcEn & StartOp) |-> (InProgress == 1));assert property(@(posedge Clk)  ();
endmodule