parameter N = 8;
module i_signed_mult_const_asic(
input			rstn,
input			clk,
input [N  :0] p, // product input
input [N+7:0] mult_wo_sign, // mult without sign
input [N-1:0] a_FF,
input			valid,
input  [N-1:0] a, // variable - positive/negative
input [N-1:0] b,
input [N-1:0] div256 // divided 256
);

assert property(@(posedge clk)  (a_FF[N-1] == 0) |-> (a[N-1:0] == a_FF[N-1:0]));
assert property(@(posedge clk)  (a_FF[N-1] == 1) |-> (mult_wo_sign[N+7:0] == {~b[N-1:0] + {{N-1{1'b0}},1'b1}} * mult_constant));
assert property(@(posedge clk)  (a_FF[N-1] == 0) |-> (b[N-1:0] == a_FF[N-1:0]));
assert property(@(posedge clk)  (a_FF[N-1] == 0) |-> (a_FF[N-1:0] == a[N-1:0]));
assert property(@(posedge clk)  (a_FF[N-1] == 1) |-> (b[N-1:0] == {~a_FF[N-1:0] + {{N-1{1'b0}},1'b1}}));
assert property(@(posedge clk)  (a_FF[N-1] == 1) |-> (a[N-1:0] == {~a_FF[N-1:0] + {{N-1{1'b0}},1'b1}}));
assert property(@(posedge clk)  (a_FF[N-1] == 1) |-> (p[N-1:0] == {~div256[N-1:0] + {{N-1{1'b0}},1'b1}}));
assert property(@(posedge clk)  (a_FF[N-1] == 0) |-> (div256[N-1:0] == a_FF[N-1:0]));
assert property(@(posedge clk)  (a_FF[N-1] == 0) |-> (p[N-1:0] == div256[N-1:0]));
assert property(@(posedge clk)  (a_FF[N-1] == 1) |-> (a_FF[N-1:0] == {~a[N-1:0] + {{N-1{1'b0}},1'b1}}));
assert property(@(posedge clk)  (a_FF[N-1] == 0) |-> (mult_wo_sign[N+7:0] == b[N-1:0] * mult_constant));
assert property(@(posedge clk)  (a_FF[N-1] == 1) |-> (p[N] == 1));
assert property(@(posedge clk)  (a_FF[N-1] == 0) |-> (p[N] == 0));
assert property(@(posedge clk)  (a_FF[N-1] == 1) |-> (div256[N-1:0] == {~a_FF[N-1:0] + {{N-1{1'b0}},1'b1}}));

endmodule