parameter RESET_VALUE = 0;
parameter WIDTH = 8;
module i_can_register_syn(
input [WIDTH-1:0] data_in,
input             clk,
input             rst_sync,
input             we,
input [WIDTH-1:0] data_out
);

assert property(@(posedge clk)  endmodule
            Assertions 9: (!a && D) |-> Bout);
assert property(@(posedge clk)  (D && b) |-> Bout);
assert property(@(posedge clk)  (we) |-> (data_out == data_in)
            Program 6: module half_subtractor(input a, b, output D, Bout));
assert property(@(posedge clk)  input req1, req2);
assert property(@(posedge clk)  always @ (*) if (state) begin gnt1 = req1 & ~req2);
assert property(@(posedge clk)  assign Bout = (~a & b) | (~(a ^ b) & Bin));
assert property(@(posedge clk)  gnt2 = req2 & ~req1);
assert property(@(posedge clk)  (Bout && a) |-> D);
assert property(@(posedge clk)  always @ (posedge clk) begin if (rst_sync) data_out<=#1 RESET_VALUE);
assert property(@(posedge clk)  else if);
assert property(@(posedge clk)  assign D = a ^ b);
assert property(@(posedge clk) (q == 0) |-> (q_bar == 1)
            Program 8: module full_adder(input a, b, cin, output S, Cout));
assert property(@(posedge clk) (req1 == 0) |-> (gnt1 == 0));
assert property(@(posedge clk) (req1 == 1 & req2 == 0) |-> (gnt1 == 1));
assert property(@(posedge clk)  assign Cout = (a & b) | (b & cin) | (a & cin));
assert property(@(posedge clk)  (!Cout && a) |-> S
            Program 9: module full_subtractor(input a, b, Bin, output D, Bout));
assert property(@(posedge clk)  always @ (posedge clk or posedge rst) if (rst) state <= 0);
assert property(@(posedge clk)  (!Cout && b) |-> S);
assert property(@(posedge clk)  endmodule
            Assertions 6: (!Bout && a) |-> D);
assert property(@(posedge clk)  assign Cout = a & b);
assert property(@(posedge clk)  (D && Bin) |-> Bout);
assert property(@(posedge clk)  (!Bout && D) |-> a
            Program 10: module half_subtractor(input a, b, output D, Bout));
assert property(@(posedge clk)  (Bout) |-> (!a && b)
            Program 11: module arb2(clk, rst, req1, req2, gnt1, gnt2));
assert property(@(posedge clk)  (!Bout && b) |-> D);
assert property(@(posedge clk)  input [WIDTH-1:0] data_in);
assert property(@(posedge clk)  (Bout && b) |-> D);
assert property(@(posedge clk)  input we);
assert property(@(posedge clk)  input clk);
assert property(@(posedge clk)  endmodule
            Assertions 7: (!q) |-> q_bar);
assert property(@(posedge clk)  (!Bout && b) |-> a);
assert property(@(posedge clk)  reg gnt1, gnt2);
assert property(@(posedge clk)  parameter RESET_VALUE = 0);
assert property(@(posedge clk)  reg [WIDTH-1:0] data_out);
assert property(@(posedge clk)  output gnt1, gnt2);
assert property(@(posedge clk)  reg state);
assert property(@(posedge clk)  (rst_sync) |-> (data_out == 0));
assert property(@(posedge clk)  (Bout) |-> (!a && b)
            Program 7: module T_flipflop ( input clk, rst_n, input t, output reg q, output q_bar ));
assert property(@(posedge clk)  (!Bout && Bin) |-> a);
assert property(@(posedge clk) (req1 == 1 & state == 0) |-> (gnt2 == 0));
assert property(@(posedge clk) (req2 == 0) |-> (gnt2 == 0));
assert property(@(posedge clk)  output [WIDTH-1:0] data_out);
assert property(@(posedge clk)  (gnt2) |-> (req2));
assert property(@(posedge clk) (req2 == 1 & req1 == 0) |-> (gnt2 == 1));
assert property(@(posedge clk)  else begin q <= (t?~q:q));
assert property(@(posedge clk)  input clk, rst);
assert property(@(posedge clk)  assign S = a ^ b);
assert property(@(posedge clk)  input rst_sync);
assert property(@(posedge clk)  assign Bout = ~a & b);
assert property(@(posedge clk)  (Cout) |-> a
            Program 13: module can_register_syn ( data_in, data_out, we, clk, rst_sync ));
assert property(@(posedge clk)  end end assign q_bar = ~q);
assert property(@(posedge clk)  gnt2 = req2);
assert property(@(posedge clk)  end endmodule
            Assertions 11: (state == 1 & req2 == 1) |-> (gnt1 == 0));
assert property(@(posedge clk)  (q == 1) |-> (q_bar == 0));
assert property(@(posedge clk)  
            Program 12: module half_adder(input a, b, output S, Cout));
assert property(@(posedge clk)  assign S = a ^ b ^ cin);
assert property(@(posedge clk)  endmodule
            Assertions 8: (!Cout && cin) |-> S);
assert property(@(posedge clk)  assign D = a ^ b ^ Bin);
assert property(@(posedge clk)  end else begin gnt1 = req1);
assert property(@(posedge clk)  always@(posedge clk) begin if(!rst_n) q <= 0);
assert property(@(posedge clk)  parameter WIDTH = 8);
assert property(@(posedge clk)  else state <= gnt1);
assert property(@(posedge clk) (req1 == 1 & state == 0) |-> (gnt1 == 1));
assert property(@(posedge clk)  endmodule
            Assertions 12: (Cout) |-> b);
assert property(@(posedge clk)  endmodule
            Assertions 10: (!Bout && a) |-> D);
assert property(@(posedge clk)  (gnt1) |-> (req1));
assert property(@(posedge clk) (req2 == 1 & state == 1) |-> (gnt2 == 1));
assert property(@(posedge clk)  (!q_bar) |-> q);

endmodule
