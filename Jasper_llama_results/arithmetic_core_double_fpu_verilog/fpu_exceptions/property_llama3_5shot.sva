module i_fpu_exceptions(
input		[63:0]	out_1,
input		inexact_trigger,
input		subtract,
input	[1:0]	rmode,
input	[1:0]	mantissa_in,
input		in_et_zero,
input		sub_inf,
input		round_nearest,
input		[63:0]	out_0,
input	[10:0]  exp_2046 ,
input		inexact,
input		a_NaN,
input		[62:0]	inf_round_down,
input		opb_inf,
input		mul_inf,
input		div_inf,
input		clk,
input		overflow_trigger ,
input	[63:0]	in_except,
input		SNaN_trigger,
input		out_inf_trigger,
input	[63:0]	out,
input		overflow,
input		div_by_0,
input		opa_QNaN,
input	[63:0]	opb,
input		multiply,
input		[62:0] NaN_input_0, 
input		divide,
input		addsub_inf,
input		opb_SNaN,
input		addsub_inf_invalid,
input		rst,
input		opb_et_zero,
input		underflow_trigger,			
input		underflow,
input		div_by_inf,
input	[10:0]  exp_2047 ,
input		SNaN_input,
input		opb_pos_inf,
input		mul_0_by_inf,
input		enable,
input	[2:0]	fpu_op,
input		[63:0]	out_2,
input		add,
input		add_inf,
input		opa_neg_inf,
input	[63:0]	opa,
input		div_inf_by_inf,
input		out_neg_inf,
input		opa_pos_inf,
input		round_to_neg_inf,
input		invalid,
input		opa_et_zero,
input		round_to_pos_inf,
input		NaN_out_trigger,
input	[51:0]  mantissa_max ,
input		ex_enable,
input	[11:0]	exponent_in,
input		invalid_trigger,
input		[62:0]	out_inf,
input		opb_QNaN,
input		opa_SNaN,
input		opb_neg_inf,
input		exception,
input		enable_trigger,
input		div_uf,								
input		mul_uf,
input		round_to_zero,
input		input_et_zero,
input		out_pos_inf,
input		div_0_by_0,
input		opa_inf,
input		inf_round_down_trigger,
input	 	except_trigger,
input		[62:0] NaN_input ,
input           [62:0] NaN_output_0,
input           [62:0] NaN_output

);

assert property(@(posedge clk) (enable && underflow_trigger) |-> (underflow == 1));
assert property(@(posedge clk) (enable &&!out_inf_trigger) |-> (out_1[63:0] == out_0[63:0]));
assert property(@(posedge clk) (enable &&!a_NaN) |-> (NaN_output_0[63:0] == { exp_2047, 1'b1, opb[50:0]}));
assert property(@(posedge clk) (rst) |-> (inexact == 0));
assert property(@(posedge clk) (rst) |-> (overflow == 0));
assert property(@(posedge clk) (enable && (rmode == 2'b10)) |-> (round_to_pos_inf == 1));
assert property(@(posedge clk) (enable && (rmode == 2'b01)) |-> (round_to_zero == 1));
assert property(@(posedge clk) (enable &&!(rmode == 2'b01)) |-> (round_to_zero == 0));
assert property(@(posedge clk) (enable && inf_round_down_trigger) |-> (out_inf[63:0]!= { exp_2047, 52'b0 }));
assert property(@(posedge clk) (enable && (rmode == 2'b11)) |-> (round_to_neg_inf == 1));
assert property(@(posedge clk) (enable && (out_neg_inf & round_to_pos_inf)) |-> (inf_round_down_trigger == 1));
assert property(@(posedge clk) (enable && out_2[63:0]!= in_except[63:0]) |-> (out!= out_2));
assert property(@(posedge clk) (enable && (out_inf_trigger & round_to_zero)) |-> (inf_round_down_trigger == 1));
assert property(@(posedge clk) (enable && out_inf_trigger) |-> (out_1[63:0]!= out_0[63:0]));
assert property(@(posedge clk) (enable &&!SNaN_trigger) |-> (NaN_output[63:0] == NaN_output_0[63:0]));
assert property(@(posedge clk) (enable &&!(rmode == 2'b10)) |-> (round_to_pos_inf == 0));
assert property(@(posedge clk) (rst) |-> (exception == 0));
assert property(@(posedge clk) (enable &&!(rmode == 2'b11)) |-> (round_to_neg_inf == 0));
assert property(@(posedge clk) (enable &&!inf_round_down_trigger) |-> (out_inf[63:0] == { exp_2047, 52'b0 }));
assert property(@(posedge clk) (rst) |-> (out == 0));
assert property(@(posedge clk) (enable &&!(out_pos_inf & round_to_neg_inf)) |-> (inf_round_down_trigger == 0));
assert property(@(posedge clk) (enable &&!(rmode == 2'b00)) |-> (round_nearest == 0));
assert property(@(posedge clk) (rst) |-> (invalid == 0));
assert property(@(posedge clk) (enable && (out_pos_inf & round_to_neg_inf)) |-> (inf_round_down_trigger == 1));
assert property(@(posedge clk) (enable && underflow_trigger) |-> (out_0[63:0]!= in_except[63:0]));
assert property(@(posedge clk) (enable && overflow_trigger) |-> (overflow == 1));
assert property(@(posedge clk) (enable &&!(out_inf_trigger & round_to_zero)) |-> (inf_round_down_trigger == 0));
assert property(@(posedge clk) (enable && enable_trigger) |-> (ex_enable == 1));
assert property(@(posedge clk) (enable && out_0[63:0]!= in_except[63:0]) |-> (out_1!= out_0));
assert property(@(posedge clk) (enable && SNaN_trigger) |-> (NaN_output[63:0]!= NaN_output_0[63:0]));
assert property(@(posedge clk) (enable && out_1[63:0] == in_except[63:0]) |-> (out_2 == out_1));
assert property(@(posedge clk) (enable && inexact_trigger) |-> (inexact == 1));
assert property(@(posedge clk) (enable && out_2[63:0] == in_except[63:0]) |-> (out == out_2));
assert property(@(posedge clk) (enable && out_1[63:0]!= in_except[63:0]) |-> (out_2!= out_1));
assert property(@(posedge clk) (enable && NaN_input) |-> (out_2[63:0]!= out_1[63:0]));
assert property(@(posedge clk) (enable &&!(out_neg_inf & round_to_pos_inf)) |-> (inf_round_down_trigger == 0));
assert property(@(posedge clk) (enable && (rmode == 2'b00)) |-> (round_nearest == 1));
assert property(@(posedge clk) ();
assert property(@(posedge clk) (enable &&!NaN_input) |-> (out_2[63:0] == out_1[63:0]));
assert property(@(posedge clk) (enable && invalid_trigger) |-> (invalid == 1));
assert property(@(posedge clk) (enable && out_0[63:0] == in_except[63:0]) |-> (out_1 == out_0));
assert property(@(posedge clk) (enable && except_trigger) |-> (exception == 1));
assert property(@(posedge clk) (enable && a_NaN) |-> (NaN_output_0[63:0]!= { exp_2047, 1'b1, opb[50:0]}));
assert property(@(posedge clk) (rst) |-> (underflow == 0));
assert property(@(posedge clk)  (rst) |-> (ex_enable == 0));
assert property(@(posedge clk) (enable &&!underflow_trigger) |-> (out_0[63:0] == in_except[63:0]));

endmodule