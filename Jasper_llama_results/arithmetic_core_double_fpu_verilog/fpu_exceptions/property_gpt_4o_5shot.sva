module i_fpu_exceptions(
input		[63:0]	out_1,
input		inexact_trigger,
input		subtract,
input	[1:0]	rmode,
input	[1:0]	mantissa_in,
input		in_et_zero,
input		sub_inf,
input		round_nearest,
input		[63:0]	out_0,
input	[10:0]  exp_2046 ,
input		inexact,
input		a_NaN,
input		[62:0]	inf_round_down,
input		opb_inf,
input		mul_inf,
input		div_inf,
input		clk,
input		overflow_trigger ,
input	[63:0]	in_except,
input		SNaN_trigger,
input		out_inf_trigger,
input	[63:0]	out,
input		overflow,
input		div_by_0,
input		opa_QNaN,
input	[63:0]	opb,
input		multiply,
input		[62:0] NaN_input_0, 
input		divide,
input		addsub_inf,
input		opb_SNaN,
input		addsub_inf_invalid,
input		rst,
input		opb_et_zero,
input		underflow_trigger,			
input		underflow,
input		div_by_inf,
input	[10:0]  exp_2047 ,
input		SNaN_input,
input		opb_pos_inf,
input		mul_0_by_inf,
input		enable,
input	[2:0]	fpu_op,
input		[63:0]	out_2,
input		add,
input		add_inf,
input		opa_neg_inf,
input	[63:0]	opa,
input		div_inf_by_inf,
input		out_neg_inf,
input		opa_pos_inf,
input		round_to_neg_inf,
input		invalid,
input		opa_et_zero,
input		round_to_pos_inf,
input		NaN_out_trigger,
input	[51:0]  mantissa_max ,
input		ex_enable,
input	[11:0]	exponent_in,
input		invalid_trigger,
input		[62:0]	out_inf,
input		opb_QNaN,
input		opa_SNaN,
input		opb_neg_inf,
input		exception,
input		enable_trigger,
input		div_uf,								
input		mul_uf,
input		round_to_zero,
input		input_et_zero,
input		out_pos_inf,
input		div_0_by_0,
input		opa_inf,
input		inf_round_down_trigger,
input	 	except_trigger,
input		[62:0] NaN_input ,
input           [62:0] NaN_output_0,
input           [62:0] NaN_output

);

assert property(@(posedge clk) (enable) |-> (ex_enable == enable_trigger));assert property(@(posedge clk) (enable) |-> (underflow == underflow_trigger));assert property(@(posedge clk) (enable) |-> (overflow == overflow_trigger));assert property(@(posedge clk) (enable) |-> (inexact == inexact_trigger));assert property(@(posedge clk) (enable) |-> (exception == except_trigger));assert property(@(posedge clk) (enable) |-> (invalid == invalid_trigger));assert property(@(posedge clk) (enable) |-> (out == out_2));assert property(@(posedge clk) (out_inf_trigger) |-> (out_pos_inf == (!in_except[63])));assert property(@(posedge clk) (out_inf_trigger) |-> (out_neg_inf == in_except[63]));assert property(@(posedge clk) (NaN_input) |-> (NaN_out_trigger));assert property(@(posedge clk) (SNaN_input) |-> (invalid_trigger));assert property(@(posedge clk) (div_by_0) |-> (div_0_by_0 == (opb_et_zero & opa_et_zero)));assert property(@(posedge clk) (div_inf_by_inf) |-> (div_by_inf == (!opa_inf & opb_inf)));assert property(@(posedge clk) (mul_0_by_inf) |-> (mul_inf == ((opa_inf | opb_inf) & !mul_0_by_inf)));assert property(@(posedge clk) (div_inf) |-> (add_inf == (add & (opa_inf | opb_inf))));assert property(@(posedge clk) (sub_inf) |-> (addsub_inf_invalid == ((add & opa_pos_inf & opb_neg_inf) | (add & opa_neg_inf & opb_pos_inf) | (subtract & opa_pos_inf & opb_pos_inf) | (subtract & opa_neg_inf & opb_neg_inf))));assert property(@(posedge clk) (addsub_inf) |-> (out_inf_trigger == (addsub_inf | mul_inf | div_inf | div_by_0 | (exponent_in > 2046))));assert property(@(posedge clk) (out_inf_trigger) |-> (inf_round_down_trigger == ((out_pos_inf & round_to_neg_inf) | (out_neg_inf & round_to_pos_inf) | (out_inf_trigger & round_to_zero))));assert property(@(posedge clk) (multiply) |-> (mul_uf == (!opa_et_zero & !opb_et_zero & in_et_zero)));assert property(@(posedge clk) (divide) |-> (div_uf == (!opa_et_zero & in_et_zero)));assert property(@(posedge clk) (div_by_inf) |-> (underflow_trigger == (div_by_inf | mul_uf | div_uf)));assert property(@(posedge clk) (SNaN_input) |-> (invalid_trigger == (SNaN_input | addsub_inf_invalid | mul_0_by_inf | div_0_by_0 | div_inf_by_inf)));assert property(@(posedge clk) (out_inf_trigger) |-> (overflow_trigger == (out_inf_trigger & !NaN_input)));assert property(@(posedge clk) (mantissa_in) |-> (inexact_trigger == ((|mantissa_in[1:0] | out_inf_trigger | underflow_trigger) & !NaN_input)));assert property(@(posedge clk) (except_trigger) |-> (enable_trigger == (except_trigger | out_inf_trigger | NaN_input)));assert property(@(posedge clk) (invalid_trigger) |-> (SNaN_trigger == (invalid_trigger & !SNaN_input)));assert property(@(posedge clk) (a_NaN) |-> (NaN_output_0 == ({ exp_2047, 1'b1, opa[50:0]})));assert property(@(posedge clk) (SNaN_trigger) |-> (NaN_output == ({ exp_2047, 2'b01, opa[49:0]})));assert property(@(posedge clk) (inf_round_down_trigger) |-> (out_inf == (inf_round_down_trigger ? inf_round_down : { exp_2047, 52'b0 })));assert property(@(posedge clk) (underflow_trigger) |-> (out_0 == (underflow_trigger ? { in_except[63], 63'b0 } : in_except)));assert property(@(posedge clk) (out_inf_trigger) |-> (out_1 == (out_inf_trigger ? { in_except[63], out_inf } : out_0)));assert property(@(posedge clk) (NaN_out_trigger) |-> (out_2 == (NaN_out_trigger ? { in_except[63], NaN_output} : out_1)));
endmodule